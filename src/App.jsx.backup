import React, { useState, useEffect, useRef } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { ref, push, set, onValue, off, update, remove, serverTimestamp, onDisconnect, get } from 'firebase/database';
import { db, functions as fbFunctions } from './firebase';
import { httpsCallable } from 'firebase/functions';
import { createUserProfile, checkUserProfileExists } from './utils/profile';
import Game from './components/Game';
import AchievementPopup from './components/popups/AchievementPopup';
import GameLogPopup from './components/popups/GameLogPopup';
import RoundEndPopup from './components/popups/RoundEndPopup';
import EliminatedPopup from './components/popups/EliminatedPopup';
import WhotShapePopup from './components/popups/WhotShapePopup';
import ProfilePopup from './components/popups/ProfilePopup';
import LeaderboardPopup from './components/popups/LeaderboardPopup';
import SettingsPopup from './components/popups/SettingsPopup';
import GameModePopup from './components/popups/GameModePopup';
import HelpPopup from './components/popups/HelpPopup';
import Confetti from 'react-confetti';
import { createDeck, shuffleDeck } from './utils/deck';
import { getCardSVGContent } from './utils/cardSVG';

import soundEffects from './utils/soundEffects';
import { ArrowLeft, ChevronRight, Play, Settings, Award, Shield, Wifi, Bot, X, Users, Plus, Crown, Clock } from 'lucide-react';
import './App.css';
// getCardSVGContent is imported from utils/cardSVG.js

const App = () => {
  const MAX_VISIBLE_AI_CARDS = 3;
  
  // Animation types
  const ANIMATION_TYPES = {
    OPPONENT_PLAY: 'opponent-play',
    OPPONENT_DRAW: 'opponent-draw',
    PLAYER_PLAY: 'player-play',
    PLAYER_DRAW: 'player-draw',
    DEALING: 'dealing'
  };
  
  // Load initial state from localStorage
  const getInitialState = (key, defaultValue) => {
    try {
      const saved = localStorage.getItem(`whotgo_${key}`);
      return saved ? JSON.parse(saved) : defaultValue;
    } catch (error) {
      console.warn(`Failed to load ${key} from localStorage:`, error);
      return defaultValue;
    }
  };

  const [currentCard, setCurrentCard] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  const [gameState, setGameState] = useState('landing'); // Always start at landing, no localStorage
  const [currentUser, setCurrentUser] = useState(() => getInitialState('currentUser', null));
  const [rooms, setRooms] = useState([]);
  const [currentRoom, setCurrentRoom] = useState(null); // Always start with no room, no localStorage
  const [gameCountdown, setGameCountdown] = useState(null); // Always start with no countdown, no localStorage
  const lastRoomGameDataRef = useRef(null);
  const [turnTimer, setTurnTimer] = useState(null); // Always start with no timer, no localStorage
  const [gameData, setGameData] = useState(null); // Always start with no game data, no localStorage
  const [dealtCountsByPlayer, setDealtCountsByPlayer] = useState([]);
  const [playPileRevealed, setPlayPileRevealed] = useState(false);
  const [showWhotChoice, setShowWhotChoice] = useState(false);
  const [activePopup, setActivePopup] = useState(null);
  const [pendingWhotCard, setPendingWhotCard] = useState(null);
  const [animatingCards, setAnimatingCards] = useState([]);
  const [marketCardPositions, setMarketCardPositions] = useState([]);
  const [needNewMarketPositions, setNeedNewMarketPositions] = useState(false);
  const [playPileCardPositions, setPlayPileCardPositions] = useState({});
  const [playerScrollIndex, setPlayerScrollIndex] = useState(0);
  const [lastGameActivity, setLastGameActivity] = useState(null);
  const gameTimeoutRef = useRef(null);
  const [maxVisiblePlayerCards, setMaxVisiblePlayerCards] = useState(6);
  const [showDeckView, setShowDeckView] = useState(false);
  const [isPlayerActionInProgress, setIsPlayerActionInProgress] = useState(false);
  const [isAITurnInProgress, setIsAITurnInProgress] = useState(false);
  const [isAnyAnimationInProgress, setIsAnyAnimationInProgress] = useState(false);
  const isAnimationInProgressRef = useRef(false);
  const [showEliminatedPopup, setShowEliminatedPopup] = useState(false);
  const [showRoundEndPopup, setShowRoundEndPopup] = useState(false);
  const [roundEndData, setRoundEndData] = useState(null);
  const [readyPlayers, setReadyPlayers] = useState([]);
  const [showGameLog, setShowGameLog] = useState(false);
  const [selectedLogRound, setSelectedLogRound] = useState(1);
  const [animationPositions, setAnimationPositions] = useState({});
  const [, setPlayPilePositions] = useState([]);
  const prevGameDataRef = useRef(null);
  
  // Save state to localStorage
  const saveToLocalStorage = (key, value) => {
    try {
      localStorage.setItem(`whotgo_${key}`, JSON.stringify(value));
    } catch (error) {
      console.warn(`Failed to save ${key} to localStorage:`, error);
    }
  };

  // Save only user state to localStorage, not game states
  useEffect(() => {
    saveToLocalStorage('currentUser', currentUser);
  }, [currentUser]);

  // Don't save game-related states to localStorage to prevent restoration

  // Clear localStorage when returning to menu or on reload
  const clearGameState = () => {
    // Clear all game-related localStorage items
    localStorage.removeItem('whotgo_gameState');
    localStorage.removeItem('whotgo_currentUser');
    localStorage.removeItem('whotgo_currentRoom');
    localStorage.removeItem('whotgo_gameCountdown');
    localStorage.removeItem('whotgo_turnTimer');
    localStorage.removeItem('whotgo_gameData');
    localStorage.removeItem('whotgo_lastGameActivity');
    localStorage.removeItem('whotgo_playerScrollIndex');
    localStorage.removeItem('whotgo_showWhotChoice');
    localStorage.removeItem('whotgo_pendingWhotCard');
    localStorage.removeItem('whotgo_activePopup');
    localStorage.removeItem('whotgo_isPlayerActionInProgress');
    localStorage.removeItem('whotgo_isAITurnInProgress');
    localStorage.removeItem('whotgo_isAnyAnimationInProgress');
    
    console.log('All game states cleared from localStorage');
  };

  // Handle page visibility changes
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        // Page became visible again - check if we need to restore state
        if (gameState === 'game' && gameData) {
          // We're in a game, make sure the state is properly restored
          console.log('Page became visible, restoring game state');
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [gameState, gameData]);

  // Check if multiplayer room still exists and handle reconnection
  const checkAndReconnectToRoom = async (roomId) => {
    try {
      const roomRef = ref(db, `rooms/${roomId}`);
      const roomSnapshot = await get(roomRef);
      
      if (roomSnapshot.exists()) {
        const roomData = roomSnapshot.val();
        // Check if current user is still in the room
        if (roomData.players && roomData.players[currentUser?.id]) {
          console.log('Successfully reconnected to room');
          setCurrentRoom({ ...roomData, id: roomId });
          return true;
        } else {
          console.log('User no longer in room, clearing state');
          clearGameState();
          setGameState('menu');
          return false;
        }
      } else {
        console.log('Room no longer exists, clearing state');
        clearGameState();
        setGameState('menu');
        return false;
      }
    } catch (error) {
      console.error('Error checking room status:', error);
      clearGameState();
      setGameState('menu');
      return false;
    }
  };

  // Clear any saved game state on app start to prevent auto-restoration
  useEffect(() => {
    // Clear game state on app initialization to always start fresh
    clearGameState();
    
    // Force reset all game-related state to ensure clean start
    setGameData(null);
    setGameState('landing');
    setCurrentRoom(null);
    setGameCountdown(null);
    setTurnTimer(null);
    setLastGameActivity(null);
    
    // Also clear on page reload/refresh
    const handleBeforeUnload = () => {
      clearGameState();
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, []); // Run only once on mount

  // Update last activity timestamp when game actions occur
  const updateGameActivity = () => {
    setLastGameActivity(Date.now());
  };

  // Clear game after 5 minutes of inactivity
  useEffect(() => {
    if (!gameData || gameState !== 'game') {
      // Clear timeout if not in game
      if (gameTimeoutRef.current) {
        clearTimeout(gameTimeoutRef.current);
        gameTimeoutRef.current = null;
      }
      return;
    }

    // Start/restart timeout when game is active
    if (gameTimeoutRef.current) {
      clearTimeout(gameTimeoutRef.current);
    }

    gameTimeoutRef.current = setTimeout(() => {
      console.log('Game cleared due to 5 minutes of inactivity');
      
      // Clear the game state
      if (currentRoom) {
        // For multiplayer, leave the room
        leaveRoom();
      } else {
        // For AI game, return to menu
        returnToMenu();
      }
      
      // Clear all game-related state
      clearGameState();
      setGameData(null);
      setGameState('menu');
      setLastGameActivity(null);
    }, 5 * 60 * 1000); // 5 minutes

    return () => {
      if (gameTimeoutRef.current) {
        clearTimeout(gameTimeoutRef.current);
        gameTimeoutRef.current = null;
      }
    };
  }, [gameData, gameState, lastGameActivity, currentRoom]);

  // Initialize player deck positions
  const initializePlayerPositions = () => {
    const screenWidth = window.innerWidth;
    const positions = {
      playPile: {
        top: '50%',
        left: '50%',
        transform: `translate(calc(-50% - ${screenWidth < 768 ? '54px' : screenWidth < 1024 ? '72px' : '90px'}), -50%)`
      },
      market: {
        top: '50%',
        left: '50%',
        transform: `translate(calc(-50% + ${screenWidth < 768 ? '54px' : screenWidth < 1024 ? '72px' : '90px'}), -50%)`
      },
      playerDecks: {
        0: {
          bottom: '20px',
          left: '50%',
          transform: 'translateX(-50%)'
        },
        1: {
          left: '-120px',
          top: '50%',
          transform: 'translateY(-50%) rotate(-90deg)'
        },
        2: {
          top: '20px',
          left: '50%',
          transform: 'translateX(-50%)'
        },
        3: {
          right: '-120px',
          top: '50%',
          transform: 'translateY(-50%) rotate(90deg)'
        }
      },
      animationStarts: {
        0: {
          top: 'calc(100vh + 200px)',
          left: '50%',
          transform: 'translateX(-50%)',
          opacity: 0
        },
        1: {
          left: '-200px',
          top: '50%',
          transform: 'translateY(-50%)',
          opacity: 0
        },
        2: {
          top: '-200px',
          left: '50%',
          transform: 'translateX(-50%)',
          opacity: 0
        },
        3: {
          left: 'calc(100% + 200px)',
          top: '50%',
          transform: 'translateY(-50%)',
          opacity: 0
        }
      },
      drawEnds: {
        0: {
          top: 'calc(100vh - 120px)',
          left: '50%',
          transform: 'translateX(-50%)',
          opacity: 1
        },
        1: {
          left: '-120px',
          top: '50%',
          transform: 'translateY(-50%)',
          opacity: 1
        },
        2: {
          top: '20px',
          left: '50%',
          transform: 'translateX(-50%)',
          opacity: 1
        },
        3: {
          left: 'calc(100% + 120px)',
          top: '50%',
          transform: 'translateY(-50%)',
          opacity: 1
        }
      }
    };
    setAnimationPositions(positions);
  };
  
  const [adminCardsRevealed, setAdminCardsRevealed] = useState(false);
  const [adminMarketRevealed, setAdminMarketRevealed] = useState(false);
  const [showAdminDeckOverview, setShowAdminDeckOverview] = useState(false);
  
  // Initialize player positions on component mount
  useEffect(() => {
    initializePlayerPositions();
  }, []);
  const [leaderboardData, setLeaderboardData] = useState([]);
  const [achievements, setAchievements] = useState([]);
  const [musicVolume, setMusicVolume] = useState(75);
  const [soundVolume, setSoundVolume] = useState(85);
  const [showHelp, setShowHelp] = useState(false);
  
  // Update sound effects volume when soundVolume changes
  useEffect(() => {
    const volume = soundVolume / 100; // Convert percentage to 0-1 range
    soundEffects.setVolume(volume);
  }, [soundVolume]);
  const [confettiActive, setConfettiActive] = useState(false);
  const [isEditingUsername, setIsEditingUsername] = useState(false);
  const [newUsername, setNewUsername] = useState('');
  const [isLoadingAfterWalletConnect, setIsLoadingAfterWalletConnect] = useState(false);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const confettiCanvasRef = useRef(null);
  const marketCardPositionsRef = useRef([]);
  const playPilePositionsRef = useRef([]);
  const { publicKey, connected, signTransaction } = useWallet();
  const ADMIN_WALLET = 'DtdnqvRddQspZvRV5SJX2DeqxmLYef7Hqn9LFK9LioJS';
  const isAdmin = publicKey?.toBase58() === ADMIN_WALLET;

  const cards = [
    { shape: '●', number: '1', color: '#80142c' },
    { shape: '▲', number: '7', color: '#a01d39' },
    { shape: '✚', number: '13', color: '#661123' },
    { shape: '■', number: '10', color: '#550f1e' },
    { shape: '🔥', number: 'WHOT', color: '#4a0c1a' }
  ];

  useEffect(() => {
    const calculateMaxCards = () => {
      const screenWidth = window.innerWidth;
      const cardWidth = screenWidth < 768 ? 72 : screenWidth < 1024 ? 100 : 130;
      const availableWidth = screenWidth - 400;
      const cardSpacing = 6;
      const maxCards = Math.max(3, Math.floor(availableWidth / (cardWidth + cardSpacing)));
      setMaxVisiblePlayerCards(Math.min(maxCards, 7));
      const positions = {
        playPile: {
          top: '50%',
          left: '50%',
          transform: `translate(calc(-50% - ${screenWidth < 768 ? '54px' : screenWidth < 1024 ? '72px' : '90px'}), -50%)`
        },
        market: {
          top: '50%',
          left: '50%',
          transform: `translate(calc(-50% + ${screenWidth < 768 ? '54px' : screenWidth < 1024 ? '72px' : '90px'}), -50%)`
        },
        playerDecks: {
          0: {
            bottom: '20px',
            left: '50%',
            transform: 'translateX(-50%)'
          },
          1: {
            left: '-120px',
            top: '50%',
            transform: 'translateY(-50%) rotate(-90deg)'
          },
          2: {
            top: '20px',
            left: '50%',
            transform: 'translateX(-50%)'
          },
          3: {
            right: '-120px',
            top: '50%',
            transform: 'translateY(-50%) rotate(90deg)'
          }
        },
        animationStarts: {
          0: {
            top: 'calc(100vh + 200px)',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 0
          },
          1: {
            left: '-200px',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 0
          },
          2: {
            top: '-200px',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 0
          },
          3: {
            left: 'calc(100% + 200px)',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 0
          }
        },
        drawEnds: {
          0: {
            top: 'calc(100vh - 120px)',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 1
          },
          1: {
            left: '-120px',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 1
          },
          2: {
            top: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 1
          },
          3: {
            left: 'calc(100% + 120px)',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 1
          }
        }
      };
      setAnimationPositions(positions);
    };
    calculateMaxCards();
    window.addEventListener('resize', calculateMaxCards);
    return () => window.removeEventListener('resize', calculateMaxCards);
  }, []);

  useEffect(() => {
    setIsVisible(true);
    const interval = setInterval(() => {
      setCurrentCard(prev => (prev + 1) % cards.length);
    }, 2000);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    if (connected && publicKey) {
      checkUserProfileExists(publicKey).then(exists => {
        if (!exists) {
          createUserProfile({ publicKey, wallet: { publicKey, signTransaction } });
        }
        // Don't automatically redirect to menu - let user click the button
      });
    } else {
      setGameState('landing');
    }
  }, [connected, publicKey, signTransaction]);

  useEffect(() => {
    if (publicKey) {
      const userRef = ref(db, `users/${publicKey.toBase58()}`);
      const unsubscribe = onValue(userRef, snapshot => {
        if (snapshot.exists()) {
          const userData = { id: publicKey.toBase58(), ...snapshot.val() };
          setCurrentUser(userData);
          
          // Only update lastActive if it's been more than 30 seconds
          const lastActive = userData.lastActive;
          const now = Date.now();
          if (!lastActive || now - lastActive > 30000) {
            update(userRef, { lastActive: serverTimestamp() });
            onDisconnect(userRef).update({ lastActive: serverTimestamp() });
          }
        }
      });
      return () => unsubscribe();
    } else {
      setCurrentUser(null);
      setAchievements([]);
      setLeaderboardData([]);
      setIsLoadingAfterWalletConnect(false);
      setLoadingProgress(0);
    }
  }, [publicKey]);

  useEffect(() => {
    const roomsRef = ref(db, 'rooms');
    const unsubscribe = onValue(roomsRef, snapshot => {
      if (snapshot.exists()) {
        const roomsData = snapshot.val();
        const roomsList = Object.keys(roomsData).map(roomId => ({
          id: roomId,
          ...roomsData[roomId]
        })).filter(room => room.status === 'waiting' || room.status === 'countdown');
        setRooms(roomsList);
      } else {
        setRooms([]);
      }
    });
    return () => unsubscribe();
  }, []);

  useEffect(() => {
    if (currentUser) {
      initializeAchievements(currentUser);
      fetchLeaderboard();
    } else {
      setAchievements([]);
      setLeaderboardData([]);
    }
  }, [currentUser]);

  useEffect(() => {
    if (currentRoom) {
      const roomRef = ref(db, `rooms/${currentRoom.id}`);
      console.log('🔥 Setting up Firebase room listener for room:', currentRoom.id);
      const unsubscribe = onValue(roomRef, snapshot => {
        console.log('🔥 Firebase room update received for room:', currentRoom.id, 'Data:', snapshot.val());
        if (snapshot.exists()) {
          const roomData = {
            id: currentRoom.id,
            ...snapshot.val()
          };
          
          // Ensure current user is still in the room before updating
          if (roomData.players && currentUser && !roomData.players[currentUser.id]) {
            console.warn('Current user no longer in room players list, leaving room');
            leaveRoom();
            return;
          }
          
          setCurrentRoom(roomData);
          if (roomData.status === 'countdown' && roomData.countdown !== undefined) {
            setGameCountdown(roomData.countdown);
          } else {
            setGameCountdown(null);
          }
            if (roomData.status === 'playing' && roomData.gameData) {
            const newGameData = roomData.gameData;
            
            // Update gameData immediately - animations will be handled separately
            console.log('🔥 Updating gameData from Firebase:', newGameData);
            setGameData(newGameData);
            setGameState('game');
            
            // Handle dealingCards phase transition
            if (newGameData.gamePhase === 'dealingCards') {
              console.log('🎴 Multiplayer game started - cards already dealt, showing immediately');
              // Change game phase to playing immediately since cards are already dealt
              if (currentRoom) {
                update(ref(db, `rooms/${currentRoom.id}/gameData`), {
                  gamePhase: 'playing',
                  lastAction: 'Game started!'
                });
              }
            }
            
            // Only update gameData if no animations were triggered
            console.log('🔥 Updating gameData from Firebase (no animations):', newGameData);
            setGameData(newGameData);
            setGameState('game');
          }
        } else {
          setCurrentRoom(null);
          setGameState('menu');
        }
      });
      return () => off(roomRef, 'value', unsubscribe);
    }
  }, [currentRoom?.id, gameData, currentUser, animationPositions]);

  // Handle opponent animations based on gameData changes
  useEffect(() => {
    if (!gameData || !currentRoom || !currentUser) return;
    
    const prevGameData = prevGameDataRef.current;
    prevGameDataRef.current = gameData;
    
    if (!prevGameData) return; // Skip first render
    
    console.log('🎴 Animation useEffect triggered - checking for animations...');
    
    // Detect opponent moves using the animations module
    const moves = detectOpponentMoves(prevGameData, gameData, currentUser);
    
    if (moves.cardPlay || moves.cardDraw.length > 0) {
      console.log('🎴 Detected opponent moves:', moves);
      
      // Create wrappers for functions that use current context
      const getVisualPlayerMappingWrapper = () => getVisualPlayerMapping(currentRoom, currentUser);
      const getPlayPilePositionWrapper = (index, updatePositions) => getPlayPilePosition(index, updatePositions);
      const getTopMarketCardPositionWrapper = () => getTopMarketCardPosition();
      
      // Process animations
      const animations = processOpponentAnimations(
        moves, 
        animationPositions, 
        getVisualPlayerMappingWrapper, 
        getPlayPilePositionWrapper,
        getTopMarketCardPositionWrapper
      );
      
      if (animations.length > 0) {
        console.log('🎴 Starting animations:', animations);
        
        // Start animations with completion callback
        startAnimations(animations, setAnimatingCards, () => {
          console.log('🎴 All animations completed');
          // Update play pile positions after animation
          if (moves.cardPlay) {
            getPlayPilePosition(gameData.playPile.length - 1, true);
          }
        });
      }
    }
  }, [gameData, currentRoom, currentUser, animationPositions]);

  // Listen for ready players in multiplayer
  useEffect(() => {
    if (currentRoom && gameData?.gamePhase === 'roundEnd') {
      const readyPlayersRef = ref(db, `rooms/${currentRoom.id}/readyPlayers`);
      const unsubscribe = onValue(readyPlayersRef, (snapshot) => {
        const readyPlayersData = snapshot.val();
        if (readyPlayersData) {
          setReadyPlayers(readyPlayersData);
        }
      });
      return () => unsubscribe();
    }
  }, [currentRoom, gameData?.gamePhase]);



  const initializeUser = async walletAddress => {
    try {
      const userRef = ref(db, `users/${walletAddress}`);
      const unsubscribe = onValue(userRef, async snapshot => {
        if (snapshot.exists()) {
          const firebaseData = snapshot.val();
          const levelData = calculateLevel(firebaseData.xp || 0);
          const userData = {
            id: walletAddress,
            ...firebaseData,
            level: levelData.level,
            currentLevelXP: levelData.currentLevelXP,
            xpNeededForNext: levelData.xpNeededForNext
          };
          setCurrentUser(userData);
          await update(userRef, {
            lastActive: serverTimestamp(),
            level: levelData.level,
            currentLevelXP: levelData.currentLevelXP,
            xpNeededForNext: levelData.xpNeededForNext
          });
        } else {
          const levelData = calculateLevel(0);
          const newUserData = {
            id: walletAddress,
            username: `Player${Math.floor(Math.random() * 10000)}`,
            xp: 0,
            level: levelData.level,
            currentLevelXP: levelData.currentLevelXP,
            xpNeededForNext: levelData.xpNeededForNext,
            gamesPlayed: 0,
            gamesWon: 0,
            createdAt: serverTimestamp(),
            lastActive: serverTimestamp()
          };
          setCurrentUser(newUserData);
          await set(userRef, newUserData);
        }
        onDisconnect(userRef).update({
          lastActive: serverTimestamp()
        });
      });
      return unsubscribe;
    } catch (error) {
      console.error('Error initializing user:', error);
      const levelData = calculateLevel(0);
      setCurrentUser({
        id: walletAddress,
        username: `Player${Math.floor(Math.random() * 10000)}`,
        xp: 0,
        level: levelData.level,
        currentLevelXP: levelData.currentLevelXP,
        xpNeededForNext: levelData.xpNeededForNext,
        gamesPlayed: 0,
        gamesWon: 0
      });
    }
  };

  const initializeAchievements = userData => {
    if (!userData) return;
    const userXP = userData?.xp || 0;
    const userGamesPlayed = userData?.gamesPlayed || 0;
    const userGamesWon = userData?.gamesWon || 0;
    const userLevel = calculateLevel(userXP).level;
    const achievementsList = [
      { id: 1, name: 'First Victory', description: 'Win your first game', unlocked: userGamesWon >= 1, claimed: userData?.claimedAchievements?.includes(1) || false, icon: '🏆', reward: '100 XP' },
      { id: 2, name: 'Card Master', description: 'Play 10 games', unlocked: userGamesPlayed >= 10, claimed: userData?.claimedAchievements?.includes(2) || false, icon: '🎯', reward: '200 XP' },
      { id: 3, name: 'Shadow Warrior', description: 'Win 5 games in a row', unlocked: (userData?.currentWinStreak || 0) >= 5, claimed: userData?.claimedAchievements?.includes(3) || false, icon: '⚔️', reward: '500 XP' },
      { id: 4, name: 'Strategic Mind', description: 'Win 20 games', unlocked: userGamesWon >= 20, claimed: userData?.claimedAchievements?.includes(4) || false, icon: '🧠', reward: '1200 XP' },
      { id: 5, name: 'Century Club', description: 'Play 100 total games', unlocked: userGamesPlayed >= 100, claimed: userData?.claimedAchievements?.includes(5) || false, icon: '💯', reward: '1500 XP' },
      { id: 6, name: 'Ultimate Champion', description: 'Reach level 50', unlocked: userLevel >= 50, claimed: userData?.claimedAchievements?.includes(6) || false, icon: '🌟', reward: '2000 XP' },
      { id: 7, name: 'Legendary Player', description: 'Reach level 75', unlocked: userLevel >= 75, claimed: userData?.claimedAchievements?.includes(7) || false, icon: '👑', reward: '3000 XP' },
      { id: 8, name: 'Whot Grandmaster', description: 'Reach level 100', unlocked: userLevel >= 100, claimed: userData?.claimedAchievements?.includes(8) || false, icon: '💎', reward: '5000 XP' }
    ];
    setAchievements(achievementsList);
  };

  const fetchLeaderboard = () => {
    const lbRef = ref(db, 'leaderboard/users');
    const unsubscribe = onValue(lbRef, snapshot => {
      if (snapshot.exists()) {
        const data = Object.values(snapshot.val());
        const sorted = data
          .sort((a, b) => b.score - a.score)
          .slice(0, 50)
          .map((u, index) => ({
            rank: index + 1,
            name: (currentUser && u.id === currentUser.id) ? 'You' : (u.username || u.id),
            wins: u.gamesWon || 0,
            games: u.gamesPlayed || 0,
            winRate: (u.winRate || 0 * 100).toFixed ? (u.winRate * 100).toFixed(1) : ((u.gamesPlayed ? (u.gamesWon / u.gamesPlayed) : 0) * 100).toFixed(1),
            level: calculateLevel(u.xp || 0).level
          }));
        setLeaderboardData(sorted);
      } else {
        setLeaderboardData([]);
      }
    });
    return () => unsubscribe();
  };

  const updateUsername = async (newUsernameValue) => {
    if (!currentUser || !newUsernameValue.trim()) return;
    try {
      const userRef = ref(db, `users/${currentUser.id}`);
      await update(userRef, { username: newUsernameValue.trim() });
      setCurrentUser(prev => ({ 
        ...prev, 
        username: newUsernameValue.trim() 
      }));
      setIsEditingUsername(false);
      setNewUsername('');
    } catch (error) {
      console.error('Error updating username:', error);
    }
  };

  const claimAchievement = async (achievementId) => {
    if (!currentUser) return;
    const achievement = achievements.find(a => a.id === achievementId);
    if (!achievement || !achievement.unlocked || achievement.claimed) return;
    try {
      const claimFn = httpsCallable(fbFunctions, 'claimAchievement');
      await claimFn({ userId: currentUser.id, achievementId });
      // Refresh user profile snapshot and update level data
      const userRef = ref(db, `users/${currentUser.id}`);
      const snapshot = await get(userRef);
      if (snapshot.exists()) {
        const firebaseData = snapshot.val();
        const levelData = calculateLevel(firebaseData.xp || 0);
        const updatedUserData = {
          id: currentUser.id,
          ...firebaseData,
          level: levelData.level,
          currentLevelXP: levelData.currentLevelXP,
          xpNeededForNext: levelData.xpNeededForNext
        };
        setCurrentUser(updatedUserData);
        // Update Firebase with new level data
        await update(userRef, {
          level: levelData.level,
          currentLevelXP: levelData.currentLevelXP,
          xpNeededForNext: levelData.xpNeededForNext
        });
      }
      setAchievements(prev => prev.map(a => a.id === achievementId ? { ...a, claimed: true } : a));
    } catch (error) {
      console.error('Error claiming achievement:', error);
    }
  };

  const calculateLevel = (xp) => {
    let totalXPNeeded = 0;
    let level = 1;
    while (level <= 100) {
      const xpForThisLevel = 100 + (level - 1) * 150 + Math.floor((level - 1) / 10) * 500;
      if (totalXPNeeded + xpForThisLevel > xp) {
        break;
      }
      totalXPNeeded += xpForThisLevel;
      level++;
    }
    return {
      level: Math.min(level, 100),
      currentLevelXP: xp - totalXPNeeded,
      xpNeededForNext: level <= 100 ? 100 + level * 150 + Math.floor(level / 10) * 500 : 0,
      totalXP: xp
    };
  };

  const getXPFromGame = (won, roundsPlayed, cardsPlayed) => {
    let baseXP = 50;
    if (won) baseXP += 100;
    baseXP += roundsPlayed * 25;
    baseXP += Math.floor(cardsPlayed / 5) * 10;
    return baseXP;
  };

  const startConfetti = () => {
    setConfettiActive(true);
    const canvas = confettiCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const particles = [];
    const colors = ['#80142C', '#a01d39', '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1'];
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    for (let i = 0; i < 150; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: -10,
        vx: (Math.random() - 0.5) * 4,
        vy: Math.random() * 3 + 2,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: Math.random() * 8 + 4,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
        gravity: 0.1
      });
    }
    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      particles.forEach((particle, index) => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += particle.gravity;
        particle.rotation += particle.rotationSpeed;
        ctx.save();
        ctx.translate(particle.x, particle.y);
        ctx.rotate(particle.rotation * Math.PI / 180);
        ctx.fillStyle = particle.color;
        ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
        ctx.restore();
        if (particle.y > canvas.height + 50) {
          particles.splice(index, 1);
        }
      });
      if (particles.length > 0) {
        requestAnimationFrame(animate);
      } else {
        setConfettiActive(false);
      }
    };
    animate();
  };

  const createDeck = () => {
    const deck = [];
    let cardIdCounter = 0;
    const cardDefinitions = [
      { shape: '●', numbers: [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14] },
      { shape: '▲', numbers: [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14] },
      { shape: '✚', numbers: [1, 2, 3, 5, 7, 10, 11, 13, 14] },
      { shape: '■', numbers: [1, 2, 3, 5, 7, 10, 11, 13, 14] },
      { shape: '★', numbers: [1, 2, 3, 4, 5, 7, 8] }
    ];
    const createdCards = new Map();
    cardDefinitions.forEach(({ shape, numbers }) => {
      numbers.forEach(number => {
        const cardKey = `${shape}-${number}`;
        if (createdCards.has(cardKey)) {
          console.error(`CRITICAL ERROR: Attempted to create duplicate card: ${cardKey}`);
          throw new Error(`Duplicate card creation attempted: ${cardKey}`);
        }
        const card = { shape, number, id: `unique-${shape}-${number}-${Date.now()}-${cardIdCounter++}` };
        if (number === 1) card.special = 'holdon';
        else if (number === 2) card.special = 'pick2';
        else if (number === 14) card.special = 'generalmarket';
        createdCards.set(cardKey, true);
        deck.push(card);
      });
    });
    for (let i = 0; i < 5; i++) {
      deck.push({ shape: '🔥', number: 'WHOT', id: `whot-${i}-${Date.now()}-${cardIdCounter++}`, special: 'whot' });
    }
    const regularCards = deck.filter(card => card.special !== 'whot');
    const cardKeys = regularCards.map(card => `${card.shape}-${card.number}`);
    const uniqueKeys = new Set(cardKeys);
    if (cardKeys.length !== uniqueKeys.size) {
      console.error('CRITICAL: Duplicate cards found in deck after creation!');
      console.log('Total regular cards:', cardKeys.length);
      console.log('Unique combinations:', uniqueKeys.size);
      const duplicates = cardKeys.filter((key, index) => cardKeys.indexOf(key) !== index);
      console.error('Duplicate cards found:', [...new Set(duplicates)]);
      throw new Error('Deck creation failed - duplicate cards detected');
    }
    console.log(`✓ Deck created successfully: ${deck.length} total cards`);
    console.log(` - Circles: ${deck.filter(c => c.shape === '●').length}`);
    console.log(` - Triangles: ${deck.filter(c => c.shape === '▲').length}`);
    console.log(` - Crosses: ${deck.filter(c => c.shape === '✚').length}`);
    console.log(` - Squares: ${deck.filter(c => c.shape === '■').length}`);
    console.log(` - Stars: ${deck.filter(c => c.shape === '★').length}`);
    console.log(` - WHOT cards: ${deck.filter(c => c.shape === '🔥').length}`);
    console.log(`✓ All ${uniqueKeys.size} regular card combinations are unique`);
    return deck;
  };

  const shuffleDeck = (deck) => {
    const shuffled = [...deck];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };

  // Animation utility functions
  const detectOpponentMoves = (prevGameData, newGameData, currentUser) => {
    const moves = {
      cardPlay: null,
      cardDraw: []
    };

    // Detect card play
    if (prevGameData?.playPile && newGameData?.playPile && newGameData.playPile.length > prevGameData.playPile.length) {
      const lastCard = newGameData.playPile[newGameData.playPile.length - 1];
      
      // Determine who played by card count difference
      let playerWhoPlayed = prevGameData.players.findIndex(p => 
        (p.cards || []).length > ((newGameData.players.find(np => np.id === p.id))?.cards || []).length
      );
      
      // Fallback to currentPlayer if no difference found
      if (playerWhoPlayed === -1) {
        playerWhoPlayed = newGameData.currentPlayer;
      }
      
      const currentUserIndex = newGameData.players.findIndex(p => p.id === currentUser?.id);
      
      if (playerWhoPlayed !== -1 && playerWhoPlayed !== currentUserIndex) {
        moves.cardPlay = {
          card: lastCard,
          playerIndex: playerWhoPlayed,
          playPileLength: newGameData.playPile.length
        };
      }
    }

    // Detect card draws
    if (prevGameData?.players && newGameData?.players) {
      newGameData.players.forEach((newPlayer, playerIndex) => {
        const oldPlayer = prevGameData.players.find(p => p.id === newPlayer.id);
        if (oldPlayer && newPlayer.cards.length > oldPlayer.cards.length && playerIndex !== newGameData.players.findIndex(p => p.id === currentUser?.id)) {
          const cardsDifference = newPlayer.cards.length - oldPlayer.cards.length;
          moves.cardDraw.push({
            playerIndex,
            cardsCount: cardsDifference
          });
        }
      });
    }

    return moves;
  };

  const processOpponentAnimations = (moves, animationPositions, getVisualPlayerMapping, getPlayPilePosition, getTopMarketCardPosition) => {
    const animations = [];

    // Process card play animation
    if (moves.cardPlay) {
      const { card, playerIndex, playPileLength } = moves.cardPlay;
      const mapping = getVisualPlayerMapping();
      const visualPlayerIndex = mapping.actualToVisual[playerIndex] !== undefined ? mapping.actualToVisual[playerIndex] : playerIndex;
      
      const newCardRelativeStyle = getPlayPilePosition(playPileLength - 1, false);
      const endPosition = {
        ...animationPositions.playPile,
        transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
        zIndex: newCardRelativeStyle.zIndex
      };

      const animatingCard = {
        ...card,
        id: `opponent-play-${Date.now()}`,
        startPos: animationPositions.animationStarts?.[visualPlayerIndex] || {
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)'
        },
        endPos: endPosition,
        isPlayerCard: true
      };

      animations.push(animatingCard);
    }

    // Process card draw animations
    moves.cardDraw.forEach(({ playerIndex, cardsCount }) => {
      const mapping = getVisualPlayerMapping();
      const visualPlayerIndex = mapping.actualToVisual[playerIndex] !== undefined ? mapping.actualToVisual[playerIndex] : playerIndex;
      
      for (let i = 0; i < cardsCount; i++) {
        const animatingCard = {
          id: `opponent-draw-${Date.now()}-${i}`,
          startPos: getTopMarketCardPosition(),
          endPos: {
            ...animationPositions.drawEnds[visualPlayerIndex],
            opacity: 0
          },
          isPlayerCard: false
        };
        animations.push(animatingCard);
      }
    });

    return animations;
  };

  const startAnimations = (animations, setAnimatingCards, onComplete) => {
    if (animations.length === 0) return;

    // Add all animations to state
    setAnimatingCards(prev => [...prev, ...animations]);

    // Calculate total animation duration
    const maxDuration = Math.max(...animations.map(anim => {
      if (anim.id.includes('opponent-draw')) {
        // Draw animations are staggered, so calculate total time
        const index = parseInt(anim.id.split('-').pop());
        return (index * 100) + 800; // 100ms stagger + 800ms animation
      }
      return 800; // Default animation duration
    }));

    // Remove animations after completion
    setTimeout(() => {
      setAnimatingCards(prev => prev.filter(card => !animations.some(anim => anim.id === card.id)));
      if (onComplete) onComplete();
    }, maxDuration);
  };

  const startDealingAnimation = async (deckToDeal, players, cardsPerPlayer) => {
    console.log('🎴 Starting dealing animation with', deckToDeal.length, 'cards for', players.length, 'players');
    console.log('🎵 Sound effects initialized:', soundEffects.isInitialized, 'enabled:', soundEffects.isEnabled);
    setIsAnyAnimationInProgress(true);
    const totalCardsToDistribute = players.length * cardsPerPlayer;
    
      for (let i = 0; i < totalCardsToDistribute; i++) {
        const currentPlayerIndex = i % players.length;
        const currentPlayer = players[currentPlayerIndex];
        const cardToDeal = deckToDeal[i];
      let visualPlayerIndex = currentPlayerIndex;
      if (currentRoom && gameData) {
        const mapping = getVisualPlayerMapping();
        visualPlayerIndex = mapping.actualToVisual[currentPlayerIndex] !== undefined ? mapping.actualToVisual[currentPlayerIndex] : currentPlayerIndex;
      }
      
      // Play deal sound for every 3rd card to avoid audio lag
      if (i % 3 === 0) {
        console.log('🎵 Playing deal sound for card', i);
        soundEffects.playDeal();
      }
      
      const dealingCard = {
        ...cardToDeal,
        id: `dealing-${Date.now()}-${i}`,
        startPos: getTopMarketCardPosition(),
        endPos: {
          ...animationPositions.drawEnds[visualPlayerIndex],
          opacity: 0
        },
        isPlayerCard: false
      };
      setAnimatingCards(prev => {
        console.log('🎴 Adding dealing card:', dealingCard.id, 'Total animating cards:', prev.length + 1);
        return [...prev, dealingCard];
      });
      await new Promise(resolve => {
        setTimeout(() => {
          console.log('🎴 Completing dealing animation for card', i, 'player', currentPlayer.name);
          setAnimatingCards(prev => prev.filter(c => c.id !== dealingCard.id));
          setGameData(prevData => {
            const newData = {
              ...prevData
            };
            const updatedPlayers = newData.players.map(p => ({
              ...p,
              cards: [...p.cards]
            }));
        const actualPlayerIndex = updatedPlayers.findIndex(p => p.id === currentPlayer.id);
        if (actualPlayerIndex !== -1 && !updatedPlayers[actualPlayerIndex].eliminated) {
          updatedPlayers[actualPlayerIndex].cards.push(cardToDeal);
              console.log('🎴 Added card to player', currentPlayer.name, 'total cards:', updatedPlayers[actualPlayerIndex].cards.length);
        }
      return {
        ...newData,
        players: updatedPlayers,
              drawPile: deckToDeal.slice(i + 1)
      };
    });
          resolve();
        }, 80);
      });
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // Handle initial play card
    const remainingDeck = deckToDeal.slice(totalCardsToDistribute);
    if (remainingDeck.length > 0) {
      const playCard = remainingDeck[0];
      console.log("Dealing initial play card:", playCard);
      
      // Play card play sound for initial card
      if (playCard.special === 'whot' || playCard.special === 'pick2' || playCard.special === 'holdon' || playCard.special === 'generalmarket') {
        soundEffects.playSpecialCard();
      } else {
        soundEffects.playCardPlay();
      }
      
      const endPosition = getPlayPilePosition(0, false);
      setPlayPileCardPositions(prev => ({
        ...prev,
        [0]: endPosition
      }));
      const playPileCard = {
        ...playCard,
        id: `dealing-play-${Date.now()}`,
        startPos: getTopMarketCardPosition(),
        endPos: {
          ...animationPositions.playPile,
          transform: `${animationPositions.playPile.transform} ${endPosition.transform}`,
          zIndex: endPosition.zIndex
        },
        isPlayerCard: true
      };
      setAnimatingCards(prev => [...prev, playPileCard]);
      await new Promise(resolve => {
        setTimeout(() => {
          setAnimatingCards(prev => prev.filter(c => c.id !== playPileCard.id));
          resolve();
        }, 800);
      });
      
      const initialCardEffects = {};
      let specialMessage = '';
      if (playCard.special === 'whot') {
        const shapes = ['●', '▲', '✚', '■', '★'];
        playCard.chosenShape = shapes[Math.floor(Math.random() * shapes.length)];
        specialMessage = ` - Auto-chosen shape: ${playCard.chosenShape}`;
      }
      
      setGameData(prevData => {
        const newData = {
          ...prevData,
          playPile: [playCard],
          drawPile: remainingDeck.slice(1),
          gamePhase: 'playing',
          lastAction: prevData.roundNumber === 1 ? `Game started - ${playCard.number}${playCard.shape} played${specialMessage}` : `Round ${prevData.roundNumber}`,
          ...initialCardEffects,
          generalMarketDrawCount: initialCardEffects.generalMarketActive ? 0 : undefined,
          gameLog: {
            ...prevData.gameLog,
            [prevData.roundNumber]: prevData.roundNumber === 1 ? [...(prevData.gameLog[1] || []), `Initial card: ${playCard.number}${playCard.shape} placed on table${specialMessage}`] : [...(prevData.gameLog[prevData.roundNumber] || []), `Round ${prevData.roundNumber} begins`]
          }
        };
        if (newData.players[newData.currentPlayer].isAI) {
          setTimeout(() => {
            setIsAITurnInProgress(true);
            setTimeout(async () => {
              if (!isAnyAnimationInProgress) {
                await aiTurn({
                  ...newData
                });
              }
            }, 1000);
          }, 500);
        }
        return newData;
      });
    }
    
    setIsAnyAnimationInProgress(false);
  };

  const animateDrawCards = async (gameDataToUse, player, count, isPending = false, isGeneral = false) => {
    isAnimationInProgressRef.current = true;
    setIsAnyAnimationInProgress(true);
    
    // Draw cards one by one, adding them to player's deck immediately
    for (let i = 0; i < count; i++) {
      if (gameDataToUse.drawPile.length <= 1) {
        reshuffleMarket(gameDataToUse);
      }
      if (gameDataToUse.drawPile.length === 0) break;
      
      const drawnCard = gameDataToUse.drawPile[gameDataToUse.drawPile.length - 1];
      gameDataToUse.drawPile = gameDataToUse.drawPile.slice(0, -1);
      
      // Add card to player's deck immediately (like original)
      player.cards = [...player.cards, drawnCard];
      
      // Update gameData immediately so the card appears in the UI
      setGameData({ ...gameDataToUse });
      
      // Create and start animation for this single card
      const playerActualIndex = gameDataToUse.players.findIndex(p => p.id === player.id);
      const getVisualPlayerMappingWrapper = () => getVisualPlayerMapping(currentRoom, currentUser);
      const getTopMarketCardPositionWrapper = () => getTopMarketCardPosition();
      
      // Play market draw sound
      console.log('🎵 Playing market draw sound for card', i);
      soundEffects.playMarketDraw();
      
      // Create draw animation using original logic
      const mapping = getVisualPlayerMappingWrapper();
      const visualPlayerIndex = mapping.actualToVisual[playerActualIndex] !== undefined ? mapping.actualToVisual[playerActualIndex] : playerActualIndex;
      
      const animatingCard = {
        id: `draw-${Date.now()}-${i}`,
        startPos: getTopMarketCardPositionWrapper(),
        endPos: {
          ...animationPositions.drawEnds[visualPlayerIndex],
          opacity: 0
        },
        isPlayerCard: false
      };
      
      setAnimatingCards(prev => [...prev, animatingCard]);
      
      // Wait for animation to complete
      await new Promise(resolve => {
        setTimeout(() => {
          setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
          resolve();
        }, 800);
      });
      
      // Wait for this card's animation to complete before drawing the next
      await new Promise(resolve => setTimeout(resolve, 800));
      
      // Small delay between cards (like original)
      if (i < count - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    const currentUserActualIndex = currentRoom ? gameDataToUse.players.findIndex(p => p.id === currentUser?.id) : 0;
    if (player.id === currentUserActualIndex || !currentRoom && player.id === 0) {
      const newTotal = player.cards.length;
      if (newTotal > maxVisiblePlayerCards) setPlayerScrollIndex(newTotal - maxVisiblePlayerCards);
      setIsPlayerActionInProgress(false);
    }
    gameDataToUse.lastAction = isPending ? `${player.name.split(' ')[0]} - pick${count}` : isGeneral ? `${player.name.split(' ')[0]} - market` : `${player.name.split(' ')[0]} - market`;
    gameDataToUse.gameLog = {
      ...gameDataToUse.gameLog,
      [gameDataToUse.roundNumber]: [...(gameDataToUse.gameLog[gameDataToUse.roundNumber] || []), isPending ? `${player.name} drew ${count} card${count > 1 ? 's' : ''} (penalty)` : isGeneral ? `${player.name} drew ${count} card${count > 1 ? 's' : ''} (general market)` : `${player.name} drew ${count} card${count > 1 ? 's' : ''} from market`]
    };
    if (isPending) gameDataToUse.pendingPickCount = 0;
    setGameData({
      ...gameDataToUse
    });
    isAnimationInProgressRef.current = false;
    setIsAnyAnimationInProgress(false);
    nextTurn(gameDataToUse);
  };

  const reshuffleMarket = gameData => {
    if (gameData.playPile.length <= 1) return;
    const topCard = gameData.playPile[gameData.playPile.length - 1];
    const cardsToShuffle = gameData.playPile.slice(0, -1);
    
    // Reset WHOT cards in the cards to shuffle (remove chosenShape)
    const resetCards = cardsToShuffle.map(card => {
      if (card.special === 'whot') {
        const { chosenShape, ...cardWithoutShape } = card;
        return cardWithoutShape;
      }
      return card;
    });
    
    // Play shuffle sound when market is reshuffled
    soundEffects.playShuffle();
    
    gameData.drawPile = shuffleDeck(resetCards);
    gameData.playPile = [topCard];
    const topCardPosition = playPileCardPositions[gameData.playPile.length - 1] || getPlayPilePosition(0, false);
    playPilePositionsRef.current = [playPilePositionsRef.current[gameData.playPile.length - 1] || {
      transform: 'translate(0px, 0px) rotate(0deg)',
      zIndex: 30
    }];
    setPlayPileCardPositions({
      0: topCardPosition
    });
    setNeedNewMarketPositions(true);
    gameData.lastAction += ' (Market reshuffled)';
    gameData.gameLog = {
      ...gameData.gameLog,
      [gameData.roundNumber]: [...(gameData.gameLog[gameData.roundNumber] || []), 'Market deck was reshuffled from played cards']
    };
  };

  const getCardBackSVG = () => {
    return `
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
        viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
      <g>
        <path fill="#7D1228" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
          c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
        <text x="93.15" y="120" font-family="Pacifico, cursive" font-size="32px" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="middle">Whot</text>
        <text x="93.15" y="140" font-family="Pacifico, cursive" font-size="32px" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="middle" transform="rotate(180 93.15 140)">Whot</text>
      </g>
      </svg>
    `;
  };

  const canPlayCard = (card, topCard) => {
    if (!card) return false;
    if (card.special === 'whot') return true;
    if (!topCard) return false;
    return card.shape === topCard.shape || card.number === topCard.number;
  };

  const isCardPlayable = (card, topCard) => {
    if (card.special === 'whot') return true;
    if (!topCard) {
      return false;
    }
    if (topCard.chosenShape) {
      return card.shape === topCard.chosenShape;
    }
    return card.shape === topCard.shape || card.number === topCard.number;
  };

  const hasPlayableCardsOutsideRange = () => {
    if (!gameData) return {
      left: false,
      right: false
    };
    const currentUserActualIndex = currentRoom ? gameData.players.findIndex(p => p.id === currentUser?.id) : 0;
    if (gameData.currentPlayer !== currentUserActualIndex) return {
      left: false,
      right: false
    };
    const player = gameData.players[currentUserActualIndex];
    const topCard = gameData.playPile[gameData.playPile.length - 1];
    const leftCards = (player.cards || []).slice(0, playerScrollIndex);
    const hasPlayableLeft = leftCards.some(card => isCardPlayable(card, topCard));
    const rightCards = (player.cards || []).slice(playerScrollIndex + maxVisiblePlayerCards);
    const hasPlayableRight = rightCards.some(card => isCardPlayable(card, topCard));
    return {
      left: hasPlayableLeft,
      right: hasPlayableRight
    };
  };

  const scrollPlayerCards = direction => {
    if (!gameData) return;
    const currentUserActualIndex = currentRoom ? gameData.players.findIndex(p => p.id === currentUser?.id) : 0;
    const playerCards = gameData.players[currentUserActualIndex]?.cards || gameData.players[0].cards;
    const maxScroll = Math.max(0, playerCards.length - maxVisiblePlayerCards);
    if (direction === 'left') {
      setPlayerScrollIndex(Math.max(0, playerScrollIndex - 1));
    } else if (direction === 'right') {
      setPlayerScrollIndex(Math.min(maxScroll, playerScrollIndex + 1));
    }
  };

  const getCardsPerPlayer = playerCount => {
    console.log(`getCardsPerPlayer called with ${playerCount} players`);
    if (playerCount === 4) {
      console.log(`Returning 6 cards for 4 players`);
      return 6;
    }
    if (playerCount === 3) {
      console.log(`Returning 9 cards for 3 players`);
      return 9;
    }
    if (playerCount === 2) {
      console.log(`Returning 12 cards for 2 players`);
      return 12;
    }
    console.log(`Returning 6 cards for ${playerCount} players (default)`);
    return 6;
  };

  const getVisualPlayerMapping = () => {
    if (!currentRoom) return { actualToVisual: {}, visualToActual: {} };
    
    const roomPlayers = currentRoom.players || [];
    const currentUserIndex = roomPlayers.findIndex(p => p.id === currentUser?.id);
    
    if (currentUserIndex === -1) return { actualToVisual: {}, visualToActual: {} };
    
    const actualToVisual = {};
    const visualToActual = {};
    
    // Map actual player indices to visual positions
    for (let i = 0; i < roomPlayers.length; i++) {
      const visualIndex = (i - currentUserIndex + roomPlayers.length) % roomPlayers.length;
      actualToVisual[i] = visualIndex;
      visualToActual[visualIndex] = i;
    }
    
    return { actualToVisual, visualToActual };
  };

  const getTopMarketCardPosition = () => {
    const screenWidth = window.innerWidth;
    return {
      top: '50%',
      left: '50%',
      transform: `translate(calc(-50% + ${screenWidth < 768 ? '54px' : screenWidth < 1024 ? '72px' : '90px'}), -50%)`
    };
  };

  const getPlayPilePosition = (cardIndex = null, storePosition = true) => {
    cardIndex = cardIndex === null ? 0 : cardIndex;
    while (playPilePositionsRef.current.length <= cardIndex) {
      const randomX = (Math.random() - 0.5) * 8;
      const randomY = (Math.random() - 0.5) * 8;
      const randomRotate = (Math.random() - 0.5) * 15;
      playPilePositionsRef.current.push({
        transform: `translate(${randomX}px, ${randomY}px) rotate(${randomRotate}deg)`,
        zIndex: 30 + playPilePositionsRef.current.length
      });
    }
    const cardPosition = playPilePositionsRef.current[cardIndex];
    const relativeCardStyle = {
      transform: cardPosition.transform,
      zIndex: cardPosition.zIndex
    };
    if (storePosition) {
      setPlayPileCardPositions(prev => ({
        ...prev,
        [cardIndex]: relativeCardStyle
      }));
    }
    return relativeCardStyle;
  };

  const getExactCardPosition = (playerIndex, cardIndex, totalCards, clampToVisible = true) => {
    const cardWidth = window.innerWidth < 768 ? 72 : window.innerWidth < 1024 ? 100 : 130;
    const cardSpacing = 6;
    const maxVisibleCards = playerIndex === 0 ? maxVisiblePlayerCards : MAX_VISIBLE_AI_CARDS;
    
    if (clampToVisible && playerIndex === 0) {
      const clampedIndex = Math.max(0, Math.min(cardIndex - playerScrollIndex, maxVisibleCards - 1));
      return {
        transform: `translateX(${clampedIndex * (cardWidth + cardSpacing)}px)`,
        zIndex: clampedIndex
      };
    }
    
    return {
      transform: `translateX(${cardIndex * (cardWidth + cardSpacing)}px)`,
      zIndex: cardIndex
    };
  };

  const getNextPlayer = gameData => {
    let nextPlayer = gameData.currentPlayer;
    let playersToSkip = gameData.skipNextPlayer ? 1 : 0;
    do {
      nextPlayer = (nextPlayer + 1) % gameData.players.length;
    } while (gameData.players[nextPlayer].eliminated);
    while (playersToSkip > 0) {
      do {
        nextPlayer = (nextPlayer + 1) % gameData.players.length;
      } while (gameData.players[nextPlayer].eliminated);
      playersToSkip--;
    }
    return nextPlayer;
  };

  const nextTurn = gameData => {
    let nextPlayer = gameData.currentPlayer;
    let playersToSkip = gameData.skipNextPlayer ? 1 : 0;
    do {
      nextPlayer = (nextPlayer + 1) % gameData.players.length;
    } while (gameData.players[nextPlayer].eliminated);
    while (playersToSkip > 0) {
      do {
        nextPlayer = (nextPlayer + 1) % gameData.players.length;
      } while (gameData.players[nextPlayer].eliminated);
      playersToSkip--;
    }
    gameData.currentPlayer = nextPlayer;
    gameData.skipNextPlayer = false;
    if (gameData.generalMarketActive && nextPlayer === gameData.generalMarketOriginatorId) {
      gameData.generalMarketActive = false;
      gameData.generalMarketOriginatorId = null;
      gameData.lastAction += ' General Market effect ends.';
      gameData.gameLog = {
        ...gameData.gameLog,
        [gameData.roundNumber]: [...(gameData.gameLog[gameData.roundNumber] || []), 'General Market effect ended - all players have drawn']
      };
    }
    setGameData({ ...gameData });
    if (gameData.players[nextPlayer].isAI) {
      setTimeout(() => {
        setIsAITurnInProgress(true);
        setTimeout(async () => {
          if (!isAnyAnimationInProgress) {
            await handleAITurn({ ...gameData });
          }
        }, 1000);
      }, 500);
    }
  };

  const endRound = gameData => {
    const activePlayers = gameData.players.filter(p => !p.eliminated);
    const playersWithTotals = activePlayers.map(p => ({
      ...p,
      cardTotal: calculateCardTotal(p.cards),
      cardCount: p.cards.length
    }));
    let maxTotal = Math.max(...playersWithTotals.map(p => p.cardTotal));
    const playersWithMaxTotal = playersWithTotals.filter(p => p.cardTotal === maxTotal);
    const eliminatedPlayer = playersWithMaxTotal[Math.floor(Math.random() * playersWithMaxTotal.length)];
    const roundWinner = playersWithTotals.find(p => p.cardTotal === Math.min(...playersWithTotals.map(p => p.cardTotal)));
    const roundEndInfo = {
      winner: roundWinner,
      players: playersWithTotals.map(p => ({
        ...p,
        cardCount: p.cards.length,
        cardTotal: p.cardTotal,
        cards: p.cards.slice()
      })),
      eliminatedPlayer,
      maxCards: maxTotal,
      roundNumber: gameData.roundNumber
    };
    const newGameData = {
      ...gameData,
      roundEndData: roundEndInfo,
      gamePhase: 'roundEnd'
    };
    const eliminatedPlayerInNewData = newGameData.players.find(p => p.id === eliminatedPlayer.id);
    if (eliminatedPlayerInNewData) {
      eliminatedPlayerInNewData.eliminated = true;
    }
    newGameData.lastAction = `${eliminatedPlayer.name.split(' ')[0]} eliminated`;
    const currentRoundLog = newGameData.gameLog[newGameData.roundNumber] || [];
    newGameData.gameLog[newGameData.roundNumber] = [...currentRoundLog, `Round ${newGameData.roundNumber}: ${eliminatedPlayer.name} eliminated with ${maxTotal} total card points`];
    const remainingPlayers = newGameData.players.filter(p => !p.eliminated);
    if (remainingPlayers.length <= 1) {
      newGameData.gamePhase = 'gameEnd';
      const finalWinner = remainingPlayers.length > 0 ? remainingPlayers[0] : roundWinner;
      newGameData.winner = finalWinner;
      newGameData.lastAction = `${finalWinner.name.split(' ')[0]} wins!`;
      newGameData.gameLog[newGameData.roundNumber + 1] = [`GAME OVER: ${finalWinner.name} wins the game!`];
      const isWinner = currentUser && finalWinner.id === currentUser.id;
      if (currentUser) {
        const updateData = {
          gamesPlayed: (currentUser.gamesPlayed || 0) + 1
        };
        if (isWinner) {
          updateData.gamesWon = (currentUser.gamesWon || 0) + 1;
          updateData.xp = (currentUser.xp || 0) + 150;
          updateData.currentWinStreak = (currentUser.currentWinStreak || 0) + 1;
          updateData.bestWinStreak = Math.max(updateData.currentWinStreak, currentUser.bestWinStreak || 0);
        } else {
          updateData.currentWinStreak = 0;
        }
        // Calculate new level data
        const newXP = updateData.xp || currentUser.xp || 0;
        const levelData = calculateLevel(newXP);
        const updatedData = {
          ...updateData,
          level: levelData.level,
          currentLevelXP: levelData.currentLevelXP,
          xpNeededForNext: levelData.xpNeededForNext
        };
        update(ref(db, `users/${currentUser.id}`), updatedData);
      }
      setTimeout(() => {
        startConfetti();
      }, 1000);
    } else {
      newGameData.roundNumber++;
      setTimeout(() => {
        const deck = createDeck();
        const shuffledNewDeck = shuffleDeck(deck);
        const remainingPlayers = newGameData.players.filter(p => !p.eliminated);
        const cardsPerPlayer = getCardsPerPlayer(remainingPlayers.length);
        remainingPlayers.forEach(player => {
          player.cards = shuffledNewDeck.splice(0, cardsPerPlayer);
        });
        const newGameDataWithNewDeck = {
          ...newGameData,
          players: remainingPlayers,
          drawPile: shuffledNewDeck,
          playPile: [],
          currentPlayer: 0,
          gamePhase: 'dealingCards',
          lastAction: 'Dealing cards...',
          pendingPickCount: 0,
          generalMarketActive: false,
          generalMarketOriginatorId: null,
          skipNextPlayer: false,
          gameLog: {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [`Round ${newGameData.roundNumber} begins`, 'Cards dealt to all players']
          }
        };
        setGameData(newGameDataWithNewDeck);
        startDealingAnimation([...shuffledNewDeck], remainingPlayers, getCardsPerPlayer(remainingPlayers.length));
      }, 3000);
    }
    setGameData(newGameData);
  };

  const calculateCardTotal = cards => {
    return cards.reduce((total, card) => {
      if (card.special === 'whot') return total + 20;
      if (card.number === 14) return total + 14;
      if (card.number === 13) return total + 13;
      if (card.number === 12) return total + 12;
      if (card.number === 11) return total + 11;
      if (card.number === 10) return total + 10;
      if (card.number === 9) return total + 9;
      if (card.number === 8) return total + 8;
      if (card.number === 7) return total + 7;
      if (card.number === 6) return total + 6;
      if (card.number === 5) return total + 5;
      if (card.number === 4) return total + 4;
      if (card.number === 3) return total + 3;
      if (card.number === 2) return total + 2;
      if (card.number === 1) return total + 1;
      return total + card.number;
    }, 0);
  };

  const aiTurn = async gameData => {
    if (!gameData.players[gameData.currentPlayer].isAI || isAnyAnimationInProgress) {
      setIsAITurnInProgress(false);
      return;
    }
    updateGameActivity(); // Track AI activity for timeout
    isAnimationInProgressRef.current = true;
    setIsAnyAnimationInProgress(true);
    let newGameData = JSON.parse(JSON.stringify(gameData));
    const currentPlayer = newGameData.players[newGameData.currentPlayer];
    if (newGameData.pendingPickCount > 0 || newGameData.generalMarketActive && currentPlayer.id !== newGameData.generalMarketOriginatorId) {
      const count = newGameData.pendingPickCount > 0 ? newGameData.pendingPickCount : 1;
      const isPending = newGameData.pendingPickCount > 0;
      const isGeneral = newGameData.generalMarketActive && currentPlayer.id !== newGameData.generalMarketOriginatorId && !isPending;
      await animateDrawCards(newGameData, currentPlayer, count, isPending, isGeneral);
      setIsAITurnInProgress(false);
      return;
    }
    const topCard = newGameData.playPile[newGameData.playPile.length - 1];
    const playableCards = currentPlayer.cards.map((card, index) => ({
      card,
      index
    })).filter(({ card }) => {
      if (!topCard) return card.special === 'whot';
      if (topCard.chosenShape) return card.special === 'whot' || card.shape === topCard.chosenShape;
      return canPlayCard(card, topCard);
    });
    if (playableCards.length > 0) {
      const randomCard = playableCards[Math.floor(Math.random() * playableCards.length)];
      const cardToPlay = { ...randomCard.card };
      const currentTopCard = newGameData.playPile[newGameData.playPile.length - 1];
      let isValidPlay = false;
      if (cardToPlay.special === 'whot') {
        isValidPlay = true;
      } else if (!currentTopCard) {
        isValidPlay = false;
      } else if (currentTopCard.chosenShape) {
        isValidPlay = cardToPlay.shape === currentTopCard.chosenShape;
      } else {
        isValidPlay = cardToPlay.shape === currentTopCard.shape || cardToPlay.number === currentTopCard.number;
      }
      if (!isValidPlay) {
        console.warn(`AI ${currentPlayer.name} attempted invalid play: ${cardToPlay.number}${cardToPlay.shape} on ${currentTopCard?.number}${currentTopCard?.chosenShape || currentTopCard?.shape}`);
        await animateDrawCards(newGameData, currentPlayer, 1, false, false);
        setIsAITurnInProgress(false);
        setIsAnyAnimationInProgress(false);
        return;
      }
      const newCardRelativeStyle = getPlayPilePosition(newGameData.playPile.length, false);
      const endPosition = {
        ...animationPositions.playPile,
        transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
        zIndex: newCardRelativeStyle.zIndex
      };
      // Play sound based on card type
      console.log('🎵 AI playing card sound for:', cardToPlay.number, cardToPlay.shape, cardToPlay.special);
      if (cardToPlay.special === 'whot' || cardToPlay.special === 'pick2' || cardToPlay.special === 'holdon' || cardToPlay.special === 'generalmarket') {
        console.log('🎵 AI playing special card sound');
        soundEffects.playSpecialCard();
      } else {
        console.log('🎵 AI playing regular card sound');
        soundEffects.playCardPlay();
      }
      
      const animatingCard = {
        ...cardToPlay,
        id: `animating-${Date.now()}-${randomCard.index}`,
        startPos: animationPositions.animationStarts[currentPlayer.id],
        endPos: endPosition,
        isPlayerCard: true
      };
      
      setAnimatingCards(prev => [...prev, animatingCard]);
      
      // Wait for animation to complete
      await new Promise(resolve => {
        setTimeout(() => {
          setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
          resolve();
        }, 800);
      });
      
      currentPlayer.cards = currentPlayer.cards.filter((_, idx) => idx !== randomCard.index);
      newGameData.playPile = [...newGameData.playPile, cardToPlay];
      if (cardToPlay.special === 'whot') {
        const shapes = ['●', '▲', '✚', '■', '★'];
        cardToPlay.chosenShape = shapes[Math.floor(Math.random() * shapes.length)];
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - WHOT → ${cardToPlay.chosenShape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played WHOT and chose ${cardToPlay.chosenShape} as the active shape`]
        };
      } else if (cardToPlay.special === 'pick2') {
        newGameData.pendingPickCount += 2;
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape} pick2`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (Pick 2) - Next player must draw 2 cards`]
        };
      } else if (cardToPlay.special === 'holdon') {
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape} hold`;
        newGameData.skipNextPlayer = true;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (Hold On) - Next player's turn skipped`]
        };
      } else if (cardToPlay.special === 'generalmarket') {
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape} gen`;
        newGameData.generalMarketActive = true;
        newGameData.generalMarketOriginatorId = newGameData.currentPlayer;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (General Market) - All other players must draw from market`]
        };
      } else {
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape}`]
        };
      }
      if (currentPlayer.cards.length === 0) {
        setGameData(newGameData);
        handleRoundEnd(newGameData);
        setIsAITurnInProgress(false);
        return;
      }
      setGameData(newGameData);
      setIsAITurnInProgress(false);
      setIsAnyAnimationInProgress(false);
      nextTurn(newGameData);
    } else {
      await animateDrawCards(newGameData, currentPlayer, 1, false, false);
      setIsAITurnInProgress(false);
      return;
    }
  };

  const handleAITurn = async (gameData) => {
    if (!gameData || isPlayerActionInProgress || isAnyAnimationInProgress || animatingCards.length > 0) {
      setIsAITurnInProgress(false);
      return;
    }
    const currentPlayer = gameData.players[gameData.currentPlayer];
    if (!currentPlayer.isAI || currentPlayer.eliminated) {
      setIsAITurnInProgress(false);
      return;
    }
    isAnimationInProgressRef.current = true;
    setIsAnyAnimationInProgress(true);
    const newGameData = { ...gameData };
    const topCard = newGameData.playPile[newGameData.playPile.length - 1];
    if (newGameData.pendingPickCount > 0 || (newGameData.generalMarketActive && newGameData.currentPlayer !== newGameData.generalMarketOriginatorId)) {
      const count = newGameData.pendingPickCount > 0 ? newGameData.pendingPickCount : 1;
      const isPending = newGameData.pendingPickCount > 0;
      const isGeneral = newGameData.generalMarketActive && newGameData.currentPlayer !== newGameData.generalMarketOriginatorId && !isPending;
      await animateDrawCards(newGameData, currentPlayer, count, isPending, isGeneral);
    } else {
      const playableCards = currentPlayer.cards.filter(card => canPlayCard(card, topCard));
      if (playableCards.length > 0) {
        const cardToPlay = playableCards[Math.floor(Math.random() * playableCards.length)];
        const cardIndex = currentPlayer.cards.findIndex(c => c.id === cardToPlay.id);
        const mapping = getVisualPlayerMapping();
        const visualPlayerIndex = mapping.actualToVisual[gameData.currentPlayer] !== undefined ? mapping.actualToVisual[gameData.currentPlayer] : gameData.currentPlayer;
        // Use the new animation system for AI card play
        const getVisualPlayerMappingWrapper = () => getVisualPlayerMapping(currentRoom, currentUser);
        const getPlayPilePositionWrapper = (index, updatePositions) => getPlayPilePosition(index, updatePositions);
        const getExactCardPositionWrapper = (playerIndex, cardIndex, totalCards, isPlayer) => getExactCardPosition(playerIndex, cardIndex, totalCards, isPlayer);
        
        const animatingCard = createPlayerPlayAnimation(
          cardToPlay, 
          cardIndex, 
          gameData.currentPlayer, 
          currentPlayer.cards.length, 
          animationPositions, 
          getExactCardPositionWrapper
        );
        
        // Update end position with correct play pile position
        const newCardRelativeStyle = getPlayPilePosition(newGameData.playPile.length, false);
        animatingCard.endPos = {
          ...animationPositions.playPile,
          transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
          zIndex: newCardRelativeStyle.zIndex
        };
        
        // Start animation using the new system
        startAnimations([animatingCard], setAnimatingCards, () => {
          getPlayPilePosition(newGameData.playPile.length - 1, true);
        });
        
        // Wait for animation to complete
        await new Promise(resolve => setTimeout(resolve, 800));
        currentPlayer.cards = currentPlayer.cards.filter((_, idx) => idx !== cardIndex);
        newGameData.playPile = [...newGameData.playPile, cardToPlay];
        if (cardToPlay.special === 'pick2') {
          newGameData.pendingPickCount += 2;
          newGameData.lastAction = `${currentPlayer.name} - ${cardToPlay.number}${cardToPlay.shape} pick2`;
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (Pick 2) - Next player must draw 2 cards`]
          };
        } else if (cardToPlay.special === 'whot') {
          const shapes = ['●', '▲', '✚', '■', '★'];
          const chosenShape = shapes[Math.floor(Math.random() * shapes.length)];
          newGameData.playPile[newGameData.playPile.length - 1] = { ...cardToPlay, chosenShape };
          newGameData.lastAction = `${currentPlayer.name} - WHOT → ${chosenShape}`;
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played WHOT and chose ${chosenShape} as the active shape`]
          };
        } else if (cardToPlay.special === 'holdon') {
          newGameData.lastAction = `${currentPlayer.name} - ${cardToPlay.number}${cardToPlay.shape} hold`;
          newGameData.skipNextPlayer = true;
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (Hold On) - Next player's turn skipped`]
          };
        } else if (cardToPlay.special === 'generalmarket') {
          newGameData.lastAction = `${currentPlayer.name} - ${cardToPlay.number}${cardToPlay.shape} gen`;
          newGameData.generalMarketActive = true;
          newGameData.generalMarketOriginatorId = gameData.currentPlayer;
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (General Market) - All other players must draw from market`]
          };
        } else {
          newGameData.lastAction = `${currentPlayer.name} - ${cardToPlay.number}${cardToPlay.shape}`;
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape}`]
          };
        }
        if (currentPlayer.cards.length === 0) {
          setGameData(newGameData);
          handleRoundEnd(newGameData);
          setIsAITurnInProgress(false);
          isAnimationInProgressRef.current = false;
          setIsAnyAnimationInProgress(false);
          return;
        }
        const nextPlayerIndex = getNextPlayer(newGameData);
        newGameData.currentPlayer = nextPlayerIndex;
        newGameData.skipNextPlayer = false;
        if (newGameData.generalMarketActive && nextPlayerIndex === newGameData.generalMarketOriginatorId) {
          newGameData.generalMarketActive = false;
          newGameData.generalMarketOriginatorId = null;
          newGameData.lastAction += ' General Market effect ends.';
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), 'General Market effect ended - all players have drawn']
          };
        }
        setGameData(newGameData);
      } else {
        await animateDrawCards(newGameData, currentPlayer, 1, false, false);
      }
    }
    setIsAITurnInProgress(false);
    setIsAnyAnimationInProgress(false);
  };



  const handleRoundEnd = gameData => {
    console.log('=== handleRoundEnd called ===');
    console.log('Game data:', gameData);
    console.log('Current gameData state:', gameData);
    console.log('Current isAnyAnimationInProgress:', isAnyAnimationInProgress);
    const activePlayers = gameData.players.filter(p => !p.eliminated);
    const playersWithTotals = activePlayers.map(p => ({
      ...p,
      cardTotal: calculateCardTotal(p.cards),
      cardCount: p.cards.length
    }));
    let maxTotal = Math.max(...playersWithTotals.map(p => p.cardTotal));
    const playersWithMaxTotal = playersWithTotals.filter(p => p.cardTotal === maxTotal);
    const eliminatedPlayer = playersWithMaxTotal[Math.floor(Math.random() * playersWithMaxTotal.length)];
    const roundWinner = playersWithTotals.find(p => p.cardTotal === Math.min(...playersWithTotals.map(p => p.cardTotal)));
    const roundEndInfo = {
      winner: roundWinner,
      players: playersWithTotals.map(p => ({
        ...p,
        cardCount: p.cards.length,
        cardTotal: p.cardTotal,
        cards: p.cards.slice()
      })),
      eliminatedPlayer,
      maxCards: maxTotal,
      roundNumber: gameData.roundNumber
    };
    setRoundEndData(roundEndInfo);
    setReadyPlayers([]); // Reset ready players for new round
    setTimeout(() => {
      setShowRoundEndPopup(true);
      setTimeout(() => startConfetti(), 200);
    }, 2500);

  // Function to handle continuing to next round (called when button is clicked)
  const handleContinueToNextRound = () => {
    if (!roundEndData) return;
    
    const eliminatedPlayer = roundEndData.eliminatedPlayer;
    const remainingPlayers = gameData.players.filter(p => !p.eliminated);
    
    setGameData(prevData => {
      if (!prevData) return prevData;
      const nextRoundGameData = { ...prevData };
      const eliminatedPlayerInNewData = nextRoundGameData.players.find(p => p.id === eliminatedPlayer.id);
      if (eliminatedPlayerInNewData) {
        eliminatedPlayerInNewData.eliminated = true;
      }
      nextRoundGameData.lastAction = `${eliminatedPlayer.name.split(' ')[0]} eliminated`;
      nextRoundGameData.gameLog = {
        ...nextRoundGameData.gameLog,
        [nextRoundGameData.roundNumber]: [
          ...(nextRoundGameData.gameLog[nextRoundGameData.roundNumber] || []),
          `Round ${nextRoundGameData.roundNumber}: ${eliminatedPlayer.name} eliminated with ${roundEndData.maxCards} total card points`
        ]
      };
      nextRoundGameData.roundNumber++;
      
      if (remainingPlayers.length <= 1) {
        nextRoundGameData.gamePhase = 'gameEnd';
        const winner = remainingPlayers.length > 0 ? remainingPlayers[0] : roundEndData.winner;
        nextRoundGameData.winner = winner;
        nextRoundGameData.lastAction = `${winner.name.split(' ')[0]} wins!`;
        nextRoundGameData.gameLog[nextRoundGameData.roundNumber] = [`GAME OVER: ${winner.name} wins the game!`];
        setShowRoundEndPopup(false);
        if (currentUser) {
          const isWinner = winner.id === currentUser.id;
          const newXP = (currentUser.xp || 0) + (isWinner ? 150 : 50);
          const levelData = calculateLevel(newXP);
          update(ref(db, `users/${currentUser.id}`), {
              gamesPlayed: (currentUser.gamesPlayed || 0) + 1,
              gamesWon: isWinner ? (currentUser.gamesWon || 0) + 1 : currentUser.gamesWon || 0,
              xp: newXP,
              level: levelData.level,
              currentLevelXP: levelData.currentLevelXP,
              xpNeededForNext: levelData.xpNeededForNext,
              currentWinStreak: isWinner ? (currentUser.currentWinStreak || 0) + 1 : 0,
              bestWinStreak: isWinner ? Math.max((currentUser.currentWinStreak || 0) + 1, currentUser.bestWinStreak || 0) : currentUser.bestWinStreak || 0
          });
        }
        setTimeout(() => {
          setGameState('menu');
          setGameData(null);
        }, 10000);
        return nextRoundGameData;
      } else {
        console.log('Setting up new round with dealing animation...');
        const newDeck = createDeck();
        const shuffledNewDeck = shuffleDeck(newDeck);
        nextRoundGameData.players.forEach(player => {
          player.cards = [];
        });
        nextRoundGameData.playPile = [];
        nextRoundGameData.drawPile = shuffledNewDeck;
        const firstPlayerIndex = nextRoundGameData.players.findIndex(p => !p.eliminated);
        nextRoundGameData.currentPlayer = firstPlayerIndex !== -1 ? firstPlayerIndex : 0;
        nextRoundGameData.pendingPickCount = 0;
        nextRoundGameData.generalMarketActive = false;
        nextRoundGameData.generalMarketOriginatorId = null;
        nextRoundGameData.skipNextPlayer = false;
        nextRoundGameData.gamePhase = 'dealingCards';
        nextRoundGameData.lastAction = 'Dealing cards...';
        nextRoundGameData.gameLog[nextRoundGameData.roundNumber] = [`Round ${nextRoundGameData.roundNumber} begins with remaining players.`, `New deck created and shuffled.`];
        setAnimatingCards([]);
        setPlayerScrollIndex(0);
        setNeedNewMarketPositions(true);
        playPilePositionsRef.current = [];
        // play pile positions are managed in Game.jsx
        setPlayPileCardPositions({});
        setIsAITurnInProgress(false);
        setIsPlayerActionInProgress(false);
        isAnimationInProgressRef.current = false;
        setIsAnyAnimationInProgress(false);
        setSelectedLogRound(nextRoundGameData.roundNumber);
        setShowRoundEndPopup(false);
        setRoundEndData(null);
        setConfettiActive(false);
        
        setTimeout(() => {
          const cardsPerPlayer = getCardsPerPlayer(remainingPlayers.length);
          console.log(`Round end - remaining players: ${remainingPlayers.length}, cards per player: ${cardsPerPlayer}, total cards to deal: ${remainingPlayers.length * cardsPerPlayer}`);
          console.log('About to call startDealingAnimation, isAnyAnimationInProgress should be false');
          console.log('Shuffled deck length:', shuffledNewDeck.length);
          console.log('Remaining players:', remainingPlayers);
          startDealingAnimation([...shuffledNewDeck], remainingPlayers, cardsPerPlayer);
        }, 100);
        return nextRoundGameData;
      }
    });
  };
  };

  const handleMultiplayerRoundEnd = async (gameData) => {
    const activePlayers = gameData.players.filter(p => !p.eliminated);
    const playersWithTotals = activePlayers.map(p => ({
      ...p,
      cardTotal: calculateCardTotal(p.cards),
      cardCount: p.cards.length
    }));
    let maxTotal = Math.max(...playersWithTotals.map(p => p.cardTotal));
    const playersWithMaxTotal = playersWithTotals.filter(p => p.cardTotal === maxTotal);
    const eliminatedPlayer = playersWithMaxTotal[Math.floor(Math.random() * playersWithMaxTotal.length)];
    const roundWinner = playersWithTotals.find(p => p.cardTotal === Math.min(...playersWithTotals.map(p => p.cardTotal)));
    
    const roundEndInfo = {
      winner: roundWinner,
      players: playersWithTotals.map(p => ({
        ...p,
        cardCount: p.cards.length,
        cardTotal: p.cardTotal,
        cards: p.cards.slice()
      })),
      eliminatedPlayer,
      maxCards: maxTotal,
      roundNumber: gameData.roundNumber
    };
    setRoundEndData(roundEndInfo);
    setReadyPlayers([]); // Reset ready players for new round
    setTimeout(() => {
      setShowRoundEndPopup(true);
      setTimeout(() => startConfetti(), 200);
    }, 2500);
        };

  // Function to handle continuing to next round in multiplayer (called when button is clicked)
  const handleMultiplayerContinueToNextRound = async () => {
    if (!roundEndData || !currentRoom) return;
    
    // Add current user to ready players
    const newReadyPlayers = [...readyPlayers];
    if (!newReadyPlayers.includes(currentUser.id)) {
      newReadyPlayers.push(currentUser.id);
      setReadyPlayers(newReadyPlayers);
    }
    
    // Update ready players in Firebase
    await update(ref(db, `rooms/${currentRoom.id}/readyPlayers`), newReadyPlayers);
    
    // Check if all remaining players are ready
    const remainingPlayers = gameData.players.filter(p => !p.eliminated);
    if (newReadyPlayers.length >= remainingPlayers.length) {
      // All players are ready, proceed to next round
      const eliminatedPlayer = roundEndData.eliminatedPlayer;
      
      const newGameData = { ...gameData };
      const eliminatedPlayerInNewData = newGameData.players.find(p => p.id === eliminatedPlayer.id);
      if (eliminatedPlayerInNewData) {
        eliminatedPlayerInNewData.eliminated = true;
      }
      newGameData.lastAction = `${eliminatedPlayer.name.split(' ')[0]} eliminated`;
      newGameData.gameLog = {
        ...newGameData.gameLog,
        [newGameData.roundNumber]: [
          ...(newGameData.gameLog[newGameData.roundNumber] || []),
          `Round ${newGameData.roundNumber}: ${eliminatedPlayer.name} eliminated with ${roundEndData.maxCards} total card points`
        ]
      };
      newGameData.roundNumber++;
      const remainingPlayersAfterElimination = newGameData.players.filter(p => !p.eliminated);
      
      if (remainingPlayersAfterElimination.length <= 1) {
        newGameData.gamePhase = 'gameEnd';
        const winner = remainingPlayersAfterElimination.length > 0 ? remainingPlayersAfterElimination[0] : roundEndData.winner;
        newGameData.winner = winner;
        newGameData.lastAction = `${winner.name.split(' ')[0]} wins!`;
        newGameData.gameLog[newGameData.roundNumber] = [`GAME OVER: ${winner.name} wins the game!`];
        await update(ref(db, `rooms/${currentRoom.id}/gameData`), newGameData);
        setTimeout(() => {
          setGameState('menu');
          setGameData(null);
        }, 10000);
      } else {
        const newDeck = createDeck();
        const shuffledNewDeck = shuffleDeck(newDeck);
        // Precompute next-round hands and piles
        const remainingPlayersCount = remainingPlayersAfterElimination.length;
        const cardsPerPlayer = getCardsPerPlayer(remainingPlayersCount);
        const totalToDeal = remainingPlayersCount * cardsPerPlayer;
        const targetPlayers = newGameData.players.map(p => ({ ...p, cards: p.eliminated ? [] : [] }));
        // deal to non-eliminated players in order
        let dealCursor = 0;
        for (let i = 0; i < totalToDeal; i++) {
          while (targetPlayers[dealCursor % targetPlayers.length].eliminated) dealCursor++;
          const idx = dealCursor % targetPlayers.length;
          targetPlayers[idx].cards.push(shuffledNewDeck[i]);
          dealCursor++;
        }
        const remainingAfterDeal = shuffledNewDeck.slice(totalToDeal);
        const initialPlayCard = remainingAfterDeal[0];
        if (initialPlayCard?.special === 'whot') {
          const shapes = ['●', '▲', '✚', '■', '★'];
          initialPlayCard.chosenShape = shapes[Math.floor(Math.random() * shapes.length)];
        }
        const remainingDrawPile = remainingAfterDeal.slice(1);
        const firstPlayerIndex = newGameData.players.findIndex(p => !p.eliminated);
        const nextSnapshot = sanitizeGameData({
          ...newGameData,
          players: targetPlayers,
          playPile: initialPlayCard ? [initialPlayCard] : [],
          drawPile: remainingDrawPile,
          currentPlayer: firstPlayerIndex !== -1 ? firstPlayerIndex : 0,
          pendingPickCount: 0,
          generalMarketActive: false,
          generalMarketOriginatorId: null,
          skipNextPlayer: false,
          gamePhase: 'dealingCards',
          cardsPerPlayer,
          lastAction: 'Dealing cards...',
          gameLog: {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [`Round ${newGameData.roundNumber} begins with remaining players.`, `New deck created and shuffled.`]
          }
        });
        await update(ref(db, `rooms/${currentRoom.id}/gameData`), nextSnapshot);
        // Reset local UI state; listener will animate based on snapshot
        setAnimatingCards([]);
        setPlayerScrollIndex(0);
        setNeedNewMarketPositions(true);
        playPilePositionsRef.current = [];
        setPlayPileCardPositions({});
        setIsAITurnInProgress(false);
        setIsPlayerActionInProgress(false);
        isAnimationInProgressRef.current = false;
        setIsAnyAnimationInProgress(false);
        setSelectedLogRound(nextSnapshot.roundNumber);
        setShowRoundEndPopup(false);
        setRoundEndData(null);
        setConfettiActive(false);
        setReadyPlayers([]);
      }
    }
  };

  const handleAutoPlay = async () => {
    if (!gameData || !currentRoom || !currentUser) return;
    const currentUserActualIndex = gameData.players.findIndex(p => p.id === (currentUser?.id));
    if (currentUserActualIndex === -1) return;
    if (gameData.currentPlayer !== currentUserActualIndex) return;
    const currentPlayerData = gameData.players[currentUserActualIndex];
    try {
      const topCard = gameData.playPile[gameData.playPile.length - 1];
      const playableCards = currentPlayerData.cards.filter(card => canPlayCard(card, topCard));
      if (playableCards.length > 0) {
        const cardToPlay = playableCards[0];
        const cardIndex = currentPlayerData.cards.findIndex(c => c.id === cardToPlay.id);
        await playMultiplayerCard(cardIndex);
      } else {
        await drawMultiplayerCard();
      }
    } catch (error) {
      console.error('Error with auto-play:', error);
    }
  };

  const chooseWhotShape = async shape => {
    if (!pendingWhotCard || isPlayerActionInProgress || isAnyAnimationInProgress) return;
    setIsPlayerActionInProgress(true);
    const newGameData = { ...gameData };
    const whotCard = { ...pendingWhotCard, chosenShape: shape };
    newGameData.playPile[newGameData.playPile.length - 1] = whotCard;
    if (currentRoom) {
      const currentUserActualIndex = gameData.players.findIndex(p => p.id === (currentUser?.id));
      const currentPlayer = newGameData.players[currentUserActualIndex];
      newGameData.lastAction = `${currentPlayer.name} - WHOT → ${shape}`;
      newGameData.gameLog = {
        ...newGameData.gameLog,
        [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played WHOT and chose ${shape} as the active shape`]
      };
      setShowWhotChoice(false);
      setPendingWhotCard(null);
      if (currentPlayer.cards.length === 0) {
        await handleMultiplayerRoundEnd(newGameData);
      } else {
        const nextPlayerIndex = getNextPlayer(newGameData);
        newGameData.currentPlayer = nextPlayerIndex;
        newGameData.skipNextPlayer = false;
        if (newGameData.generalMarketActive && nextPlayerIndex === newGameData.generalMarketOriginatorId) {
          newGameData.generalMarketActive = false;
          newGameData.generalMarketOriginatorId = null;
          newGameData.lastAction += ' General Market effect ends.';
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), 'General Market effect ended - all players have drawn']
          };
        }
        // Update local state immediately for better responsiveness
        setGameData(newGameData);
        await update(ref(db, `rooms/${currentRoom.id}/gameData`), newGameData);
      }
      setIsPlayerActionInProgress(false);
    } else {
      newGameData.lastAction = `You - WHOT → ${shape}`;
      newGameData.gameLog = {
        ...newGameData.gameLog,
        [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played WHOT and chose ${shape} as the active shape`]
      };
      setShowWhotChoice(false);
      setPendingWhotCard(null);
      if (newGameData.players[0].cards.length === 0) {
        handleRoundEnd(newGameData);
      } else {
        nextTurn(newGameData);
      }
      setGameData(newGameData);
      setIsPlayerActionInProgress(false);
      setIsAnyAnimationInProgress(false);
    }
  };

  const createRoom = async () => {
    if (!currentUser) return;
    
    const roomRef = ref(db, 'rooms');
    const newRoomRef = push(roomRef);
    const roomData = {
      id: newRoomRef.key,
      ownerId: currentUser.id,
      ownerUsername: currentUser.username,
      players: { [currentUser.id]: { ...currentUser, ready: true } },
      maxPlayers: 4,
      status: 'waiting',
      createdAt: serverTimestamp(),
      lastActive: Date.now()
    };
    
    await set(newRoomRef, roomData);
    setCurrentRoom(roomData);
    setGameState('room');
  };

  const joinRoom = async (roomId) => {
    if (!currentUser) return;
    
    const roomRef = ref(db, `rooms/${roomId}`);
    const roomSnapshot = await get(roomRef);
    if (!roomSnapshot.exists()) return;
    
    const roomData = roomSnapshot.val();
    if (Object.keys(roomData.players || {}).length >= roomData.maxPlayers) return;
    
    await update(roomRef, {
      [`players/${currentUser.id}`]: { ...currentUser, ready: false },
      lastActive: Date.now()
    });
    
    setCurrentRoom({ ...roomData, id: roomId });
    setGameState('room');
  };

  const toggleReady = async () => {
    if (!currentUser || !currentRoom) return;
    
    const roomRef = ref(db, `rooms/${currentRoom.id}`);
    const currentReady = currentRoom.players?.[currentUser.id]?.ready || false;
    
    try {
      await update(roomRef, {
        [`players/${currentUser.id}/ready`]: !currentReady,
        lastActive: Date.now()
      });
    } catch (e) {
      console.error('Failed to toggle ready state:', e);
    }
  };

  const startGameCountdown = async () => {
    if (!currentRoom || currentRoom.ownerId !== currentUser?.id) return;
    
    const roomRef = ref(db, `rooms/${currentRoom.id}`);
    await update(roomRef, {
      status: 'countdown',
      countdown: 5,
      lastActive: Date.now()
    });
    // Drive countdown ticks from owner
    let secs = 5;
    const interval = setInterval(async () => {
      secs -= 1;
      if (secs <= 0) {
        clearInterval(interval);
        await startMultiplayerGame();
      } else {
        await update(roomRef, { 
          countdown: secs,
          lastActive: Date.now()
        });
      }
    }, 1000);
  };

  // Ensure gameData has valid array structure before using or writing to Firebase
  function sanitizeGameData(input) {
    if (!input || typeof input !== 'object') return input;
    const safePlayers = Array.isArray(input.players)
      ? input.players.map(p => ({
          ...p,
          cards: Array.isArray(p?.cards) ? [...p.cards] : []
        }))
      : [];
    const safeGameData = {
      ...input,
      players: safePlayers,
      playPile: Array.isArray(input.playPile) ? [...input.playPile] : [],
      drawPile: Array.isArray(input.drawPile) ? [...input.drawPile] : [],
      gameLog: input.gameLog && typeof input.gameLog === 'object' ? input.gameLog : {}
    };
    return safeGameData;
  }



  const startMultiplayerGame = async () => {
    if (!currentRoom || !currentUser || currentUser.id !== currentRoom.ownerId) return;
    updateGameActivity(); // Track activity for timeout
    try {
      // Create and deal cards immediately like AI game, no animation
      const deck = createDeck();
      const shuffledDeck = shuffleDeck(deck);
      const playersList = Object.values(currentRoom.players || {});
      const cardsPerPlayer = getCardsPerPlayer(playersList.length);
      
      const players = playersList.map((player, index) => ({
        id: player.id,
        name: player.username,
        cards: [],
        isAI: false,
        eliminated: false
      }));
      
      // Ensure all players have proper cards arrays
      players.forEach(player => {
        if (!Array.isArray(player.cards)) {
          player.cards = [];
        }
      });
      
      // Pre-compute final dealt hands and piles so all clients can animate locally
      const totalToDeal = players.length * cardsPerPlayer;
      const targetPlayers = players.map(p => ({ ...p, cards: [] }));
      for (let i = 0; i < totalToDeal; i++) {
        const pIdx = i % players.length;
        targetPlayers[pIdx].cards.push(shuffledDeck[i]);
      }
      const remainingAfterDeal = shuffledDeck.slice(totalToDeal);
      const initialPlayCard = remainingAfterDeal[0];
      if (initialPlayCard?.special === 'whot') {
        const shapes = ['●', '▲', '✚', '■', '★'];
        initialPlayCard.chosenShape = shapes[Math.floor(Math.random() * shapes.length)];
      }
      const remainingDrawPile = remainingAfterDeal.slice(1);

      const initialGameData = sanitizeGameData({
        players: targetPlayers,
        playPile: initialPlayCard ? [initialPlayCard] : [],
        drawPile: remainingDrawPile,
        currentPlayer: 0,
        gamePhase: 'dealingCards',
        roundNumber: 1,
        lastAction: 'Dealing cards...',
        pendingPickCount: 0,
        generalMarketActive: false,
        generalMarketOriginatorId: null,
        dealingStartAt: serverTimestamp(),
        cardsPerPlayer,
        gameLog: {
          1: [`Game started with ${players.length} players: ${players.map(p => p.name).join(', ')}`, 'Cards dealt to all players', 'The shadow realm awaits your first move...']
        }
      });

      // Save complete game state to Firebase while preserving room metadata
      const updateData = {
        status: 'playing',
        gameData: initialGameData,
        countdown: null,
        lastActive: Date.now()
      };
      
      // Only add room metadata if it exists to avoid undefined values
      if (currentRoom.players) updateData.players = currentRoom.players;
      if (currentRoom.name) updateData.name = currentRoom.name;
      if (currentRoom.maxPlayers) updateData.maxPlayers = currentRoom.maxPlayers;
      if (currentRoom.ownerId) updateData.ownerId = currentRoom.ownerId;
      if (currentRoom.createdAt) updateData.createdAt = currentRoom.createdAt;
      
      console.log('🔥 Sending Firebase update with gameData:', updateData);
      // Ensure we don't send undefined arrays/fields
      const safeUpdate = JSON.parse(JSON.stringify(updateData));
      await update(ref(db, `rooms/${currentRoom.id}`), safeUpdate);
      console.log('✅ Firebase update completed successfully');
      
      // Reset UI states before setting game state
      setAnimatingCards([]);
      setPlayerScrollIndex(0);
      setNeedNewMarketPositions(true);
      playPilePositionsRef.current = [];
      setPlayPileCardPositions({});
      setIsAITurnInProgress(false);
      setIsPlayerActionInProgress(false);
      setIsAnyAnimationInProgress(false);
      setSelectedLogRound(1);
      setShowRoundEndPopup(false);
      setRoundEndData(null);
      setConfettiActive(false);

      // Move to game state; listener will animate locally from Firebase snapshot
      setGameState('game');

      console.log(`Multiplayer game started with ${players.length} players, ${cardsPerPlayer} cards each`);

    } catch (error) {
      console.error('❌ Error starting multiplayer game:', error);
    }
  };

  const playCard = async cardIndex => {
    if (!gameData || gameData.currentPlayer !== 0 || isPlayerActionInProgress || isAnyAnimationInProgress || animatingCards.length > 0) return;
    updateGameActivity(); // Track activity for timeout
    setIsPlayerActionInProgress(true);
    isAnimationInProgressRef.current = true;
    setIsAnyAnimationInProgress(true);
    const newGameData = JSON.parse(JSON.stringify(gameData));
    const player = newGameData.players[0];
    const actualCardIndex = cardIndex + playerScrollIndex;
    const card = player.cards[actualCardIndex];
    const topCard = newGameData.playPile[newGameData.playPile.length - 1];
    if (topCard.chosenShape) {
      if (card.special !== 'whot' && card.shape !== topCard.chosenShape) {
        setIsPlayerActionInProgress(false);
        isAnimationInProgressRef.current = false;
        setIsAnyAnimationInProgress(false);
        return;
      }
    } else if (!canPlayCard(card, topCard)) {
      setIsPlayerActionInProgress(false);
      isAnimationInProgressRef.current = false;
      setIsAnyAnimationInProgress(false);
      return;
    }
    // Play sound based on card type
    console.log('🎵 Playing card sound for:', card.number, card.shape, card.special);
    console.log('🎵 Sound effects initialized:', soundEffects.isInitialized, 'enabled:', soundEffects.isEnabled);
    if (card.special === 'whot' || card.special === 'pick2' || card.special === 'holdon' || card.special === 'generalmarket') {
      console.log('🎵 Playing special card sound');
      soundEffects.playSpecialCard();
    } else {
      console.log('🎵 Playing regular card sound');
      soundEffects.playCardPlay();
    }
    
    // Force a small delay to ensure sound plays
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Create animation using original logic
    const newCardRelativeStyle = getPlayPilePosition(newGameData.playPile.length, false);
    const endPosition = {
      ...animationPositions.playPile,
      transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
      zIndex: newCardRelativeStyle.zIndex
    };
    
    const animatingCard = {
      ...card,
      id: `animating-${Date.now()}-${actualCardIndex}`,
      startPos: getExactCardPosition(0, actualCardIndex, player.cards.length, true),
      endPos: endPosition,
      isPlayerCard: true
    };
    
    setAnimatingCards(prev => {
      console.log('🎴 Adding play card animation:', animatingCard.id, 'Total animating cards:', prev.length + 1);
      return [...prev, animatingCard];
    });
    player.cards = player.cards.filter((_, idx) => idx !== actualCardIndex);
    newGameData.playPile = [...newGameData.playPile, card];
    const newCardsLength = player.cards.length;
    const maxScroll = Math.max(0, newCardsLength - maxVisiblePlayerCards);
    if (newCardsLength <= maxVisiblePlayerCards) {
      setPlayerScrollIndex(0);
    } else if (playerScrollIndex >= maxScroll) {
      setPlayerScrollIndex(maxScroll);
    } else if (actualCardIndex < playerScrollIndex + Math.floor(maxVisiblePlayerCards / 2)) {
      setPlayerScrollIndex(Math.max(0, playerScrollIndex - 1));
    }
    setTimeout(() => {
      setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
      getPlayPilePosition(newGameData.playPile.length - 1, true);
      if (card.special === 'pick2') {
        newGameData.pendingPickCount += 2;
        newGameData.lastAction = `You - ${card.number}${card.shape} pick2`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape} (Pick 2) - Next player must draw 2 cards`]
        };
      } else if (card.special === 'whot') {
        setPendingWhotCard(card);
        setShowWhotChoice(true);
        setGameData(newGameData);
        setIsPlayerActionInProgress(false);
        isAnimationInProgressRef.current = false;
        setIsAnyAnimationInProgress(false);
        return;
      } else if (card.special === 'holdon') {
        newGameData.lastAction = `You - ${card.number}${card.shape} hold`;
        newGameData.skipNextPlayer = true;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape} (Hold On) - Next player's turn skipped`]
        };
      } else if (card.special === 'generalmarket') {
        newGameData.lastAction = `You - ${card.number}${card.shape} gen`;
        newGameData.generalMarketActive = true;
        newGameData.generalMarketOriginatorId = 0;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape} (General Market) - All other players must draw from market`]
        };
      } else {
        newGameData.lastAction = `You - ${card.number}${card.shape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape}`]
        };
      }
      if (player.cards.length === 0) {
        setGameData(newGameData);
        handleRoundEnd(newGameData);
        setIsPlayerActionInProgress(false);
        isAnimationInProgressRef.current = false;
        setIsAnyAnimationInProgress(false);
      } else {
        setGameData(newGameData);
        setIsPlayerActionInProgress(false);
        isAnimationInProgressRef.current = false;
        setIsAnyAnimationInProgress(false);
        if (newGameData.gamePhase === 'playing') {
          nextTurn(newGameData);
        }
      }
    }, 800);
  };

  const playMultiplayerCard = async (cardIndex) => {
    if (!gameData || !currentRoom || !currentUser || isPlayerActionInProgress) return;
    
    const currentUserActualIndex = gameData.players.findIndex(p => p.id === currentUser.id);
    if (currentUserActualIndex === -1) return;
    if (gameData.currentPlayer !== currentUserActualIndex) {
      console.log('🎴 Not your turn! Current player:', gameData.currentPlayer, 'Your index:', currentUserActualIndex);
      return;
    }
    
    const currentPlayerData = gameData.players[currentUserActualIndex];
    const actualCardIndex = cardIndex + playerScrollIndex;
    const card = currentPlayerData.cards[actualCardIndex];
    const topCard = gameData.playPile[gameData.playPile.length - 1];
    
    if (topCard.chosenShape) {
      if (card.special !== 'whot' && card.shape !== topCard.chosenShape) return;
    } else if (!canPlayCard(card, topCard)) {
      return;
    }
    
    try {
      setIsPlayerActionInProgress(true);
      setIsAnyAnimationInProgress(true);
      
      const newCardRelativeStyle = getPlayPilePosition(gameData.playPile.length, false);
      const endPosition = {
        ...animationPositions.playPile,
        transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
        zIndex: newCardRelativeStyle.zIndex
      };
      
      const animatingCard = {
        ...card,
        id: `player-play-${Date.now()}-${actualCardIndex}`,
        startPos: getExactCardPosition(currentUserActualIndex, actualCardIndex, currentPlayerData.cards.length, true),
        endPos: endPosition,
        isPlayerCard: true,
        type: 'player-play'
      };
      
      // Start animation using the modular system
      startAnimations([animatingCard], setAnimatingCards, () => {
        getPlayPilePosition(gameData.playPile.length, true);
      });
      
      // Wait for animation to complete
      await new Promise(resolve => setTimeout(resolve, 800));
      
      const newGameData = {
        ...gameData
      };
      const newPlayers = [...newGameData.players];
      const currentPlayer = {
        ...newPlayers[currentUserActualIndex]
      };
      currentPlayer.cards = currentPlayer.cards.filter((_, idx) => idx !== actualCardIndex);
      newPlayers[currentUserActualIndex] = currentPlayer;
      newGameData.players = newPlayers;
      newGameData.playPile = [...newGameData.playPile, card];
      
      const newCardsLength = currentPlayer.cards.length;
      const maxScroll = Math.max(0, newCardsLength - maxVisiblePlayerCards);
      if (newCardsLength <= maxVisiblePlayerCards) {
        setPlayerScrollIndex(0);
      } else if (playerScrollIndex >= maxScroll) {
        setPlayerScrollIndex(maxScroll);
      } else if (actualCardIndex < playerScrollIndex + Math.floor(maxVisiblePlayerCards / 2)) {
        setPlayerScrollIndex(Math.max(0, playerScrollIndex - 1));
      }
      
      if (card.special === 'pick2') {
        newGameData.pendingPickCount += 2;
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape} pick2`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape} (Pick 2) - Next player must draw 2 cards`]
        };
      } else if (card.special === 'whot') {
        setPendingWhotCard(card);
        setShowWhotChoice(true);
        setGameData(newGameData);
        setIsPlayerActionInProgress(false);
        setIsAnyAnimationInProgress(false);
        return;
      } else if (card.special === 'holdon') {
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape} hold`;
        newGameData.skipNextPlayer = true;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape} (Hold On) - Next player's turn skipped`]
        };
      } else if (card.special === 'generalmarket') {
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape} gen`;
        newGameData.generalMarketActive = true;
        newGameData.generalMarketOriginatorId = currentUserActualIndex;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape} (General Market) - All other players must draw from market`]
        };
      } else {
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape}`]
        };
      }
      
      if (currentPlayer.cards.length === 0) {
        await handleMultiplayerRoundEnd(newGameData);
      } else {
        const nextPlayerIndex = getNextPlayer(newGameData);
        newGameData.currentPlayer = nextPlayerIndex;
        newGameData.skipNextPlayer = false;
        if (newGameData.generalMarketActive && nextPlayerIndex === newGameData.generalMarketOriginatorId) {
          newGameData.generalMarketActive = false;
          newGameData.generalMarketOriginatorId = null;
          newGameData.lastAction += ' General Market effect ends.';
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), 'General Market effect ended - all players have drawn']
          };
        }
        // Update local state immediately for better responsiveness
        setGameData(newGameData);
        await update(ref(db, `rooms/${currentRoom.id}/gameData`), newGameData);
      }
      
      setIsPlayerActionInProgress(false);
      setIsAnyAnimationInProgress(false);
    } catch (error) {
      console.error('Error playing multiplayer card:', error);
      setIsPlayerActionInProgress(false);
    }
  };

  const drawCard = async () => {
    if (!gameData || gameData.currentPlayer !== 0 || animatingCards.length > 0 || isPlayerActionInProgress || isAnyAnimationInProgress) return;
    updateGameActivity(); // Track activity for timeout
    setIsPlayerActionInProgress(true);
    isAnimationInProgressRef.current = true;
    setIsAnyAnimationInProgress(true);
    const newGameData = {
      ...gameData
    };
    const player = newGameData.players[0];
    const count = newGameData.pendingPickCount > 0 ? newGameData.pendingPickCount : newGameData.generalMarketActive && newGameData.currentPlayer !== newGameData.generalMarketOriginatorId ? 1 : 1;
    const isPending = newGameData.pendingPickCount > 0;
    const isGeneral = newGameData.generalMarketActive && newGameData.currentPlayer !== newGameData.generalMarketOriginatorId && !isPending;
    await animateDrawCards(newGameData, player, count, isPending, isGeneral);
  };

  const drawMultiplayerCard = async () => {
    if (!gameData || !currentRoom || isPlayerActionInProgress || isAnyAnimationInProgress || animatingCards.length > 0) return;
    updateGameActivity(); // Track activity for timeout
    
    const currentUserActualIndex = gameData.players.findIndex(p => p.id === (currentUser?.id));
    if (gameData.currentPlayer !== currentUserActualIndex) {
      console.log('🎴 Not your turn to draw! Current player:', gameData.currentPlayer, 'Your index:', currentUserActualIndex);
      return;
    }
    
    const currentPlayer = gameData.players[currentUserActualIndex];
    if (currentPlayer.eliminated) return;
    
    setIsPlayerActionInProgress(true);
    isAnimationInProgressRef.current = true;
    setIsAnyAnimationInProgress(true);
    
    const newGameData = JSON.parse(JSON.stringify(gameData));
    const player = newGameData.players[currentUserActualIndex];
    
    // Handle card drawing like AI game with animation
    if (newGameData.drawPile.length <= 1) {
      reshuffleMarket(newGameData);
    }
    
    if (newGameData.drawPile.length > 0) {
      const cardsToDraw = newGameData.pendingPickCount > 0 ? newGameData.pendingPickCount : 1;
      const isPending = newGameData.pendingPickCount > 0;
      const isGeneral = newGameData.generalMarketActive && newGameData.currentPlayer !== newGameData.generalMarketOriginatorId && !isPending;
      
      // Use the same animation function as AI game
      await animateDrawCards(newGameData, player, cardsToDraw, isPending, isGeneral);
      
      // Clear pending pick count after drawing
      if (newGameData.pendingPickCount > 0) {
        newGameData.pendingPickCount = 0;
        newGameData.lastAction = `${player.name} picked ${cardsToDraw} cards`;
      } else {
        newGameData.lastAction = `${player.name} drew a card`;
      }
      
      newGameData.gameLog = {
        ...newGameData.gameLog,
        [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), newGameData.lastAction]
      };
    }
    
    // Move to next player like AI game
    const nextPlayerIndex = getNextPlayer(newGameData);
    newGameData.currentPlayer = nextPlayerIndex;
    newGameData.skipNextPlayer = false;
    
    // Update local state immediately for better responsiveness
    setGameData(newGameData);
    // Update Firebase with complete state
    await update(ref(db, `rooms/${currentRoom.id}/gameData`), newGameData);
    setIsPlayerActionInProgress(false);
    isAnimationInProgressRef.current = false;
    setIsAnyAnimationInProgress(false);
  };

  const leaveRoom = async () => {
    if (!currentUser || !currentRoom) return;
    
    // Clear game timeout when leaving room
    if (gameTimeoutRef.current) {
      clearTimeout(gameTimeoutRef.current);
      gameTimeoutRef.current = null;
    }
    
    const roomRef = ref(db, `rooms/${currentRoom.id}`);
    await remove(ref(db, `rooms/${currentRoom.id}/players/${currentUser.id}`));
    
    const roomSnapshot = await get(roomRef);
    if (roomSnapshot.exists()) {
      const roomData = roomSnapshot.val();
      if (Object.keys(roomData.players || {}).length === 0) {
        await remove(roomRef);
      }
    }
    
    // Clean up localStorage
    try {
      localStorage.removeItem(`whotgo_room_${currentRoom.id}`);
      localStorage.removeItem(`whotgo_currentRoom`);
    } catch (e) {
      console.warn('Failed to clean up room data from localStorage:', e);
    }
    
    setCurrentRoom(null);
    setGameState('menu');
  };

  const initializeGame = () => {
    updateGameActivity(); // Track activity for timeout
    const deck = createDeck();
    const shuffledDeck = shuffleDeck(deck);
    const players = [{
      id: 0,
      name: 'You',
      cards: [],
      isAI: false,
      eliminated: false
    }, {
      id: 1,
      name: 'AI Shadow',
      cards: [],
      isAI: true,
      eliminated: false
    }, {
      id: 2,
      name: 'AI Phantom',
      cards: [],
      isAI: true,
      eliminated: false
    }, {
      id: 3,
      name: 'AI Wraith',
      cards: [],
      isAI: true,
      eliminated: false
    }];
    const cardsPerPlayer = getCardsPerPlayer(players.length);
    console.log(`Initializing game: ${players.length} total players (1 human + ${players.length - 1} AI), ${cardsPerPlayer} cards each`);
    playPilePositionsRef.current = [];
    // play pile positions are managed in Game.jsx
    setGameData({
      players,
      playPile: [],
      drawPile: shuffledDeck,
      currentPlayer: 0,
      gamePhase: 'dealingCards',
      roundNumber: 1,
      lastAction: 'Dealing cards...',
      pendingPickCount: 0,
      generalMarketActive: false,
      generalMarketOriginatorId: null,
      gameLog: {
        1: [`Game started with ${players.length} players: ${players.map(p => p.name).join(', ')}`, 'Cards dealt to all players', 'The shadow realm awaits your first move...']
      }
    });
    setTimeout(() => startDealingAnimation([...shuffledDeck], players, cardsPerPlayer), 500);
  };

  const returnToMenu = () => {
    // Clear game timeout
    if (gameTimeoutRef.current) {
      clearTimeout(gameTimeoutRef.current);
      gameTimeoutRef.current = null;
    }
    
    if (currentRoom) {
      leaveRoom();
    } else {
      setGameState('menu');
    }
    setGameData(null);
    setShowWhotChoice(false);
    setPendingWhotCard(null);
    setAnimatingCards([]);
    setPlayerScrollIndex(0);
    setShowDeckView(false);
    setShowEliminatedPopup(false);
    setShowRoundEndPopup(false);
    setRoundEndData(null);
    setShowGameLog(false);
    setSelectedLogRound(1);
    setIsPlayerActionInProgress(false);
    setIsAITurnInProgress(false);
    setIsAnyAnimationInProgress(false);
    setActivePopup(null);
    setLastGameActivity(null);
    setAdminCardsRevealed(false);
    setAdminMarketRevealed(false);
    setShowAdminDeckOverview(false);
    setConfettiActive(false);
    setPlayPileCardPositions({});
    marketCardPositionsRef.current = [];
    playPilePositionsRef.current = [];
    setMarketCardPositions([]);
    setNeedNewMarketPositions(false);
    if (confettiCanvasRef.current) {
      const ctx = confettiCanvasRef.current.getContext('2d');
      ctx?.clearRect(0, 0, confettiCanvasRef.current.width, confettiCanvasRef.current.height);
    }
    // Clear localStorage when explicitly returning to menu
    clearGameState();
  };

  // Initialize AI game when gameState changes to 'game' without a room
  useEffect(() => {
    if (gameState === 'game' && !currentRoom && !gameData) {
      initializeGame();
    }
  }, [gameState, currentRoom, gameData]);

  // Clean up inactive rooms from client side
  const cleanupInactiveRooms = async () => {
    try {
      const roomsRef = ref(db, 'rooms');
      const snapshot = await get(roomsRef);
      if (!snapshot.exists()) return;

      const now = Date.now();
      const thresholdMs = 5 * 60 * 1000; // 5 minutes
      const updates = {};

      snapshot.forEach(roomSnap => {
        const room = roomSnap.val();
        const roomId = roomSnap.key;
        const status = room?.status;
        const lastActive = typeof room?.lastActive === 'number' ? room.lastActive : 0;
        
        // Clean up rooms that are waiting or countdown and haven't been active for 5 minutes
        const shouldDelete = (status === 'waiting' || status === 'countdown') && 
                           lastActive && (now - lastActive > thresholdMs);
        
        if (shouldDelete) {
          console.log(`Cleaning up inactive room: ${roomId} (last active: ${new Date(lastActive).toISOString()})`);
          updates[roomId] = null;
          
          // Also clean up any room-related data from localStorage
          try {
            localStorage.removeItem(`whotgo_room_${roomId}`);
            localStorage.removeItem(`whotgo_currentRoom`);
          } catch (e) {
            console.warn('Failed to clean up room data from localStorage:', e);
          }
        }
      });

      if (Object.keys(updates).length > 0) {
        await update(roomsRef, updates);
      }
    } catch (error) {
      console.error('Error cleaning up inactive rooms:', error);
    }
  };

  // Periodically clean up inactive rooms (every 2 minutes)
  useEffect(() => {
    const cleanupInterval = setInterval(cleanupInactiveRooms, 2 * 60 * 1000);
    return () => clearInterval(cleanupInterval);
  }, []);

  // Clean up stale room data from localStorage on app startup
  useEffect(() => {
    try {
      // Remove any stale room references from localStorage
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('whotgo_room_')) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(key => localStorage.removeItem(key));
      localStorage.removeItem('whotgo_currentRoom');
    } catch (e) {
      console.warn('Failed to clean up stale room data from localStorage:', e);
    }
  }, []);

  // Removed aggressive game state validation that was causing premature resets

  const renderContent = () => {
    if (gameState === 'landing') {
      return (
        <div className="h-full flex flex-col relative">
          <div className="absolute top-8 left-1/2 transform -translate-x-1/2 z-10">
            <div className="relative w-80 h-32">
              {cards.map((card, index) => (
                <div
                  key={index}
                  className={`absolute w-20 h-28 rounded-lg border border-black shadow-2xl transform transition-all duration-700 ${index === currentCard ? 'scale-110 z-20 rotate-0' : 'scale-95'}`}
                  style={{
                    backgroundColor: card.color,
                    left: `${104 + index * 18 + Math.sin(Date.now() * 0.001 + index) * 5}px`,
                    top: `${Math.cos(Date.now() * 0.001 + index) * 3}px`,
                    zIndex: index === currentCard ? 20 : 10 - index,
                    opacity: index === currentCard ? 1 : 0.7,
                    transform: `scale(${index === currentCard ? 1.1 : 0.95}) rotate(${index === currentCard ? 0 : (index - 2) * 8}deg) translateY(${Math.sin(Date.now() * 0.002 + index) * 2}px)`,
                    transition: 'all 0.7s ease-in-out'
                  }}
                >
                  <div className="flex items-center justify-center w-full h-full" dangerouslySetInnerHTML={{ __html: getCardSVGContent(card) }} />
                </div>
              ))}
            </div>
          </div>
          <div className="flex-1 flex flex-col justify-center items-center px-6 pt-32">
            <div className={`text-center transform transition-all duration-1000 ${isVisible ? 'translate-y-0 opacity-100' : 'translate-y-10 opacity-0'} max-w-6xl`}>
              <div className="mb-8">
                <h1 className="text-7xl md:text-8xl font-bold mb-4 text-white relative">
                  <span className="bg-gradient-to-r from-[#80142C] via-[#a01d39] to-[#80142C] bg-clip-text text-transparent">whot</span>
                  <span className="text-white ml-4">Go!</span>
                  <div className="absolute -inset-1 bg-gradient-to-r from-[#80142C] to [#4a0c1a] rounded-xl blur opacity-20"></div>
                </h1>
                <div className="text-[#b8869d] text-xl md:text-2xl font-medium tracking-widest">◆ THE CLASSIC 4-PLAYER CARD GAME ◆</div>
              </div>
              <div className="mb-8 max-w-2xl mx-auto">
                <p className="text-xl md:text-2xl mb-3 leading-relaxed text-gray-200">
                  Experience the <span className="text-[#80142C] font-bold">beloved classic</span> card game for everyone
                </p>
                <p className="text-base text-gray-300 leading-relaxed">
                  Strategic thinking meets fun gameplay in exciting 4-player matches with friends or AI opponents.
                </p>
              </div>
              <div className="flex flex-col items-center gap-6">
                <div className="flex items-center gap-3">
                  <div className="h-12 flex items-center">
                    <WalletMultiButton style={{ backgroundColor: '#7D1228' }} />
                  </div>
                  <button onClick={() => setShowHelp(true)} className="bg-[#80142C] hover:bg-[#4a0c1a] text-white w-12 h-12 rounded-xl transition-all duration-200 border border-[#80142C] flex items-center justify-center" title="Game Help & Guide">
                    <span className="text-lg font-bold">?</span>
                  </button>

                </div>
                <button
                  disabled={!connected || !currentUser || isLoadingAfterWalletConnect}
                  onClick={async () => {
                    if (connected && currentUser && !isLoadingAfterWalletConnect) {
                      // Start loading state
                      setIsLoadingAfterWalletConnect(true);
                      setLoadingProgress(0);
                      
                      try {
                        // Initial progress
                        setTimeout(() => setLoadingProgress(10), 100);
                        setTimeout(() => setLoadingProgress(25), 300);
                        
                        // Initialize sounds
                        setTimeout(() => setLoadingProgress(50), 500);
                        await soundEffects.initializeAfterUserInteraction();
                        
                        // Final progress
                        setLoadingProgress(80);
                        setTimeout(() => setLoadingProgress(100), 200);
                        
                        // Small delay to show completion
                        setTimeout(() => {
                          setIsLoadingAfterWalletConnect(false);
                          setGameState('menu');
                        }, 800);
                      } catch (error) {
                        setLoadingProgress(100);
                        setTimeout(() => {
                          setIsLoadingAfterWalletConnect(false);
                          setGameState('menu');
                        }, 500);
                      }
                    }
                  }}
                  className={`group relative px-12 py-4 rounded-2xl font-bold text-xl transform transition-all duration-300 overflow-hidden ${connected && currentUser && !isLoadingAfterWalletConnect ? 'hover:scale-105 cursor-pointer' : 'cursor-not-allowed opacity-50'}`}
                  style={{
                    background: connected && currentUser && !isLoadingAfterWalletConnect ? 'linear-gradient(135deg, #80142C 0%, #4a0c1a 100%)' : 'linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%)',
                    color: '#ffffff',
                    boxShadow: connected && currentUser && !isLoadingAfterWalletConnect ? '0 10px 30px rgba(128, 20, 44, 0.4), inset 0 1px 0 rgba(255,255,255,0.1)' : '0 10px 30px rgba(74, 74, 74, 0.2)'
                  }}
                  onMouseEnter={e => {
                    if (connected && currentUser && !isLoadingAfterWalletConnect) {
                      e.target.style.background = 'linear-gradient(135deg, #a01d39 0%, #661123 100%)';
                      e.target.style.boxShadow = '0 15px 40px rgba(128, 20, 44, 0.6), inset 0 1px 0 rgba(255,255,255,0.2)';
                    }
                  }}
                  onMouseLeave={e => {
                    if (connected && currentUser && !isLoadingAfterWalletConnect) {
                      e.target.style.background = 'linear-gradient(135deg, #80142C 0%, #4a0c1a 100%)';
                      e.target.style.boxShadow = '0 10px 30px rgba(128, 20, 44, 0.4), inset 0 1px 0 rgba(255,255,255,0.1)';
                    }
                  }}
                >
                  <span className="relative z-10 flex items-center justify-center">
                    {isLoadingAfterWalletConnect ? (
                      <>
                        <span>Loading... ({loadingProgress}%)</span>
                        <div className="ml-3 w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                      </>
                    ) : connected && currentUser ? (
                      <>
                        <span>Start Playing</span>
                        <ChevronRight className="ml-3 group-hover:translate-x-1 transition-transform duration-200" size={24} />
                      </>
                    ) : 'Connect Wallet to Play'}
                  </span>
                  
                  {/* Loading Progress Bar */}
                  {isLoadingAfterWalletConnect && (
                    <div className="absolute bottom-0 left-0 right-0 h-2 bg-white/20 rounded-b-2xl overflow-hidden">
                      <div 
                        className="h-full bg-gradient-to-r from-[#80142C] to-[#4a0c1a] transition-all duration-500 ease-out rounded-b-2xl"
                        style={{ width: `${loadingProgress}%` }}
                      ></div>
                    </div>
                  )}
                  
                  {connected && currentUser && !isLoadingAfterWalletConnect && <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700"></div>}
                </button>
                <p className="text-sm text-gray-400 italic max-w-md text-center">
                  Connect your wallet and start playing the classic African card game that brings families together.
                </p>
              </div>
            </div>
          </div>
        </div>
      );
    } else if (gameState === 'rooms') {
      return (
        <div className="h-full flex flex-col relative overflow-y-auto">
          <div className="flex-1 flex flex-col justify-start items-center px-4 py-8 min-h-0">
            <div className="w-full max-w-lg md:max-w-2xl lg:max-w-4xl relative">
              <button onClick={() => setGameState('menu')} className="absolute -top-2 left-0 text-white hover:text-gray-300 transition-all duration-300 flex items-center group">
                <ArrowLeft size={20} className="group-hover:-translate-x-1 transition-transform duration-200" />
              </button>
              <div className="text-center mb-12 mt-16">
                <h1 className="text-4xl md:text-6xl font-bold mb-4 text-white">
                  Online Multiplayer
                </h1>
                <div className="text-white text-lg tracking-wider">
                  Join or Create a Room
                </div>
              </div>
              
              <div className="mb-8">
                <button 
                  onClick={createRoom} 
                  disabled={!currentUser} 
                  className="group w-full p-6 bg-[#80142C] transition-all duration-200 hover:bg-[#4a0c1a] rounded-xl disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <div className="flex items-center justify-center">
                    <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg mr-4">
                      <Plus className="text-white" size={24} />
                    </div>
                    <div className="text-center">
                      <h2 className="text-2xl font-bold text-white mb-1">Create New Room</h2>
                      <p className="text-gray-200">Start your own game room</p>
                    </div>
                  </div>
                </button>
              </div>
              
              <div className="bg-black p-6 rounded-xl">
                <h3 className="text-2xl font-bold text-white mb-6 flex items-center">
                  <Users className="mr-3" size={24} />
                  Available Rooms ({rooms.length})
                </h3>
                {rooms.length === 0 ? (
                  <div className="text-center py-8 text-gray-400">
                    <Users size={48} className="mx-auto mb-4 opacity-50" />
                    <p className="text-lg">No rooms available</p>
                    <p className="text-sm">Create a new room to get started!</p>
                  </div>
                ) : (
                  <div className="space-y-4 max-h-96 overflow-y-auto">
                    {rooms.map(room => {
                      const playerCount = Object.keys(room.players || {}).length;
                      const canJoin = playerCount < room.maxPlayers && room.status === 'waiting';
                      return (
                        <div key={room.id} className="bg-gray-800 p-4 rounded-xl flex items-center justify-between">
                          <div className="flex items-center">
                            <div className="w-12 h-12 bg-[#80142C] flex items-center justify-center rounded-lg mr-4">
                              <Crown className="text-white" size={20} />
                            </div>
                            <div>
                              <h4 className="text-white font-bold">{room.ownerUsername}'s Room</h4>
                              <p className="text-gray-300 text-sm">
                                {playerCount}/{room.maxPlayers} players
                                {room.status === 'countdown' && ` • Starting in ${room.countdown}s`}
                              </p>
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            {room.status === 'countdown' && (
                              <div className="flex items-center text-yellow-400 mr-2">
                                <Clock size={16} className="mr-1" />
                                <span className="text-sm font-bold">{room.countdown}s</span>
                              </div>
                            )}
                            <button 
                              onClick={() => joinRoom(room.id)} 
                              disabled={!canJoin || !currentUser} 
                              className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                              {canJoin ? 'Join' : room.status === 'countdown' ? 'Starting' : 'Full'}
                            </button>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
              
              {!currentUser && (
                <div className="mt-6 p-4 bg-yellow-900 bg-opacity-50 rounded-xl border border-yellow-600">
                  <p className="text-yellow-200 text-center">
                    Connect your wallet to join or create rooms
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    } else if (gameState === 'room' && currentRoom) {
      return (
        <div className="h-full flex flex-col relative overflow-y-auto">
          <div className="flex-1 flex flex-col justify-start items-center px-4 py-8 min-h-0">
            <div className="w-full max-w-lg md:max-w-2xl lg:max-w-4xl relative">
              <button onClick={leaveRoom} className="absolute -top-2 left-0 text-white hover:text-gray-300 transition-all duration-300 flex items-center group">
                <ArrowLeft size={20} className="group-hover:-translate-x-1 transition-transform duration-200" />
              </button>
              <div className="text-center mb-12 mt-16">
                <h1 className="text-4xl md:text-6xl font-bold mb-4 text-white">
                  {currentRoom.ownerUsername}'s Room
                </h1>
                <div className="text-white text-lg tracking-wider">
                  {currentRoom.status === 'waiting' && 'Waiting for Players'}
                  {currentRoom.status === 'countdown' && `Starting in ${gameCountdown}s`}
                  {currentRoom.status === 'playing' && 'Game in Progress'}
                </div>
              </div>
              
              {currentRoom.status === 'countdown' && gameCountdown && (
                <div className="mb-8 text-center">
                  <div className="text-6xl font-bold text-[#80142C] mb-4">{gameCountdown}</div>
                  <p className="text-xl text-white">Game starting...</p>
                </div>
              )}
              
              <div className="bg-black p-6 rounded-xl mb-6">
                <h3 className="text-2xl font-bold text-white mb-6 flex items-center">
                  <Users className="mr-3" size={24} />
                  Players ({Object.keys(currentRoom.players || {}).length}/4)
                </h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {Object.values(currentRoom.players || {}).map(player => (
                    <div key={player.id} className="bg-gray-800 p-4 rounded-xl flex items-center justify-between">
                      <div className="flex items-center">
                        <div className={`w-10 h-10 flex items-center justify-center rounded-lg mr-3 ${player.id === currentRoom.ownerId ? 'bg-yellow-600' : 'bg-gray-600'}`}>
                          {player.id === currentRoom.ownerId ? (
                            <Crown size={20} className="text-white" />
                          ) : (
                            <Users size={20} className="text-white" />
                          )}
                        </div>
                        <div>
                          <h4 className="text-white font-bold">{player.username}</h4>
                          <p className="text-gray-300 text-sm">
                            {player.id === currentRoom.ownerId ? 'Room Owner' : 'Player'}
                          </p>
                        </div>
                      </div>
                      <div className="flex items-center">
                        {player.id !== currentRoom.ownerId && (
                          <div className={`px-3 py-1 rounded-lg text-sm font-bold ${player.ready ? 'bg-green-600 text-white' : 'bg-gray-600 text-gray-300'}`}>
                            {player.ready ? 'Ready' : 'Not Ready'}
                          </div>
                        )}
                      </div>
                    </div>
                  ))}
                  
                  {Array.from({ length: 4 - Object.keys(currentRoom.players || {}).length }, (_, index) => (
                    <div key={`empty-${index}`} className="bg-gray-900 p-4 rounded-xl border-2 border-dashed border-gray-600 flex items-center justify-center">
                      <div className="text-gray-500 text-center">
                        <Users size={24} className="mx-auto mb-2 opacity-50" />
                        <p className="text-sm">Waiting for player...</p>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
              
              <div className="flex gap-4 justify-center">
                {currentUser?.id === currentRoom.ownerId ? (
                  <button 
                    onClick={startGameCountdown} 
                    disabled={Object.keys(currentRoom.players || {}).length < 2 || currentRoom.status !== 'waiting'} 
                    className="px-8 py-3 bg-green-600 text-white rounded-xl font-bold hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Start Game
                  </button>
                ) : (
                  <button 
                    onClick={toggleReady} 
                    disabled={currentRoom.status !== 'waiting'} 
                    className={`px-8 py-3 rounded-xl font-bold transition-colors ${currentRoom.players[currentUser?.id]?.ready ? 'bg-gray-600 text-white hover:bg-gray-700' : 'bg-green-600 text-white hover:bg-green-700'} disabled:opacity-50 disabled:cursor-not-allowed`}
                  >
                    {currentRoom.players[currentUser?.id]?.ready ? 'Not Ready' : 'Ready Up'}
                  </button>
                )}
                <button 
                  onClick={leaveRoom} 
                  className="px-8 py-3 bg-[#80142C] text-white rounded-xl font-bold hover:bg-[#4a0c1a] transition-colors"
                >
                  Leave Room
                </button>
              </div>
              
              <div className="mt-6 text-center text-gray-400">
                {currentUser?.id === currentRoom.ownerId && Object.keys(currentRoom.players || {}).length < 2 && (
                  <p>Need at least 2 players to start the game</p>
                )}
                {currentUser?.id !== currentRoom.ownerId && !currentRoom.players[currentUser?.id]?.ready && (
                  <p>Click "Ready Up" when you're ready to play</p>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    } else if (gameState === 'menu') {
        return (
        <div className="h-full flex flex-col relative overflow-y-auto">
          <div className="flex-1 flex flex-col justify-start items-center px-4 py-8 min-h-0">
            <div className="w-full max-w-lg md:max-w-2xl lg:max-w-4xl relative">
              <button onClick={() => setGameState('landing')} className="absolute -top-2 left-0 text-white hover:text-gray-300 transition-all duration-300 flex items-center group">
                <ArrowLeft size={20} className="group-hover:-translate-x-1 transition-transform duration-200" />
              </button>
              <div className="text-center mb-12 mt-16">
                <h1 className="text-4xl md:text-6xl font-bold mb-4 text-white">
                  Main Menu
                </h1>
                <div className="text-white text-lg tracking-wider">
                  Select an Option
                </div>
              </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                  <button 
                    onClick={() => setActivePopup('battle')} 
                    disabled={!connected}
                    className={`group w-full p-8 transition-all duration-200 rounded-xl ${connected ? 'bg-[#80142C] hover:bg-[#4a0c1a]' : 'bg-gray-600 cursor-not-allowed'}`}
                  >
                    <div className="flex items-center">
                      <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                        <Play className="text-white" size={24} />
                      </div>
                      <div className="ml-6 text-left">
                        <h2 className="text-2xl font-bold text-white mb-1">Play Game</h2>
                        <p className="text-gray-200">Start a new Whot game</p>
                      </div>
                      <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                    </div>
                  </button>
                  <button 
                    onClick={() => setActivePopup('profile')} 
                    disabled={!connected}
                    className={`group w-full p-8 transition-all duration-200 rounded-xl ${connected ? 'bg-[#80142C] hover:bg-[#4a0c1a]' : 'bg-gray-600 cursor-not-allowed'}`}
                  >
                    <div className="flex items-center">
                      <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                        <Shield className="text-white" size={24} />
                      </div>
                      <div className="ml-6 text-left">
                        <h2 className="text-2xl font-bold text-white mb-1">Profile</h2>
                        <p className="text-gray-200">View your player profile</p>
                      </div>
                      <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                    </div>
                  </button>
                  <button 
                    onClick={() => setActivePopup('achievements')} 
                    disabled={!connected}
                    className={`group w-full p-8 transition-all duration-200 rounded-xl ${connected ? 'bg-[#80142C] hover:bg-[#4a0c1a]' : 'bg-gray-600 cursor-not-allowed'}`}
                  >
                    <div className="flex items-center">
                      <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                        <Award className="text-white" size={24} />
                      </div>
                      <div className="ml-6 text-left">
                        <h2 className="text-2xl font-bold text-white mb-1">Achievements</h2>
                        <p className="text-gray-200">Track your progress</p>
                      </div>
                      <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                    </div>
                  </button>
                  <button 
                    onClick={() => setActivePopup('config')} 
                    className="group w-full p-8 bg-[#80142C] transition-all duration-200 hover:bg-[#4a0c1a] rounded-xl"
                  >
                    <div className="flex items-center">
                      <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                        <Settings className="text-white" size={24} />
                      </div>
                      <div className="ml-6 text-left">
                        <h2 className="text-2xl font-bold text-white mb-1">Settings</h2>
                        <p className="text-gray-200">Adjust game preferences</p>
                      </div>
                      <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                    </div>
                  </button>
                </div>
                <div className="text-center">
                  <p className="text-gray-400 italic">
                    Choose an option above to get started with Whot Go!
                  </p>
                </div>
              </div>
            </div>
          </div>
          {activePopup && (
            <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4" onClick={() => setActivePopup(null)}>
              <div className="relative w-full max-w-4xl max-h-[90vh] overflow-y-auto rounded-xl" onClick={e => e.stopPropagation()}>
                {activePopup === 'battle' && <GameModePopup 
                  onClose={() => setActivePopup(null)}
                  onSelectMultiplayer={() => {
                    setActivePopup(null);
                    setGameState('rooms');
                  }}
                  onSelectAI={() => {
                    setActivePopup(null);
                    setGameState('game');
                  }}
                />}
                {activePopup === 'profile' && <ProfilePopup 
                  userProfile={currentUser} 
                  updateUsername={updateUsername} 
                  closePopup={() => setActivePopup(null)}
                  onShowLeaderboard={() => setActivePopup('leaderboards')}
                />}
                {activePopup === 'achievements' && <AchievementPopup 
                  userProfile={currentUser} 
                  claimAchievement={claimAchievement} 
                  closePopup={() => setActivePopup(null)} 
                />}
                {activePopup === 'leaderboards' && <LeaderboardPopup 
                  leaderboardData={leaderboardData} 
                  closePopup={() => setActivePopup(null)}
                  onBackToProfile={() => setActivePopup('profile')}
                />}
                {activePopup === 'config' && <SettingsPopup 
                  musicVolume={musicVolume}
                  soundVolume={soundVolume}
                  setMusicVolume={setMusicVolume}
                  setSoundVolume={setSoundVolume}
                  closePopup={() => setActivePopup(null)} 
                />}
              </div>
            </div>
          )}
        </div>
      );
    } else if (gameState === 'game') {
      // Check if we have valid game data
      if (gameData && Array.isArray(gameData.players) && gameData.players.length > 0 && gameData.players.every(p => Array.isArray(p.cards))) {
        return <Game gameData={gameData} currentUser={currentUser} isAdmin={isAdmin} adminCardsRevealed={adminCardsRevealed} adminMarketRevealed={adminMarketRevealed} setAdminCardsRevealed={setAdminCardsRevealed} setAdminMarketRevealed={setAdminMarketRevealed} showAdminDeckOverview={showAdminDeckOverview} setShowAdminDeckOverview={setShowAdminDeckOverview} playCard={playCard} playMultiplayerCard={playMultiplayerCard} drawCard={drawCard} drawMultiplayerCard={drawMultiplayerCard} showDeckView={showDeckView} setShowDeckView={setShowDeckView} showGameLog={showGameLog} setShowGameLog={setShowGameLog} currentRoom={currentRoom} turnTimer={turnTimer} animatingCards={animatingCards} setAnimatingCards={setAnimatingCards} playerScrollIndex={playerScrollIndex} setPlayerScrollIndex={setPlayerScrollIndex} maxVisiblePlayerCards={maxVisiblePlayerCards} playPileCardPositions={playPileCardPositions} marketCardPositions={marketCardPositions} animationPositions={animationPositions} isPlayerActionInProgress={isPlayerActionInProgress} isAnyAnimationInProgress={isAnyAnimationInProgress} setPlayPileCardPositions={setPlayPileCardPositions} setMarketCardPositions={setMarketCardPositions} setIsPlayerActionInProgress={setIsPlayerActionInProgress} setIsAnyAnimationInProgress={setIsAnyAnimationInProgress} returnToMenu={returnToMenu} setGameData={setGameData} startDealingAnimation={startDealingAnimation} handleMultiplayerRoundEnd={handleMultiplayerRoundEnd} handleRoundEnd={handleRoundEnd} />;
      } else {
        // Show loading state while game data is being set up
        return (
          <div className="h-full flex items-center justify-center text-white">
            <div className="text-center">
              <div className="text-xl mb-2">Starting game...</div>
              <div className="text-sm text-gray-400">Please wait</div>
            </div>
          </div>
        );
      }
    } else {
      // Safe fallback to avoid blank screen if state is inconsistent
      return (
        <div className="h-full flex items-center justify-center text-white">
          <div className="text-center">
            <div className="text-xl mb-2">Loading...</div>
            <div className="text-sm text-gray-400">Please wait</div>
          </div>
        </div>
      );
    }
  };

  return (
    <div className="fixed inset-0 overflow-hidden">
      {renderContent()}
      {showGameLog && gameData && <GameLogPopup gameData={gameData} selectedLogRound={selectedLogRound} setSelectedLogRound={setSelectedLogRound} closePopup={() => setShowGameLog(false)} />}
      {showRoundEndPopup && roundEndData && <RoundEndPopup 
        roundEndData={roundEndData} 
        onContinue={currentRoom ? handleMultiplayerContinueToNextRound : handleContinueToNextRound}
        isMultiplayer={!!currentRoom}
        readyPlayers={readyPlayers}
        currentUser={currentUser}
        remainingPlayers={gameData?.players?.filter(p => !p.eliminated) || []}
      />}
      {showEliminatedPopup && <EliminatedPopup setShowEliminatedPopup={setShowEliminatedPopup} returnToMenu={returnToMenu} />}
      {showWhotChoice && <WhotShapePopup selectShape={chooseWhotShape} closePopup={() => setShowWhotChoice(false)} />}
      {showHelp && <HelpPopup closePopup={() => setShowHelp(false)} />}
      {confettiActive && <canvas ref={confettiCanvasRef} className="fixed inset-0 pointer-events-none z-[110]" style={{ width: '100vw', height: '100vh' }} />}
    </div>
  );
};

export default App;