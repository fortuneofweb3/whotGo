import { useState, useEffect, useRef } from 'react';
import { ChevronRight, Play, Settings, Award, Shield, ArrowLeft, Wifi, Bot, ChevronLeft, ChevronRight as ChevronRightIcon, Grid3X3, Users, Plus, Clock, Crown } from 'lucide-react';
import { useDevapp, UserButton, DevappProvider } from '@devfunlabs/web-sdk';
import { initializeApp } from 'firebase/app';
import { getDatabase, ref, push, set, onValue, off, update, remove, serverTimestamp, onDisconnect } from 'firebase/database';
const firebaseConfig = {
  apiKey: "AIzaSyCdEsxnNGXVb0UOY1gdTElzJTtxZag-Q2w",
  authDomain: "xashmarkets-1.firebaseapp.com",
  databaseURL: "https://xashmarkets-1-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "xashmarkets-1",
  storageBucket: "xashmarkets-1.firebasestorage.app",
  messagingSenderId: "166775884916",
  appId: "1:166775884916:web:20453106dfe337739e5521",
  measurementId: "G-VRMQS3FBV1"
};
const app = initializeApp(firebaseConfig);
const database = getDatabase(app);
export default function AppWithProvider() {
  return <DevappProvider rpcEndpoint="https://rpc.dev.fun/1dd217667e21a49fcd4a" devbaseEndpoint="https://devbase.dev.fun" appId="1dd217667e21a49fcd4a">
      <App />
    </DevappProvider>;
}
function App() {
  const MAX_VISIBLE_AI_CARDS = 3;
  const [currentCard, setCurrentCard] = useState(0);
  const [isVisible, setIsVisible] = useState(false);
  const [gameState, setGameState] = useState('landing');
  const [currentUser, setCurrentUser] = useState(null);
  const [rooms, setRooms] = useState([]);
  const [currentRoom, setCurrentRoom] = useState(null);
  const [gameCountdown, setGameCountdown] = useState(null);
  const [turnTimer, setTurnTimer] = useState(null);
  const [gameData, setGameData] = useState(null);
  const [showWhotChoice, setShowWhotChoice] = useState(false);
  const [activePopup, setActivePopup] = useState(null);
  const [pendingWhotCard, setPendingWhotCard] = useState(null);
  const [animatingCards, setAnimatingCards] = useState([]);
  const [marketCardPositions, setMarketCardPositions] = useState([]);
  const [needNewMarketPositions, setNeedNewMarketPositions] = useState(false);
  const [, setPlayPilePositions] = useState([]);
  const [playerScrollIndex, setPlayerScrollIndex] = useState(0);
  const [maxVisiblePlayerCards, setMaxVisiblePlayerCards] = useState(6);
  const [showDeckView, setShowDeckView] = useState(false);
  const [isPlayerActionInProgress, setIsPlayerActionInProgress] = useState(false);
  const [, setIsAITurnInProgress] = useState(false);
  const [isAnyAnimationInProgress, setIsAnyAnimationInProgress] = useState(false);
  const [showEliminatedPopup, setShowEliminatedPopup] = useState(false);
  const [showRoundEndPopup, setShowRoundEndPopup] = useState(false);
  const [roundEndData, setRoundEndData] = useState(null);
  const [showGameLog, setShowGameLog] = useState(false);
  const [selectedLogRound, setSelectedLogRound] = useState(1);
  const [animationPositions, setAnimationPositions] = useState({});
  const [playPileCardPositions, setPlayPileCardPositions] = useState({});
  const [confettiActive, setConfettiActive] = useState(false);
  const confettiCanvasRef = useRef(null);
  const [adminCardsRevealed, setAdminCardsRevealed] = useState(false);
  const [adminMarketRevealed, setAdminMarketRevealed] = useState(false);
  const [showAdminDeckOverview, setShowAdminDeckOverview] = useState(false);
  const [leaderboardData, setLeaderboardData] = useState([]);
  const [achievements, setAchievements] = useState([]);
  const [musicVolume, setMusicVolume] = useState(75);
  const [soundVolume, setSoundVolume] = useState(85);
  const [showHelp, setShowHelp] = useState(false);
  const [isEditingUsername, setIsEditingUsername] = useState(false);
  const [newUsername, setNewUsername] = useState('');
  const marketCardPositionsRef = useRef([]);
  const playPilePositionsRef = useRef([]);
  const {
    userWallet
  } = useDevapp();
  const ADMIN_WALLET = 'DtdnqvRddQspZvRV5SJX2DeqxmLYef7Hqn9LFK9LioJS';
  const isAdmin = userWallet === ADMIN_WALLET;
  useEffect(() => {
    let unsubscribe;
    if (userWallet) {
      unsubscribe = initializeUser(userWallet);
      fetchLeaderboard();
    } else {
      setCurrentUser(null);
      setLeaderboardData([]);
      setAchievements([]);
    }
    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, [userWallet]);
  useEffect(() => {
    if (currentUser) {
      initializeAchievements(currentUser);
      fetchLeaderboard();
    }
  }, [currentUser]);
  const initializeUser = async walletAddress => {
    try {
      const userRef = ref(database, `users/${walletAddress}`);
      const unsubscribe = onValue(userRef, async snapshot => {
        if (snapshot.exists()) {
          const userData = {
            id: walletAddress,
            ...snapshot.val()
          };
          setCurrentUser(userData);
          await update(userRef, {
            lastActive: serverTimestamp()
          });
        } else {
          const newUserData = {
            id: walletAddress,
            username: `Player${Math.floor(Math.random() * 10000)}`,
            xp: 0,
            level: 1,
            gamesPlayed: 0,
            gamesWon: 0,
            createdAt: serverTimestamp(),
            lastActive: serverTimestamp()
          };
          setCurrentUser(newUserData);
          await set(userRef, newUserData);
        }
        onDisconnect(userRef).update({
          lastActive: serverTimestamp()
        });
      });
      return unsubscribe;
    } catch (error) {
      console.error('Error initializing user:', error);
      setCurrentUser({
        id: walletAddress,
        username: `Player${Math.floor(Math.random() * 10000)}`,
        xp: 0,
        level: 1,
        gamesPlayed: 0,
        gamesWon: 0
      });
    }
  };
  useEffect(() => {
    const roomsRef = ref(database, 'rooms');
    const unsubscribe = onValue(roomsRef, snapshot => {
      if (snapshot.exists()) {
        const roomsData = snapshot.val();
        const roomsList = Object.keys(roomsData).map(roomId => ({
          id: roomId,
          ...roomsData[roomId]
        })).filter(room => room.status === 'waiting' || room.status === 'countdown');
        setRooms(roomsList);
      } else {
        setRooms([]);
      }
    });
    return () => off(roomsRef, 'value', unsubscribe);
  }, []);
  useEffect(() => {
    if (currentRoom) {
      const roomRef = ref(database, `rooms/${currentRoom.id}`);
      const unsubscribe = onValue(roomRef, snapshot => {
        if (snapshot.exists()) {
          const roomData = {
            id: currentRoom.id,
            ...snapshot.val()
          };
          setCurrentRoom(roomData);
          if (roomData.status === 'countdown' && roomData.countdown !== undefined) {
            if (currentUser?.id !== currentRoom?.ownerId || gameCountdown === null) {
              setGameCountdown(roomData.countdown);
            }
          } else {
            setGameCountdown(null);
          }
          if (roomData.status === 'playing' && roomData.gameData) {
            const newGameData = roomData.gameData;
            if (gameData && gameData.playPile && newGameData.playPile.length > gameData.playPile.length) {
              const lastCard = newGameData.playPile[newGameData.playPile.length - 1];
              const playerWhoPlayed = gameData.players.findIndex(p => p.cards.length > newGameData.players.find(np => np.id === p.id)?.cards.length);
              if (playerWhoPlayed !== -1 && playerWhoPlayed !== gameData.players.findIndex(p => p.id === currentUser?.id)) {
                const mapping = getVisualPlayerMapping();
                const visualPlayerIndex = mapping.actualToVisual[playerWhoPlayed] !== undefined ? mapping.actualToVisual[playerWhoPlayed] : playerWhoPlayed;
                const newCardRelativeStyle = getPlayPilePosition(newGameData.playPile.length - 1, false);
                const endPosition = {
                  ...animationPositions.playPile,
                  transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
                  zIndex: newCardRelativeStyle.zIndex
                };
                const animatingCard = {
                  ...lastCard,
                  id: `opponent-play-${Date.now()}`,
                  startPos: animationPositions.animationStarts?.[visualPlayerIndex] || {
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)'
                  },
                  endPos: endPosition,
                  isPlayerCard: true
                };
                setAnimatingCards(prev => [...prev, animatingCard]);
                setTimeout(() => {
                  setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
                  getPlayPilePosition(newGameData.playPile.length - 1, true);
                }, 800);
              }
            }
            if (gameData && gameData.players) {
              newGameData.players.forEach((newPlayer, playerIndex) => {
                const oldPlayer = gameData.players.find(p => p.id === newPlayer.id);
                if (oldPlayer && newPlayer.cards.length > oldPlayer.cards.length && playerIndex !== gameData.players.findIndex(p => p.id === currentUser?.id)) {
                  const cardsDifference = newPlayer.cards.length - oldPlayer.cards.length;
                  const mapping = getVisualPlayerMapping();
                  const visualPlayerIndex = mapping.actualToVisual[playerIndex] !== undefined ? mapping.actualToVisual[playerIndex] : playerIndex;
                  for (let i = 0; i < cardsDifference; i++) {
                    const animatingCard = {
                      id: `opponent-draw-${Date.now()}-${i}`,
                      startPos: getTopMarketCardPosition(),
                      endPos: {
                        ...animationPositions.drawEnds[visualPlayerIndex],
                        opacity: 0
                      },
                      isPlayerCard: false
                    };
                    setTimeout(() => {
                      setAnimatingCards(prev => [...prev, animatingCard]);
                      setTimeout(() => {
                        setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
                      }, 800);
                    }, i * 100);
                  }
                }
              });
            }
            setGameData(newGameData);
            setGameState('game');
          }
        } else {
          setCurrentRoom(null);
          setGameState('menu');
        }
      });
      return () => off(roomRef, 'value', unsubscribe);
    }
  }, [currentRoom?.id, gameData, currentUser, animationPositions]);
  useEffect(() => {
    if (gameCountdown > 0 && currentRoom && currentUser?.id === currentRoom.ownerId) {
      const timer = setTimeout(() => {
        const newCountdown = gameCountdown - 1;
        setGameCountdown(newCountdown);
        update(ref(database, `rooms/${currentRoom.id}`), {
          countdown: newCountdown
        });
        if (newCountdown === 0) {
          startMultiplayerGame();
        }
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [gameCountdown]);
  useEffect(() => {
    if (gameData && gameState === 'game' && currentRoom && turnTimer > 0) {
      const timer = setTimeout(() => {
        const newTimer = turnTimer - 1;
        setTurnTimer(newTimer);
        if (newTimer === 0) {
          const currentUserActualIndex = gameData.players.findIndex(p => p.id === currentUser?.id);
          if (currentUserActualIndex !== -1 && gameData.currentPlayer === currentUserActualIndex) {
            handleAutoPlay();
          }
        }
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [turnTimer, gameData, gameState, currentRoom, currentUser]);
  useEffect(() => {
    if (gameData && gameState === 'game' && currentRoom && gameData.gamePhase === 'playing') {
      setTurnTimer(30);
    }
  }, [gameData?.currentPlayer, gameState, currentRoom, gameData?.gamePhase]);
  const createRoom = async () => {
    if (!currentUser) return;
    try {
      const roomRef = push(ref(database, 'rooms'));
      const roomData = {
        ownerId: currentUser.id,
        ownerUsername: currentUser.username,
        status: 'waiting',
        players: {
          [currentUser.id]: {
            id: currentUser.id,
            username: currentUser.username,
            ready: true,
            joinedAt: serverTimestamp()
          }
        },
        maxPlayers: 4,
        createdAt: serverTimestamp()
      };
      await set(roomRef, roomData);
      setCurrentRoom({
        id: roomRef.key,
        ...roomData
      });
      setGameState('room');
    } catch (error) {
      console.error('Error creating room:', error);
    }
  };
  const joinRoom = async roomId => {
    if (!currentUser) return;
    try {
      const roomRef = ref(database, `rooms/${roomId}`);
      const playerRef = ref(database, `rooms/${roomId}/players/${currentUser.id}`);
      await set(playerRef, {
        id: currentUser.id,
        username: currentUser.username,
        ready: false,
        joinedAt: serverTimestamp()
      });
      onValue(roomRef, snapshot => {
        if (snapshot.exists()) {
          setCurrentRoom({
            id: roomId,
            ...snapshot.val()
          });
          setGameState('room');
        }
      }, {
        onlyOnce: true
      });
    } catch (error) {
      console.error('Error joining room:', error);
    }
  };
  const leaveRoom = async () => {
    if (!currentRoom || !currentUser) return;
    try {
      if (currentUser.id === currentRoom.ownerId) {
        await remove(ref(database, `rooms/${currentRoom.id}`));
      } else {
        await remove(ref(database, `rooms/${currentRoom.id}/players/${currentUser.id}`));
      }
      setCurrentRoom(null);
      setGameState('menu');
    } catch (error) {
      console.error('Error leaving room:', error);
    }
  };
  const toggleReady = async () => {
    if (!currentRoom || !currentUser || currentUser.id === currentRoom.ownerId) return;
    try {
      const currentReady = currentRoom.players[currentUser.id]?.ready || false;
      await update(ref(database, `rooms/${currentRoom.id}/players/${currentUser.id}`), {
        ready: !currentReady
      });
    } catch (error) {
      console.error('Error toggling ready:', error);
    }
  };
  const startGameCountdown = async () => {
    if (!currentRoom || !currentUser || currentUser.id !== currentRoom.ownerId) return;
    const playersList = Object.values(currentRoom.players || {});
    if (playersList.length < 2) return;
    try {
      await update(ref(database, `rooms/${currentRoom.id}`), {
        status: 'countdown',
        countdown: 30
      });
    } catch (error) {
      console.error('Error starting countdown:', error);
    }
  };
  const startMultiplayerGame = async () => {
    if (!currentRoom || !currentUser || currentUser.id !== currentRoom.ownerId) return;
    try {
      const deck = createDeck();
      const shuffledDeck = shuffleDeck(deck);
      const playersList = Object.values(currentRoom.players || {});
      const cardsPerPlayer = getCardsPerPlayer(playersList.length);
      const players = playersList.map((player, index) => ({
        id: player.id,
        name: player.username,
        cards: shuffledDeck.slice(index * cardsPerPlayer, (index + 1) * cardsPerPlayer),
        isAI: false,
        eliminated: false
      }));
      const remainingDeck = shuffledDeck.slice(playersList.length * cardsPerPlayer);
      const playCard = remainingDeck[0];
      const initialGameData = {
        players,
        playPile: [playCard],
        drawPile: remainingDeck.slice(1),
        currentPlayer: 0,
        gamePhase: 'playing',
        roundNumber: 1,
        lastAction: `Game started - ${playCard.number}${playCard.shape} played`,
        pendingPickCount: 0,
        generalMarketActive: false,
        generalMarketOriginatorId: null,
        gameLog: {
          1: [`Game started with ${players.length} players: ${players.map(p => p.name).join(', ')}`, `Initial card: ${playCard.number}${playCard.shape} placed on table`]
        }
      };
      await update(ref(database, `rooms/${currentRoom.id}`), {
        status: 'playing',
        gameData: initialGameData,
        countdown: null
      });
    } catch (error) {
      console.error('Error starting multiplayer game:', error);
    }
  };
  const handleAutoPlay = async () => {
    if (!gameData || !currentRoom || !currentUser) return;
    const currentUserActualIndex = gameData.players.findIndex(p => p.id === currentUser.id);
    if (currentUserActualIndex === -1) return;
    if (gameData.currentPlayer !== currentUserActualIndex) return;
    const currentPlayerData = gameData.players[currentUserActualIndex];
    try {
      const topCard = gameData.playPile[gameData.playPile.length - 1];
      const playableCards = currentPlayerData.cards.filter(card => canPlayCard(card, topCard));
      if (playableCards.length > 0) {
        const cardToPlay = playableCards[0];
        const cardIndex = currentPlayerData.cards.findIndex(c => c.id === cardToPlay.id);
        await playMultiplayerCard(cardIndex);
      } else {
        await drawMultiplayerCard();
      }
    } catch (error) {
      console.error('Error with auto-play:', error);
    }
  };
  const playMultiplayerCard = async cardIndex => {
    if (!gameData || !currentRoom || !currentUser || isPlayerActionInProgress) return;
    const currentUserActualIndex = gameData.players.findIndex(p => p.id === currentUser.id);
    if (currentUserActualIndex === -1) return;
    if (gameData.currentPlayer !== currentUserActualIndex) return;
    const currentPlayerData = gameData.players[currentUserActualIndex];
    const actualCardIndex = cardIndex + playerScrollIndex;
    const card = currentPlayerData.cards[actualCardIndex];
    const topCard = gameData.playPile[gameData.playPile.length - 1];
    if (topCard.chosenShape) {
      if (card.special !== 'whot' && card.shape !== topCard.chosenShape) return;
    } else if (!canPlayCard(card, topCard)) {
      return;
    }
    try {
      setIsPlayerActionInProgress(true);
      setIsAnyAnimationInProgress(true);
      const newCardRelativeStyle = getPlayPilePosition(gameData.playPile.length, false);
      const endPosition = {
        ...animationPositions.playPile,
        transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
        zIndex: newCardRelativeStyle.zIndex
      };
      const animatingCard = {
        ...card,
        id: `animating-${Date.now()}-${actualCardIndex}`,
        startPos: getExactCardPosition(currentUserActualIndex, actualCardIndex, currentPlayerData.cards.length, true),
        endPos: endPosition,
        isPlayerCard: true
      };
      setAnimatingCards(prev => [...prev, animatingCard]);
      await new Promise(resolve => setTimeout(resolve, 800));
      setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
      getPlayPilePosition(gameData.playPile.length, true);
      const newGameData = {
        ...gameData
      };
      const newPlayers = [...newGameData.players];
      const currentPlayer = {
        ...newPlayers[currentUserActualIndex]
      };
      currentPlayer.cards = currentPlayer.cards.filter((_, idx) => idx !== actualCardIndex);
      newPlayers[currentUserActualIndex] = currentPlayer;
      newGameData.players = newPlayers;
      newGameData.playPile = [...newGameData.playPile, card];
      const newCardsLength = currentPlayer.cards.length;
      const maxScroll = Math.max(0, newCardsLength - maxVisiblePlayerCards);
      if (newCardsLength <= maxVisiblePlayerCards) {
        setPlayerScrollIndex(0);
      } else if (playerScrollIndex >= maxScroll) {
        setPlayerScrollIndex(maxScroll);
      } else if (actualCardIndex < playerScrollIndex + Math.floor(maxVisiblePlayerCards / 2)) {
        setPlayerScrollIndex(Math.max(0, playerScrollIndex - 1));
      }
      if (card.special === 'pick2') {
        newGameData.pendingPickCount += 2;
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape} pick2`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape} (Pick 2) - Next player must draw 2 cards`]
        };
      } else if (card.special === 'whot') {
        setPendingWhotCard(card);
        setShowWhotChoice(true);
        setGameData(newGameData);
        setIsPlayerActionInProgress(false);
        return;
      } else if (card.special === 'holdon') {
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape} hold`;
        newGameData.skipNextPlayer = true;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape} (Hold On) - Next player's turn skipped`]
        };
      } else if (card.special === 'generalmarket') {
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape} gen`;
        newGameData.generalMarketActive = true;
        newGameData.generalMarketOriginatorId = currentUserActualIndex;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape} (General Market) - All other players must draw from market`]
        };
      } else {
        newGameData.lastAction = `${currentPlayer.name} - ${card.number}${card.shape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${card.number}${card.shape}`]
        };
      }
      if (currentPlayer.cards.length === 0) {
        await handleMultiplayerRoundEnd(newGameData);
      } else {
        const nextPlayerIndex = getNextPlayer(newGameData);
        newGameData.currentPlayer = nextPlayerIndex;
        newGameData.skipNextPlayer = false;
        if (newGameData.generalMarketActive && nextPlayerIndex === newGameData.generalMarketOriginatorId) {
          newGameData.generalMarketActive = false;
          newGameData.generalMarketOriginatorId = null;
          newGameData.lastAction += ' General Market effect ends.';
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), 'General Market effect ended - all players have drawn']
          };
        }
        await update(ref(database, `rooms/${currentRoom.id}/gameData`), newGameData);
      }
      setIsPlayerActionInProgress(false);
      setIsAnyAnimationInProgress(false);
    } catch (error) {
      console.error('Error playing multiplayer card:', error);
      setIsPlayerActionInProgress(false);
    }
  };
  const drawMultiplayerCard = async () => {
    if (!gameData || !currentRoom || !currentUser || isPlayerActionInProgress) return;
    const currentUserActualIndex = gameData.players.findIndex(p => p.id === currentUser.id);
    if (currentUserActualIndex === -1) return;
    if (gameData.currentPlayer !== currentUserActualIndex) return;
    try {
      setIsPlayerActionInProgress(true);
      setIsAnyAnimationInProgress(true);
      const newGameData = {
        ...gameData
      };
      const count = newGameData.pendingPickCount > 0 ? newGameData.pendingPickCount : 1;
      const currentPlayer = {
        ...newGameData.players[currentUserActualIndex]
      };
      for (let i = 0; i < count; i++) {
        if (newGameData.drawPile.length <= 1) {
          reshuffleMarket(newGameData);
        }
        if (newGameData.drawPile.length === 0) break;
        const drawnCard = newGameData.drawPile[newGameData.drawPile.length - 1];
        newGameData.drawPile = newGameData.drawPile.slice(0, -1);
        currentPlayer.cards = [...currentPlayer.cards, drawnCard];
        const mapping = getVisualPlayerMapping();
        const visualPlayerIndex = mapping.actualToVisual[currentUserActualIndex] !== undefined ? mapping.actualToVisual[currentUserActualIndex] : currentUserActualIndex;
        const animatingCard = {
          ...drawnCard,
          id: `draw-${Date.now()}-${i}`,
          startPos: getTopMarketCardPosition(),
          endPos: {
            ...animationPositions.drawEnds[visualPlayerIndex],
            opacity: 0
          },
          isPlayerCard: false
        };
        setAnimatingCards(prev => [...prev, animatingCard]);
        await new Promise(resolve => {
          setTimeout(() => {
            setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
            resolve();
          }, 800);
        });
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      const newPlayers = [...newGameData.players];
      newPlayers[currentUserActualIndex] = currentPlayer;
      newGameData.players = newPlayers;
      newGameData.pendingPickCount = 0;
      newGameData.lastAction = `${currentPlayer.name} - drew ${count} card${count > 1 ? 's' : ''}`;
      const newTotal = currentPlayer.cards.length;
      if (newTotal > maxVisiblePlayerCards) {
        setPlayerScrollIndex(newTotal - maxVisiblePlayerCards);
      }
      const nextPlayerIndex = getNextPlayer(newGameData);
      newGameData.currentPlayer = nextPlayerIndex;
      await update(ref(database, `rooms/${currentRoom.id}/gameData`), newGameData);
      setIsPlayerActionInProgress(false);
      setIsAnyAnimationInProgress(false);
    } catch (error) {
      console.error('Error drawing multiplayer card:', error);
      setIsPlayerActionInProgress(false);
    }
  };
  const getNextPlayer = gameData => {
    let nextPlayer = gameData.currentPlayer;
    let playersToSkip = gameData.skipNextPlayer ? 1 : 0;
    do {
      nextPlayer = (nextPlayer + 1) % gameData.players.length;
    } while (gameData.players[nextPlayer].eliminated);
    while (playersToSkip > 0) {
      do {
        nextPlayer = (nextPlayer + 1) % gameData.players.length;
      } while (gameData.players[nextPlayer].eliminated);
      playersToSkip--;
    }
    return nextPlayer;
  };
  const handleMultiplayerRoundEnd = async gameData => {
    try {
      const activePlayers = gameData.players.filter(p => !p.eliminated);
      const playersWithTotals = activePlayers.map(p => ({
        ...p,
        cardTotal: calculateCardTotal(p.cards),
        cardCount: p.cards.length
      }));
      let maxTotal = Math.max(...playersWithTotals.map(p => p.cardTotal));
      const playersWithMaxTotal = playersWithTotals.filter(p => p.cardTotal === maxTotal);
      const eliminatedPlayer = playersWithMaxTotal[Math.floor(Math.random() * playersWithMaxTotal.length)];
      const roundWinner = playersWithTotals.find(p => p.cardTotal === Math.min(...playersWithTotals.map(p => p.cardTotal)));
      const roundEndInfo = {
        winner: roundWinner,
        players: playersWithTotals.map(p => ({
          ...p,
          cardCount: p.cards.length,
          cardTotal: p.cardTotal,
          cards: p.cards.slice()
        })),
        eliminatedPlayer,
        maxCards: maxTotal,
        roundNumber: gameData.roundNumber
      };
      const newGameData = {
        ...gameData,
        roundEndData: roundEndInfo,
        gamePhase: 'roundEnd'
      };
      const eliminatedPlayerInNewData = newGameData.players.find(p => p.id === eliminatedPlayer.id);
      if (eliminatedPlayerInNewData) {
        eliminatedPlayerInNewData.eliminated = true;
      }
      newGameData.lastAction = `${eliminatedPlayer.name.split(' ')[0]} eliminated`;
      const currentRoundLog = newGameData.gameLog[newGameData.roundNumber] || [];
      newGameData.gameLog[newGameData.roundNumber] = [...currentRoundLog, `Round ${newGameData.roundNumber}: ${eliminatedPlayer.name} eliminated with ${maxTotal} total card points`];
      const remainingPlayers = newGameData.players.filter(p => !p.eliminated);
      if (remainingPlayers.length <= 1) {
        newGameData.gamePhase = 'gameEnd';
        const finalWinner = remainingPlayers.length > 0 ? remainingPlayers[0] : roundWinner;
        newGameData.winner = finalWinner;
        newGameData.lastAction = `${finalWinner.name.split(' ')[0]} wins!`;
        newGameData.gameLog[newGameData.roundNumber + 1] = [`GAME OVER: ${finalWinner.name} wins the game!`];
        const isWinner = finalWinner.id === currentUser.id;
        const updateData = {
          gamesPlayed: (currentUser.gamesPlayed || 0) + 1
        };
        if (isWinner) {
          updateData.gamesWon = (currentUser.gamesWon || 0) + 1;
          updateData.xp = (currentUser.xp || 0) + 150;
          updateData.currentWinStreak = (currentUser.currentWinStreak || 0) + 1;
          updateData.bestWinStreak = Math.max(updateData.currentWinStreak, currentUser.bestWinStreak || 0);
        } else {
          updateData.currentWinStreak = 0;
        }
        await update(ref(database, `users/${currentUser.id}`), updateData);
        await update(ref(database, `rooms/${currentRoom.id}/gameData`), newGameData);
        setTimeout(async () => {
          await update(ref(database, `rooms/${currentRoom.id}`), {
            status: 'waiting',
            gameData: null,
            countdown: null
          });
        }, 10000);
      } else {
        newGameData.roundNumber++;
        await update(ref(database, `rooms/${currentRoom.id}/gameData`), newGameData);
        setTimeout(async () => {
          const deck = createDeck();
          const shuffledDeck = shuffleDeck(deck);
          const resetPlayers = newGameData.players.map(player => ({
            ...player,
            cards: []
          }));
          const nextRoundGameData = {
            ...newGameData,
            players: resetPlayers,
            playPile: [],
            drawPile: shuffledDeck,
            currentPlayer: remainingPlayers[0] ? newGameData.players.findIndex(p => p.id === remainingPlayers[0].id) : 0,
            pendingPickCount: 0,
            generalMarketActive: false,
            generalMarketOriginatorId: null,
            skipNextPlayer: false,
            gamePhase: 'dealingCards',
            lastAction: 'Dealing cards...',
            roundEndData: null,
            gameLog: {
              ...newGameData.gameLog,
              [newGameData.roundNumber]: [`Round ${newGameData.roundNumber} begins with remaining players.`, `New deck created and shuffled.`]
            }
          };
          await update(ref(database, `rooms/${currentRoom.id}/gameData`), nextRoundGameData);
        }, 10000);
      }
    } catch (error) {
      console.error('Error handling multiplayer round end:', error);
    }
  };
  const calculateLevel = xp => {
    let totalXPNeeded = 0;
    let level = 1;
    while (level <= 100) {
      const xpForThisLevel = 100 + (level - 1) * 150 + Math.floor((level - 1) / 10) * 500;
      if (totalXPNeeded + xpForThisLevel > xp) {
        break;
      }
      totalXPNeeded += xpForThisLevel;
      level++;
    }
    return {
      level: Math.min(level, 100),
      currentLevelXP: xp - totalXPNeeded,
      xpNeededForNext: level <= 100 ? 100 + level * 150 + Math.floor(level / 10) * 500 : 0,
      totalXP: xp
    };
  };
  const playerProgress = calculateLevel(currentUser?.xp || 0);
  const fetchLeaderboard = async () => {
    try {
      const usersRef = ref(database, 'users');
      onValue(usersRef, snapshot => {
        if (snapshot.exists()) {
          const usersData = snapshot.val();
          const usersList = Object.keys(usersData).map(userId => ({
            id: userId,
            ...usersData[userId]
          }));
          const sortedUsers = usersList.filter(user => user.gamesPlayed > 0).sort((a, b) => {
            const aWinRate = (a.gamesWon || 0) / (a.gamesPlayed || 1);
            const bWinRate = (b.gamesWon || 0) / (b.gamesPlayed || 1);
            if (bWinRate !== aWinRate) return bWinRate - aWinRate;
            return (b.gamesWon || 0) - (a.gamesWon || 0);
          }).slice(0, 20).map((user, index) => ({
            rank: index + 1,
            name: user.id === currentUser?.id ? 'You' : user.username,
            wins: user.gamesWon || 0,
            games: user.gamesPlayed || 0,
            winRate: user.gamesPlayed > 0 ? ((user.gamesWon || 0) / user.gamesPlayed * 100).toFixed(1) : 0,
            level: calculateLevel(user.xp || 0).level
          }));
          setLeaderboardData(sortedUsers);
        }
      });
    } catch (error) {
      console.error('Error fetching leaderboard:', error);
    }
  };
  const initializeAchievements = userData => {
    const userXP = userData?.xp || 0;
    const userGamesPlayed = userData?.gamesPlayed || 0;
    const userGamesWon = userData?.gamesWon || 0;
    const userLevel = calculateLevel(userXP).level;
    const achievementsList = [{
      id: 1,
      name: 'First Victory',
      description: 'Win your first game',
      unlocked: userGamesWon >= 1,
      claimed: userData?.claimedAchievements?.includes(1) || false,
      icon: 'ðŸ†',
      reward: '100 XP'
    }, {
      id: 2,
      name: 'Card Master',
      description: 'Play 10 games',
      unlocked: userGamesPlayed >= 10,
      claimed: userData?.claimedAchievements?.includes(2) || false,
      icon: 'ðŸŽ¯',
      reward: '200 XP'
    }, {
      id: 3,
      name: 'Shadow Warrior',
      description: 'Win 5 games in a row',
      unlocked: (userData?.currentWinStreak || 0) >= 5,
      claimed: userData?.claimedAchievements?.includes(3) || false,
      icon: 'âš”ï¸',
      reward: '500 XP'
    }, {
      id: 4,
      name: 'Strategic Mind',
      description: 'Win 20 games',
      unlocked: userGamesWon >= 20,
      claimed: userData?.claimedAchievements?.includes(4) || false,
      icon: 'ðŸ§ ',
      reward: '1200 XP'
    }, {
      id: 5,
      name: 'Century Club',
      description: 'Play 100 total games',
      unlocked: userGamesPlayed >= 100,
      claimed: userData?.claimedAchievements?.includes(5) || false,
      icon: 'ðŸ’¯',
      reward: '1500 XP'
    }, {
      id: 6,
      name: 'Ultimate Champion',
      description: 'Reach Level 50',
      unlocked: userLevel >= 50,
      claimed: userData?.claimedAchievements?.includes(6) || false,
      icon: 'ðŸŒŸ',
      reward: '2000 XP'
    }, {
      id: 7,
      name: 'Legendary Player',
      description: 'Reach Level 75',
      unlocked: userLevel >= 75,
      claimed: userData?.claimedAchievements?.includes(7) || false,
      icon: 'ðŸ‘‘',
      reward: '3000 XP'
    }, {
      id: 8,
      name: 'Whot Grandmaster',
      description: 'Reach Level 100',
      unlocked: userLevel >= 100,
      claimed: userData?.claimedAchievements?.includes(8) || false,
      icon: 'ðŸ’Ž',
      reward: '5000 XP'
    }];
    setAchievements(achievementsList);
  };
  const startConfetti = () => {
    setConfettiActive(true);
    const canvas = confettiCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const particles = [];
    const colors = ['#80142C', '#a01d39', '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1'];
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    for (let i = 0; i < 150; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: -10,
        vx: (Math.random() - 0.5) * 4,
        vy: Math.random() * 3 + 2,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: Math.random() * 8 + 4,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
        gravity: 0.1
      });
    }
    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      particles.forEach((particle, index) => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += particle.gravity;
        particle.rotation += particle.rotationSpeed;
        ctx.save();
        ctx.translate(particle.x, particle.y);
        ctx.rotate(particle.rotation * Math.PI / 180);
        ctx.fillStyle = particle.color;
        ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
        ctx.restore();
        if (particle.y > canvas.height + 50) {
          particles.splice(index, 1);
        }
      });
      if (particles.length > 0) {
        requestAnimationFrame(animate);
      } else {
        setConfettiActive(false);
      }
    };
    animate();
  };
  const updateUsername = async newUsernameValue => {
    if (!currentUser || !newUsernameValue.trim()) return;
    try {
      const userRef = ref(database, `users/${currentUser.id}`);
      await update(userRef, {
        username: newUsernameValue.trim()
      });
      setCurrentUser(prev => ({
        ...prev,
        username: newUsernameValue.trim()
      }));
      setIsEditingUsername(false);
      setNewUsername('');
    } catch (error) {
      console.error('Error updating username:', error);
    }
  };
  const claimAchievement = async achievementId => {
    if (!currentUser) return;
    const achievement = achievements.find(a => a.id === achievementId);
    if (!achievement || !achievement.unlocked || achievement.claimed) return;
    try {
      const xpReward = parseInt(achievement.reward.replace(' XP', ''));
      const userRef = ref(database, `users/${currentUser.id}`);
      const claimedAchievements = currentUser.claimedAchievements || [];
      await update(userRef, {
        xp: (currentUser.xp || 0) + xpReward,
        claimedAchievements: [...claimedAchievements, achievementId]
      });
      setAchievements(prevAchievements => prevAchievements.map(a => {
        if (a.id === achievementId) {
          return {
            ...a,
            claimed: true
          };
        }
        return a;
      }));
    } catch (error) {
      console.error('Error claiming achievement:', error);
    }
  };
  const getXPFromGame = (won, roundsPlayed, cardsPlayed) => {
    let baseXP = 50;
    if (won) baseXP += 100;
    baseXP += roundsPlayed * 25;
    baseXP += Math.floor(cardsPlayed / 5) * 10;
    return baseXP;
  };
  useEffect(() => {
    const calculateMaxCards = () => {
      const screenWidth = window.innerWidth;
      const cardWidth = screenWidth < 768 ? 72 : screenWidth < 1024 ? 100 : 130;
      const availableWidth = screenWidth - 400;
      const cardSpacing = 6;
      const maxCards = Math.max(3, Math.floor(availableWidth / (cardWidth + cardSpacing)));
      setMaxVisiblePlayerCards(Math.min(maxCards, 7));
      const positions = {
        playPile: {
          top: '50%',
          left: '50%',
          transform: `translate(calc(-50% - ${screenWidth < 768 ? '54px' : screenWidth < 1024 ? '72px' : '90px'}), -50%)`
        },
        market: {
          top: '50%',
          left: '50%',
          transform: `translate(calc(-50% + ${screenWidth < 768 ? '54px' : screenWidth < 1024 ? '72px' : '90px'}), -50%)`
        },
        playerDecks: {
          0: {
            bottom: '20px',
            left: '50%',
            transform: 'translateX(-50%)'
          },
          1: {
            left: '-120px',
            top: '50%',
            transform: 'translateY(-50%) rotate(-90deg)'
          },
          2: {
            top: '20px',
            left: '50%',
            transform: 'translateX(-50%)'
          },
          3: {
            right: '-120px',
            top: '50%',
            transform: 'translateY(-50%) rotate(90deg)'
          }
        },
        animationStarts: {
          0: {
            top: 'calc(100vh + 200px)',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 0
          },
          1: {
            left: '-200px',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 0
          },
          2: {
            top: '-200px',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 0
          },
          3: {
            left: 'calc(100% + 200px)',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 0
          }
        },
        drawEnds: {
          0: {
            top: 'calc(100vh - 120px)',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 1
          },
          1: {
            left: '-120px',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 1
          },
          2: {
            top: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            opacity: 1
          },
          3: {
            left: 'calc(100% + 120px)',
            top: '50%',
            transform: 'translateY(-50%)',
            opacity: 1
          }
        }
      };
      setAnimationPositions(positions);
    };
    calculateMaxCards();
    window.addEventListener('resize', calculateMaxCards);
    return () => window.removeEventListener('resize', calculateMaxCards);
  }, []);
  useEffect(() => {
    if (gameState === 'game' && !gameData) {
      initializeGame();
      setPlayerScrollIndex(0);
      setNeedNewMarketPositions(true);
    }
  }, [gameState]);
  useEffect(() => {
    if (gameData && gameData.drawPile && needNewMarketPositions) {
      if (marketCardPositionsRef.current.length === 0) {
        const positions = Array.from({
          length: 8
        }, (_, index) => {
          const randomX = (Math.random() - 0.5) * 8;
          const randomY = (Math.random() - 0.5) * 8;
          const randomRotate = (Math.random() - 0.5) * 15;
          return {
            transform: `translate(${randomX}px, ${randomY}px) rotate(${randomRotate}deg)`,
            zIndex: index
          };
        });
        marketCardPositionsRef.current = positions;
        setMarketCardPositions(positions);
      } else {
        setMarketCardPositions(marketCardPositionsRef.current);
      }
      setNeedNewMarketPositions(false);
    }
  }, [gameData?.drawPile, needNewMarketPositions]);
  useEffect(() => {
    if (gameData && gameData.gamePhase === 'roundEnd' && gameData.roundEndData && !showRoundEndPopup) {
      setRoundEndData(gameData.roundEndData);
      setTimeout(() => {
        setShowRoundEndPopup(true);
        setTimeout(() => startConfetti(), 200);
      }, 2500);
      setTimeout(() => {
        setShowRoundEndPopup(false);
        setRoundEndData(null);
        setConfettiActive(false);
      }, 12500);
    }
  }, [gameData?.gamePhase, gameData?.roundEndData, showRoundEndPopup]);
  useEffect(() => {
    if (currentRoom && gameData && gameData.gamePhase === 'dealingCards' && gameData.players.every(p => p.cards.length === 0)) {
      const activePlayers = gameData.players.filter(p => !p.eliminated);
      const cardsPerPlayer = getCardsPerPlayer(activePlayers.length);
      setTimeout(() => {
        startDealingAnimation([...gameData.drawPile], activePlayers, cardsPerPlayer);
      }, 500);
    }
  }, [gameData?.gamePhase, currentRoom, gameData?.players]);
  const getCardsPerPlayer = playerCount => {
    if (playerCount === 4) return 6;
    if (playerCount === 3) return 9;
    if (playerCount === 2) return 12;
    return 6;
  };
  const initializeGame = () => {
    const deck = createDeck();
    const shuffledDeck = shuffleDeck(deck);
    const players = [{
      id: 0,
      name: 'You',
      cards: [],
      isAI: false,
      eliminated: false
    }, {
      id: 1,
      name: 'AI Shadow',
      cards: [],
      isAI: true,
      eliminated: false
    }, {
      id: 2,
      name: 'AI Phantom',
      cards: [],
      isAI: true,
      eliminated: false
    }, {
      id: 3,
      name: 'AI Wraith',
      cards: [],
      isAI: true,
      eliminated: false
    }];
    const cardsPerPlayer = getCardsPerPlayer(players.length);
    console.log(`Initializing game: ${players.length} total players (1 human + ${players.length - 1} AI), ${cardsPerPlayer} cards each`);
    playPilePositionsRef.current = [];
    setPlayPilePositions([]);
    setGameData({
      players,
      playPile: [],
      drawPile: shuffledDeck,
      currentPlayer: 0,
      gamePhase: 'dealingCards',
      roundNumber: 1,
      lastAction: 'Dealing cards...',
      pendingPickCount: 0,
      generalMarketActive: false,
      generalMarketOriginatorId: null,
      gameLog: {
        1: [`Game started with ${players.length} players: ${players.map(p => p.name).join(', ')}`, 'Cards dealt to all players', 'The shadow realm awaits your first move...']
      }
    });
    setTimeout(() => startDealingAnimation([...shuffledDeck], players, cardsPerPlayer), 500);
  };
  const startDealingAnimation = async (deckToDeal, players, cardsPerPlayer) => {
    setIsAnyAnimationInProgress(true);
    const totalCardsToDistribute = players.length * cardsPerPlayer;
    for (let i = 0; i < totalCardsToDistribute; i++) {
      const currentPlayerIndex = i % players.length;
      const currentPlayer = players[currentPlayerIndex];
      const cardToDeal = deckToDeal[i];
      let visualPlayerIndex = currentPlayerIndex;
      if (currentRoom && gameData) {
        const mapping = getVisualPlayerMapping();
        visualPlayerIndex = mapping.actualToVisual[currentPlayerIndex] !== undefined ? mapping.actualToVisual[currentPlayerIndex] : currentPlayerIndex;
      }
      const dealingCard = {
        ...cardToDeal,
        id: `dealing-${Date.now()}-${i}`,
        startPos: getTopMarketCardPosition(),
        endPos: {
          ...animationPositions.drawEnds[visualPlayerIndex],
          opacity: 0
        },
        isPlayerCard: false
      };
      setAnimatingCards(prev => [...prev, dealingCard]);
      await new Promise(resolve => {
        setTimeout(() => {
          setAnimatingCards(prev => prev.filter(c => c.id !== dealingCard.id));
          setGameData(prevData => {
            const newData = {
              ...prevData
            };
            const updatedPlayers = newData.players.map(p => ({
              ...p,
              cards: [...p.cards]
            }));
            const actualPlayerIndex = updatedPlayers.findIndex(p => p.id === currentPlayer.id);
            if (actualPlayerIndex !== -1 && !updatedPlayers[actualPlayerIndex].eliminated) {
              updatedPlayers[actualPlayerIndex].cards.push(cardToDeal);
            }
            return {
              ...newData,
              players: updatedPlayers,
              drawPile: deckToDeal.slice(i + 1)
            };
          });
          resolve();
        }, 80);
      });
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    const remainingDeck = deckToDeal.slice(totalCardsToDistribute);
    if (remainingDeck.length > 0) {
      const playCard = remainingDeck[0];
      console.log("Dealing initial play card:", playCard);
      const endPosition = getPlayPilePosition(0, false);
      setPlayPileCardPositions(prev => ({
        ...prev,
        [0]: endPosition
      }));
      const playPileCard = {
        ...playCard,
        id: `dealing-play-${Date.now()}`,
        startPos: getTopMarketCardPosition(),
        endPos: {
          ...animationPositions.playPile,
          transform: `${animationPositions.playPile.transform} ${endPosition.transform}`,
          zIndex: endPosition.zIndex
        },
        isPlayerCard: true
      };
      setAnimatingCards(prev => [...prev, playPileCard]);
      await new Promise(resolve => {
        setTimeout(() => {
          setAnimatingCards(prev => prev.filter(c => c.id !== playPileCard.id));
          const initialCardEffects = {};
          let specialMessage = '';
          if (playCard.special === 'whot') {
            const shapes = ['â—', 'â–²', 'âœš', 'â– ', 'â˜…'];
            playCard.chosenShape = shapes[Math.floor(Math.random() * shapes.length)];
            specialMessage = ` - Auto-chosen shape: ${playCard.chosenShape}`;
          }
          setGameData(prevData => {
            const newData = {
              ...prevData,
              playPile: [playCard],
              drawPile: remainingDeck.slice(1),
              gamePhase: 'playing',
              lastAction: prevData.roundNumber === 1 ? `Game started - ${playCard.number}${playCard.shape} played${specialMessage}` : `Round ${prevData.roundNumber}`,
              ...initialCardEffects,
              generalMarketDrawCount: initialCardEffects.generalMarketActive ? 0 : undefined,
              gameLog: {
                ...prevData.gameLog,
                [prevData.roundNumber]: prevData.roundNumber === 1 ? [...(prevData.gameLog[1] || []), `Initial card: ${playCard.number}${playCard.shape} placed on table${specialMessage}`] : [...(prevData.gameLog[prevData.roundNumber] || []), `Round ${prevData.roundNumber} begins`]
              }
            };
            if (newData.players[newData.currentPlayer].isAI) {
              setTimeout(() => {
                setIsAITurnInProgress(true);
                setTimeout(async () => {
                  if (!isAnyAnimationInProgress) {
                    await aiTurn({
                      ...newData
                    });
                  }
                }, 1000);
              }, 500);
            }
            return newData;
          });
          resolve();
        }, 800);
      });
    }
    setIsAnyAnimationInProgress(false);
  };
  const createDeck = () => {
    const deck = [];
    let cardIdCounter = 0;
    const cardDefinitions = [{
      shape: 'â—',
      numbers: [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14]
    }, {
      shape: 'â–²',
      numbers: [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14]
    }, {
      shape: 'âœš',
      numbers: [1, 2, 3, 5, 7, 10, 11, 13, 14]
    }, {
      shape: 'â– ',
      numbers: [1, 2, 3, 5, 7, 10, 11, 13, 14]
    }, {
      shape: 'â˜…',
      numbers: [1, 2, 3, 4, 5, 7, 8]
    }];
    const createdCards = new Map();
    cardDefinitions.forEach(({
      shape,
      numbers
    }) => {
      numbers.forEach(number => {
        const cardKey = `${shape}-${number}`;
        if (createdCards.has(cardKey)) {
          console.error(`CRITICAL ERROR: Attempted to create duplicate card: ${cardKey}`);
          throw new Error(`Duplicate card creation attempted: ${cardKey}`);
        }
        const card = {
          shape: shape,
          number: number,
          id: `unique-${shape}-${number}-${Date.now()}-${cardIdCounter++}`
        };
        if (number === 1) card.special = 'holdon';else if (number === 2) card.special = 'pick2';else if (number === 14) card.special = 'generalmarket';
        createdCards.set(cardKey, card);
        deck.push(card);
      });
    });
    for (let i = 0; i < 5; i++) {
      deck.push({
        shape: 'ðŸ”¥',
        number: 'WHOT',
        id: `whot-${i}-${Date.now()}-${cardIdCounter++}`,
        special: 'whot'
      });
    }
    const regularCards = deck.filter(card => card.special !== 'whot');
    const cardKeys = regularCards.map(card => `${card.shape}-${card.number}`);
    const uniqueKeys = new Set(cardKeys);
    if (cardKeys.length !== uniqueKeys.size) {
      console.error('CRITICAL: Duplicate cards found in deck after creation!');
      console.log('Total regular cards:', cardKeys.length);
      console.log('Unique combinations:', uniqueKeys.size);
      const duplicates = cardKeys.filter((key, index) => cardKeys.indexOf(key) !== index);
      console.error('Duplicate cards found:', [...new Set(duplicates)]);
      throw new Error('Deck creation failed - duplicate cards detected');
    }
    console.log(`âœ“ Deck created successfully: ${deck.length} total cards`);
    console.log(`  - Circles: ${deck.filter(c => c.shape === 'â—').length}`);
    console.log(`  - Triangles: ${deck.filter(c => c.shape === 'â–²').length}`);
    console.log(`  - Crosses: ${deck.filter(c => c.shape === 'âœš').length}`);
    console.log(`  - Squares: ${deck.filter(c => c.shape === 'â– ').length}`);
    console.log(`  - Stars: ${deck.filter(c => c.shape === 'â˜…').length}`);
    console.log(`  - WHOT cards: ${deck.filter(c => c.shape === 'ðŸ”¥').length}`);
    console.log(`âœ“ All ${uniqueKeys.size} regular card combinations are unique`);
    return deck;
  };
  const shuffleDeck = deck => {
    const shuffled = [...deck];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };
  const canPlayCard = (card, topCard) => {
    if (!card) return false;
    if (card.special === 'whot') return true;
    if (!topCard) {
      return false;
    }
    return card.shape === topCard.shape || card.number === topCard.number;
  };
  const chooseWhotShape = async shape => {
    if (!pendingWhotCard || isPlayerActionInProgress || isAnyAnimationInProgress) return;
    setIsPlayerActionInProgress(true);
    const newGameData = {
      ...gameData
    };
    const whotCard = {
      ...pendingWhotCard,
      chosenShape: shape
    };
    newGameData.playPile[newGameData.playPile.length - 1] = whotCard;
    if (currentRoom) {
      const currentUserActualIndex = gameData.players.findIndex(p => p.id === currentUser.id);
      const currentPlayer = newGameData.players[currentUserActualIndex];
      newGameData.lastAction = `${currentPlayer.name} - WHOT â†’ ${shape}`;
      newGameData.gameLog = {
        ...newGameData.gameLog,
        [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played WHOT and chose ${shape} as the active shape`]
      };
      setShowWhotChoice(false);
      setPendingWhotCard(null);
      if (currentPlayer.cards.length === 0) {
        await handleMultiplayerRoundEnd(newGameData);
      } else {
        const nextPlayerIndex = getNextPlayer(newGameData);
        newGameData.currentPlayer = nextPlayerIndex;
        newGameData.skipNextPlayer = false;
        if (newGameData.generalMarketActive && nextPlayerIndex === newGameData.generalMarketOriginatorId) {
          newGameData.generalMarketActive = false;
          newGameData.generalMarketOriginatorId = null;
          newGameData.lastAction += ' General Market effect ends.';
          newGameData.gameLog = {
            ...newGameData.gameLog,
            [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), 'General Market effect ended - all players have drawn']
          };
        }
        await update(ref(database, `rooms/${currentRoom.id}/gameData`), newGameData);
      }
      setIsPlayerActionInProgress(false);
    } else {
      newGameData.lastAction = `You - WHOT â†’ ${shape}`;
      newGameData.gameLog = {
        ...newGameData.gameLog,
        [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played WHOT and chose ${shape} as the active shape`]
      };
      setShowWhotChoice(false);
      setPendingWhotCard(null);
      if (newGameData.players[0].cards.length === 0) {
        endRound(newGameData);
      } else {
        nextTurn(newGameData);
      }
      setGameData(newGameData);
      setIsPlayerActionInProgress(false);
    }
  };
  const getVisualPlayerMapping = () => {
    if (!currentRoom || !gameData) {
      return {
        visualToActual: [0, 1, 2, 3],
        actualToVisual: {
          0: 0,
          1: 1,
          2: 2,
          3: 3
        }
      };
    }
    const currentUserActualIndex = gameData.players.findIndex(p => p.id === currentUser?.id);
    if (currentUserActualIndex === -1) {
      return {
        visualToActual: [0, 1, 2, 3],
        actualToVisual: {
          0: 0,
          1: 1,
          2: 2,
          3: 3
        }
      };
    }
    const totalPlayers = gameData.players.length;
    const visualToActual = [];
    const actualToVisual = {};
    visualToActual[0] = currentUserActualIndex;
    actualToVisual[currentUserActualIndex] = 0;
    for (let i = 1; i < totalPlayers; i++) {
      const actualIndex = (currentUserActualIndex + i) % totalPlayers;
      visualToActual[i] = actualIndex;
      actualToVisual[actualIndex] = i;
    }
    return {
      visualToActual,
      actualToVisual
    };
  };
  const getExactCardPosition = (playerIndex, cardIndex, totalCards, clampToVisible = true) => {
    if (!animationPositions.playerDecks) return {
      left: '50%',
      top: '50%',
      transform: 'translate(-50%, -50%)'
    };
    let visualPlayerIndex = playerIndex;
    if (currentRoom && gameData) {
      const mapping = getVisualPlayerMapping();
      visualPlayerIndex = mapping.actualToVisual[playerIndex] !== undefined ? mapping.actualToVisual[playerIndex] : playerIndex;
    }
    const basePosition = animationPositions.playerDecks[visualPlayerIndex];
    const cardWidth = window.innerWidth < 768 ? 72 : window.innerWidth < 1024 ? 100 : 130;
    const cardSpacing = 6;
    const MAX_VISIBLE_AI_CARDS = 3;
    if (visualPlayerIndex === 0) {
      const effectiveCardIndex = clampToVisible ? Math.max(0, Math.min(cardIndex, totalCards - 1)) : cardIndex;
      const totalHandWidth = totalCards * cardWidth + (totalCards - 1) * cardSpacing;
      const startX = (window.innerWidth - totalHandWidth) / 2;
      const cardX = startX + effectiveCardIndex * (cardWidth + cardSpacing);
      return {
        position: 'fixed',
        left: `${cardX}px`,
        bottom: basePosition.bottom,
        transform: basePosition.transform || ''
      };
    } else if (visualPlayerIndex === 1) {
      const effectiveCardIndex = clampToVisible ? Math.min(cardIndex, MAX_VISIBLE_AI_CARDS - 1) : cardIndex;
      const cardY = window.innerHeight / 2 - (MAX_VISIBLE_AI_CARDS * cardWidth + (MAX_VISIBLE_AI_CARDS - 1) * cardSpacing) / 2 + effectiveCardIndex * (cardWidth + cardSpacing);
      return {
        position: 'fixed',
        left: basePosition.left,
        top: `${cardY}px`,
        transform: basePosition.transform || ''
      };
    } else if (visualPlayerIndex === 2) {
      const effectiveCardIndex = clampToVisible ? Math.min(cardIndex, MAX_VISIBLE_AI_CARDS - 1) : cardIndex;
      const cardX = window.innerWidth / 2 - (MAX_VISIBLE_AI_CARDS * cardWidth + (MAX_VISIBLE_AI_CARDS - 1) * cardSpacing) / 2 + effectiveCardIndex * (cardWidth + cardSpacing);
      return {
        position: 'fixed',
        left: `${cardX}px`,
        top: basePosition.top,
        transform: basePosition.transform || ''
      };
    } else if (visualPlayerIndex === 3) {
      const effectiveCardIndex = clampToVisible ? Math.min(cardIndex, MAX_VISIBLE_AI_CARDS - 1) : cardIndex;
      const cardY = window.innerHeight / 2 - (MAX_VISIBLE_AI_CARDS * cardWidth + (MAX_VISIBLE_AI_CARDS - 1) * cardSpacing) / 2 + effectiveCardIndex * (cardWidth + cardSpacing);
      return {
        position: 'fixed',
        right: basePosition.right,
        top: `${cardY}px`,
        transform: basePosition.transform || ''
      };
    }
    return basePosition;
  };
  const getPlayPilePosition = (cardIndex = null, storePosition = true) => {
    cardIndex = cardIndex === null ? 0 : cardIndex;
    while (playPilePositionsRef.current.length <= cardIndex) {
      const randomX = (Math.random() - 0.5) * 8;
      const randomY = (Math.random() - 0.5) * 8;
      const randomRotate = (Math.random() - 0.5) * 15;
      playPilePositionsRef.current.push({
        transform: `translate(${randomX}px, ${randomY}px) rotate(${randomRotate}deg)`,
        zIndex: 30 + playPilePositionsRef.current.length
      });
    }
    const cardPosition = playPilePositionsRef.current[cardIndex];
    const relativeCardStyle = {
      transform: cardPosition.transform,
      zIndex: cardPosition.zIndex
    };
    if (storePosition) {
      setPlayPileCardPositions(prev => ({
        ...prev,
        [cardIndex]: relativeCardStyle
      }));
    }
    return relativeCardStyle;
  };
  const getMarketCardPosition = index => {
    return marketCardPositionsRef.current[index] || marketCardPositions[index] || {
      transform: 'translate(0px, 0px) rotate(0deg)',
      zIndex: index
    };
  };
  const scrollPlayerCards = direction => {
    if (!gameData) return;
    const currentUserActualIndex = currentRoom ? gameData.players.findIndex(p => p.id === currentUser?.id) : 0;
    const playerCards = gameData.players[currentUserActualIndex]?.cards || gameData.players[0].cards;
    const maxScroll = Math.max(0, playerCards.length - maxVisiblePlayerCards);
    if (direction === 'left') {
      setPlayerScrollIndex(Math.max(0, playerScrollIndex - 1));
    } else if (direction === 'right') {
      setPlayerScrollIndex(Math.min(maxScroll, playerScrollIndex + 1));
    }
  };
  const isCardPlayable = (card, topCard) => {
    if (card.special === 'whot') return true;
    if (!topCard) {
      return false;
    }
    if (topCard.chosenShape) {
      return card.shape === topCard.chosenShape;
    }
    return card.shape === topCard.shape || card.number === topCard.number;
  };
  const hasPlayableCardsOutsideRange = () => {
    if (!gameData) return {
      left: false,
      right: false
    };
    const currentUserActualIndex = currentRoom ? gameData.players.findIndex(p => p.id === currentUser?.id) : 0;
    if (gameData.currentPlayer !== currentUserActualIndex) return {
      left: false,
      right: false
    };
    const player = gameData.players[currentUserActualIndex];
    const topCard = gameData.playPile[gameData.playPile.length - 1];
    const leftCards = player.cards.slice(0, playerScrollIndex);
    const hasPlayableLeft = leftCards.some(card => isCardPlayable(card, topCard));
    const rightCards = player.cards.slice(playerScrollIndex + maxVisiblePlayerCards);
    const hasPlayableRight = rightCards.some(card => isCardPlayable(card, topCard));
    return {
      left: hasPlayableLeft,
      right: hasPlayableRight
    };
  };
  const playCard = cardIndex => {
    if (!gameData || gameData.currentPlayer !== 0 || isPlayerActionInProgress || isAnyAnimationInProgress || animatingCards.length > 0) return;
    setIsPlayerActionInProgress(true);
    setIsAnyAnimationInProgress(true);
    const newGameData = JSON.parse(JSON.stringify(gameData));
    const player = newGameData.players[0];
    const actualCardIndex = cardIndex + playerScrollIndex;
    const card = player.cards[actualCardIndex];
    const topCard = newGameData.playPile[newGameData.playPile.length - 1];
    const newCardRelativeStyle = getPlayPilePosition(newGameData.playPile.length, false);
    if (topCard.chosenShape) {
      if (card.special !== 'whot' && card.shape !== topCard.chosenShape) {
        setIsPlayerActionInProgress(false);
        setIsAnyAnimationInProgress(false);
        return;
      }
    } else if (!canPlayCard(card, topCard)) {
      setIsPlayerActionInProgress(false);
      setIsAnyAnimationInProgress(false);
      return;
    }
    const endPosition = {
      ...animationPositions.playPile,
      transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
      zIndex: newCardRelativeStyle.zIndex
    };
    const animatingCard = {
      ...card,
      id: `animating-${Date.now()}-${actualCardIndex}`,
      startPos: getExactCardPosition(0, actualCardIndex, player.cards.length, true),
      endPos: endPosition,
      isPlayerCard: true
    };
    setAnimatingCards(prev => [...prev, animatingCard]);
    player.cards = player.cards.filter((_, idx) => idx !== actualCardIndex);
    newGameData.playPile = [...newGameData.playPile, card];
    const newCardsLength = player.cards.length;
    const maxScroll = Math.max(0, newCardsLength - maxVisiblePlayerCards);
    if (newCardsLength <= maxVisiblePlayerCards) {
      setPlayerScrollIndex(0);
    } else if (playerScrollIndex >= maxScroll) {
      setPlayerScrollIndex(maxScroll);
    } else if (actualCardIndex < playerScrollIndex + Math.floor(maxVisiblePlayerCards / 2)) {
      setPlayerScrollIndex(Math.max(0, playerScrollIndex - 1));
    }
    setTimeout(() => {
      getPlayPilePosition(newGameData.playPile.length - 1, true);
      setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
      if (card.special === 'pick2') {
        newGameData.pendingPickCount += 2;
        newGameData.lastAction = `You - ${card.number}${card.shape} pick2`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape} (Pick 2) - Next player must draw 2 cards`]
        };
      } else if (card.special === 'whot') {
        setPendingWhotCard(card);
        setShowWhotChoice(true);
        setGameData(newGameData);
        setIsPlayerActionInProgress(false);
        setIsAnyAnimationInProgress(false);
        return;
      } else if (card.special === 'holdon') {
        newGameData.lastAction = `You - ${card.number}${card.shape} hold`;
        newGameData.skipNextPlayer = true;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape} (Hold On) - Next player's turn skipped`]
        };
      } else if (card.special === 'generalmarket') {
        newGameData.lastAction = `You - ${card.number}${card.shape} gen`;
        newGameData.generalMarketActive = true;
        newGameData.generalMarketOriginatorId = 0;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape} (General Market) - All other players must draw from market`]
        };
      } else {
        newGameData.lastAction = `You - ${card.number}${card.shape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `You played ${card.number}${card.shape}`]
        };
      }
      if (player.cards.length === 0) {
        endRound(newGameData);
        setGameData(newGameData);
        setIsPlayerActionInProgress(false);
        setIsAnyAnimationInProgress(false);
      } else {
        setGameData(newGameData);
        setIsPlayerActionInProgress(false);
        setIsAnyAnimationInProgress(false);
        if (newGameData.gamePhase === 'playing') {
          nextTurn(newGameData);
        }
      }
    }, 800);
  };
  const nextTurn = gameData => {
    let nextPlayer = gameData.currentPlayer;
    let playersToSkip = gameData.skipNextPlayer ? 1 : 0;
    do {
      nextPlayer = (nextPlayer + 1) % gameData.players.length;
    } while (gameData.players[nextPlayer].eliminated);
    while (playersToSkip > 0) {
      do {
        nextPlayer = (nextPlayer + 1) % gameData.players.length;
      } while (gameData.players[nextPlayer].eliminated);
      playersToSkip--;
    }
    gameData.currentPlayer = nextPlayer;
    gameData.skipNextPlayer = false;
    if (gameData.generalMarketActive && nextPlayer === gameData.generalMarketOriginatorId) {
      gameData.generalMarketActive = false;
      gameData.generalMarketOriginatorId = null;
      gameData.lastAction += ' General Market effect ends.';
      gameData.gameLog = {
        ...gameData.gameLog,
        [gameData.roundNumber]: [...(gameData.gameLog[gameData.roundNumber] || []), 'General Market effect ended - all players have drawn']
      };
    }
    setGameData({
      ...gameData
    });
    if (gameData.players[nextPlayer].isAI) {
      setIsAITurnInProgress(true);
      setTimeout(async () => {
        if (!isAnyAnimationInProgress) {
          await aiTurn({
            ...gameData,
            currentPlayer: nextPlayer
          });
        }
      }, 1000);
    }
  };
  const aiTurn = async gameData => {
    if (!gameData.players[gameData.currentPlayer].isAI || isAnyAnimationInProgress) {
      setIsAITurnInProgress(false);
      return;
    }
    setIsAnyAnimationInProgress(true);
    let newGameData = JSON.parse(JSON.stringify(gameData));
    const currentPlayer = newGameData.players[newGameData.currentPlayer];
    if (newGameData.pendingPickCount > 0 || newGameData.generalMarketActive && currentPlayer.id !== newGameData.generalMarketOriginatorId) {
      const count = newGameData.pendingPickCount > 0 ? newGameData.pendingPickCount : 1;
      const isPending = newGameData.pendingPickCount > 0;
      const isGeneral = newGameData.generalMarketActive && currentPlayer.id !== newGameData.generalMarketOriginatorId && !isPending;
      await animateDrawCards(newGameData, currentPlayer, count, isPending, isGeneral);
      setIsAITurnInProgress(false);
      return;
    }
    const topCard = newGameData.playPile[newGameData.playPile.length - 1];
    const playableCards = currentPlayer.cards.map((card, index) => ({
      card,
      index
    })).filter(({
      card
    }) => {
      if (!topCard) return card.special === 'whot';
      if (topCard.chosenShape) return card.special === 'whot' || card.shape === topCard.chosenShape;
      return canPlayCard(card, topCard);
    });
    if (playableCards.length > 0) {
      const randomCard = playableCards[Math.floor(Math.random() * playableCards.length)];
      const cardToPlay = {
        ...randomCard.card
      };
      const currentTopCard = newGameData.playPile[newGameData.playPile.length - 1];
      let isValidPlay = false;
      if (cardToPlay.special === 'whot') {
        isValidPlay = true;
      } else if (!currentTopCard) {
        isValidPlay = false;
      } else if (currentTopCard.chosenShape) {
        isValidPlay = cardToPlay.shape === currentTopCard.chosenShape;
      } else {
        isValidPlay = cardToPlay.shape === currentTopCard.shape || cardToPlay.number === currentTopCard.number;
      }
      if (!isValidPlay) {
        console.warn(`AI ${currentPlayer.name} attempted invalid play: ${cardToPlay.number}${cardToPlay.shape} on ${currentTopCard?.number}${currentTopCard?.chosenShape || currentTopCard?.shape}`);
        await animateDrawCards(newGameData, currentPlayer, 1, false, false);
        setIsAITurnInProgress(false);
        setIsAnyAnimationInProgress(false);
        return;
      }
      const newCardRelativeStyle = getPlayPilePosition(newGameData.playPile.length, false);
      const endPosition = {
        ...animationPositions.playPile,
        transform: `${animationPositions.playPile.transform} ${newCardRelativeStyle.transform}`,
        zIndex: newCardRelativeStyle.zIndex
      };
      const animatingCard = {
        ...cardToPlay,
        id: `animating-${Date.now()}-${randomCard.index}`,
        startPos: animationPositions.animationStarts[currentPlayer.id],
        endPos: endPosition,
        isPlayerCard: true
      };
      setAnimatingCards(prev => [...prev, animatingCard]);
      await new Promise(resolve => setTimeout(resolve, 800));
      currentPlayer.cards = currentPlayer.cards.filter((_, idx) => idx !== randomCard.index);
      newGameData.playPile = [...newGameData.playPile, cardToPlay];
      setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
      if (cardToPlay.special === 'whot') {
        const shapes = ['â—', 'â–²', 'âœš', 'â– ', 'â˜…'];
        cardToPlay.chosenShape = shapes[Math.floor(Math.random() * shapes.length)];
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - WHOT â†’ ${cardToPlay.chosenShape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played WHOT and chose ${cardToPlay.chosenShape} as the active shape`]
        };
      } else if (cardToPlay.special === 'pick2') {
        newGameData.pendingPickCount += 2;
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape} pick2`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (Pick 2) - Next player must draw 2 cards`]
        };
      } else if (cardToPlay.special === 'holdon') {
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape} hold`;
        newGameData.skipNextPlayer = true;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (Hold On) - Next player's turn skipped`]
        };
      } else if (cardToPlay.special === 'generalmarket') {
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape} gen`;
        newGameData.generalMarketActive = true;
        newGameData.generalMarketOriginatorId = newGameData.currentPlayer;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape} (General Market) - All other players must draw from market`]
        };
      } else {
        newGameData.lastAction = `${currentPlayer.name.split(' ')[0]} - ${cardToPlay.number}${cardToPlay.shape}`;
        newGameData.gameLog = {
          ...newGameData.gameLog,
          [newGameData.roundNumber]: [...(newGameData.gameLog[newGameData.roundNumber] || []), `${currentPlayer.name} played ${cardToPlay.number}${cardToPlay.shape}`]
        };
      }
      if (currentPlayer.cards.length === 0) {
        endRound(newGameData);
        setGameData(newGameData);
        setIsAITurnInProgress(false);
        return;
      }
      setGameData(newGameData);
      setIsAITurnInProgress(false);
      setIsAnyAnimationInProgress(false);
      nextTurn(newGameData);
    } else {
      await animateDrawCards(newGameData, currentPlayer, 1, false, false);
      setIsAITurnInProgress(false);
      return;
    }
  };
  const calculateCardTotal = cards => {
    return cards.reduce((total, card) => {
      if (card.number === 'WHOT') return total + 20;
      return total + parseInt(card.number);
    }, 0);
  };
  const endRound = gameData => {
    const activePlayers = gameData.players.filter(p => !p.eliminated);
    const playersWithTotals = activePlayers.map(p => ({
      ...p,
      cardTotal: calculateCardTotal(p.cards),
      cardCount: p.cards.length
    }));
    let maxTotal = Math.max(...playersWithTotals.map(p => p.cardTotal));
    const playersWithMaxTotal = playersWithTotals.filter(p => p.cardTotal === maxTotal);
    const eliminatedPlayer = playersWithMaxTotal[Math.floor(Math.random() * playersWithMaxTotal.length)];
    const roundWinner = playersWithTotals.find(p => p.cardTotal === Math.min(...playersWithTotals.map(p => p.cardTotal)));
    const roundEndInfo = {
      winner: roundWinner,
      players: playersWithTotals.map(p => ({
        ...p,
        cardCount: p.cards.length,
        cardTotal: p.cardTotal,
        cards: p.cards.slice()
      })),
      eliminatedPlayer,
      maxCards: maxTotal,
      roundNumber: gameData.roundNumber
    };
    setRoundEndData(roundEndInfo);
    setTimeout(() => {
      setShowRoundEndPopup(true);
      setTimeout(() => startConfetti(), 200);
    }, 2500);
    setTimeout(() => {
      setGameData(prevData => {
        const nextRoundGameData = JSON.parse(JSON.stringify(prevData));
        const eliminatedPlayerInNewData = nextRoundGameData.players.find(p => p.id === eliminatedPlayer.id);
        if (eliminatedPlayerInNewData) {
          eliminatedPlayerInNewData.eliminated = true;
        }
        nextRoundGameData.lastAction = `${eliminatedPlayer.name.split(' ')[0]} eliminated`;
        const currentRoundLog = nextRoundGameData.gameLog[nextRoundGameData.roundNumber] || [];
        nextRoundGameData.gameLog[nextRoundGameData.roundNumber] = [...currentRoundLog, `Round ${nextRoundGameData.roundNumber}: ${eliminatedPlayer.name} eliminated with ${maxTotal} total card points`];
        if (eliminatedPlayer.id === 0) {
          setShowEliminatedPopup(true);
        }
        nextRoundGameData.roundNumber++;
        const remainingPlayers = nextRoundGameData.players.filter(p => !p.eliminated);
        if (remainingPlayers.length <= 1) {
          nextRoundGameData.gamePhase = 'gameEnd';
          const winner = remainingPlayers.length > 0 ? remainingPlayers[0] : roundWinner;
          nextRoundGameData.winner = winner;
          nextRoundGameData.lastAction = `${winner.name.split(' ')[0]} wins!`;
          nextRoundGameData.gameLog[nextRoundGameData.roundNumber] = [`GAME OVER: ${winner.name} wins the game!`];
          setShowRoundEndPopup(false);
          return nextRoundGameData;
        } else {
          const newDeck = createDeck();
          const shuffledNewDeck = shuffleDeck(newDeck);
          nextRoundGameData.players.forEach(player => {
            player.cards = [];
          });
          nextRoundGameData.playPile = [];
          nextRoundGameData.drawPile = shuffledNewDeck;
          const firstPlayerIndex = nextRoundGameData.players.findIndex(p => !p.eliminated);
          nextRoundGameData.currentPlayer = firstPlayerIndex !== -1 ? firstPlayerIndex : 0;
          nextRoundGameData.pendingPickCount = 0;
          nextRoundGameData.generalMarketActive = false;
          nextRoundGameData.generalMarketOriginatorId = null;
          nextRoundGameData.skipNextPlayer = false;
          nextRoundGameData.gamePhase = 'dealingCards';
          nextRoundGameData.lastAction = 'Dealing cards...';
          nextRoundGameData.gameLog[nextRoundGameData.roundNumber] = [`Round ${nextRoundGameData.roundNumber} begins with remaining players.`, `New deck created and shuffled.`];
          setAnimatingCards([]);
          setPlayerScrollIndex(0);
          setNeedNewMarketPositions(true);
          playPilePositionsRef.current = [];
          setPlayPilePositions([]);
          setPlayPileCardPositions({});
          setIsAITurnInProgress(false);
          setIsPlayerActionInProgress(false);
          setIsAnyAnimationInProgress(false);
          setSelectedLogRound(nextRoundGameData.roundNumber);
          setShowRoundEndPopup(false);
          setRoundEndData(null);
          setConfettiActive(false);
          setTimeout(() => {
            startDealingAnimation([...shuffledNewDeck], remainingPlayers, getCardsPerPlayer(remainingPlayers.length));
          }, 100);
          return nextRoundGameData;
        }
      });
    }, 10000);
  };
  const getTopMarketCardPosition = () => {
    if (!animationPositions.market) {
      const offset = window.innerWidth < 768 ? '54px' : window.innerWidth < 1024 ? '72px' : '90px';
      return {
        top: '50%',
        left: '50%',
        transform: `translate(calc(-50% + ${offset}), -50%)`
      };
    }
    const topCardIndex = Math.min(gameData?.drawPile?.length || 0, 8) - 1;
    if (topCardIndex < 0) {
      return animationPositions.market;
    }
    const cardPosition = getMarketCardPosition(topCardIndex);
    return {
      ...animationPositions.market,
      transform: `${animationPositions.market.transform} ${cardPosition.transform}`
    };
  };
  const animateDrawCards = async (gameDataToUse, player, count, isPending = false, isGeneral = false) => {
    setIsAnyAnimationInProgress(true);
    for (let i = 0; i < count; i++) {
      if (gameDataToUse.drawPile.length <= 1) {
        reshuffleMarket(gameDataToUse);
      }
      if (gameDataToUse.drawPile.length === 0) break;
      const drawnCard = gameDataToUse.drawPile[gameDataToUse.drawPile.length - 1];
      gameDataToUse.drawPile = gameDataToUse.drawPile.slice(0, -1);
      player.cards = [...player.cards, drawnCard];
      const playerActualIndex = gameDataToUse.players.findIndex(p => p.id === player.id);
      let visualPlayerIndex = playerActualIndex;
      if (currentRoom) {
        const mapping = getVisualPlayerMapping();
        visualPlayerIndex = mapping.actualToVisual[playerActualIndex] !== undefined ? mapping.actualToVisual[playerActualIndex] : playerActualIndex;
      }
      const animatingCard = {
        ...drawnCard,
        id: `draw-${Date.now()}-${i}`,
        startPos: getTopMarketCardPosition(),
        endPos: {
          ...animationPositions.drawEnds[visualPlayerIndex],
          opacity: 0
        },
        isPlayerCard: false
      };
      setAnimatingCards(prev => [...prev, animatingCard]);
      await new Promise(resolve => {
        setTimeout(() => {
          setAnimatingCards(prev => prev.filter(c => c.id !== animatingCard.id));
          resolve();
        }, 800);
      });
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    const currentUserActualIndex = currentRoom ? gameDataToUse.players.findIndex(p => p.id === currentUser?.id) : 0;
    if (player.id === currentUserActualIndex || !currentRoom && player.id === 0) {
      const newTotal = player.cards.length;
      if (newTotal > maxVisiblePlayerCards) setPlayerScrollIndex(newTotal - maxVisiblePlayerCards);
      setIsPlayerActionInProgress(false);
    }
    gameDataToUse.lastAction = isPending ? `${player.name.split(' ')[0]} - pick${count}` : isGeneral ? `${player.name.split(' ')[0]} - market` : `${player.name.split(' ')[0]} - market`;
    gameDataToUse.gameLog = {
      ...gameDataToUse.gameLog,
      [gameDataToUse.roundNumber]: [...(gameDataToUse.gameLog[gameDataToUse.roundNumber] || []), isPending ? `${player.name} drew ${count} card${count > 1 ? 's' : ''} (penalty)` : isGeneral ? `${player.name} drew ${count} card${count > 1 ? 's' : ''} (general market)` : `${player.name} drew ${count} card${count > 1 ? 's' : ''} from market`]
    };
    if (isPending) gameDataToUse.pendingPickCount = 0;
    setGameData({
      ...gameDataToUse
    });
    setIsAnyAnimationInProgress(false);
    nextTurn(gameDataToUse);
  };
  const drawCard = async () => {
    if (!gameData || gameData.currentPlayer !== 0 || animatingCards.length > 0 || isPlayerActionInProgress || isAnyAnimationInProgress) return;
    setIsPlayerActionInProgress(true);
    setIsAnyAnimationInProgress(true);
    const newGameData = {
      ...gameData
    };
    const player = newGameData.players[0];
    const count = newGameData.pendingPickCount > 0 ? newGameData.pendingPickCount : newGameData.generalMarketActive && newGameData.currentPlayer !== newGameData.generalMarketOriginatorId ? 1 : 1;
    const isPending = newGameData.pendingPickCount > 0;
    const isGeneral = newGameData.generalMarketActive && newGameData.currentPlayer !== newGameData.generalMarketOriginatorId && !isPending;
    await animateDrawCards(newGameData, player, count, isPending, isGeneral);
  };
  const reshuffleMarket = gameData => {
    if (gameData.playPile.length <= 1) return;
    const topCard = gameData.playPile[gameData.playPile.length - 1];
    const cardsToShuffle = gameData.playPile.slice(0, -1);
    gameData.drawPile = shuffleDeck(cardsToShuffle);
    gameData.playPile = [topCard];
    const topCardPosition = playPileCardPositions[gameData.playPile.length - 1] || getPlayPilePosition(0, false);
    playPilePositionsRef.current = [playPilePositionsRef.current[gameData.playPile.length - 1] || {
      transform: 'translate(0px, 0px) rotate(0deg)',
      zIndex: 30
    }];
    setPlayPileCardPositions({
      0: topCardPosition
    });
    setNeedNewMarketPositions(true);
    gameData.lastAction += ' (Market reshuffled)';
    gameData.gameLog = {
      ...gameData.gameLog,
      [gameData.roundNumber]: [...(gameData.gameLog[gameData.roundNumber] || []), 'Market deck was reshuffled from played cards']
    };
  };
  const getCardBackSVG = () => {
    return `
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
        viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
      <g>
        <path fill="#7D1228" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
          c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
        <text x="93.15" y="120" font-family="Pacifico, cursive" font-size="32px" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="middle">Whot</text>
        <text x="93.15" y="140" font-family="Pacifico, cursive" font-size="32px" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="middle" transform="rotate(180 93.15 140)">Whot</text>
      </g>
      </svg>
    `;
  };
  const getCardSVGContent = card => {
    const numberText = card.number;
    if (card.special === 'whot' || card.shape === 'ðŸ”¥') {
      const hasChosenShape = card.chosenShape;
      const firstWhotY = hasChosenShape ? "110" : "120";
      const secondWhotY = hasChosenShape ? "150" : "140";
      const chosenShapeElement = hasChosenShape ? `<text x="93.15" y="180" font-family="Helvetica, Arial, sans-serif" font-size="36px" font-weight="bold" fill="#7D1228" text-anchor="middle" dominant-baseline="middle">${card.chosenShape}</text>` : '';
      return `
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
      viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
    <g>
      <path fill="white" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
        c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
      <text transform="matrix(1 0 0 1 15.942 31.6153)" fill="#7D1228" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">20</text>
      <text transform="matrix(1 0 0 1 147.3851 236.655)" fill="#7D1228" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">20</text>
      <text x="93.15" y="${firstWhotY}" font-family="Pacifico, cursive" font-size="32px" font-weight="bold" fill="#7D1228" text-anchor="middle" dominant-baseline="middle">Whot</text>
      <text x="93.15" y="${secondWhotY}" font-family="Pacifico, cursive" font-size="32px" font-weight="bold" fill="#7D1228" text-anchor="middle" dominant-baseline="middle" transform="rotate(180 93.15 ${secondWhotY})">Whot</text>
      ${chosenShapeElement}
    </g>
    </svg>
  `;
    }
    const svgTemplates = {
      'â—': num => `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
        <g>
          <g>
            <path fill="#F4F4F2" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
              c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
          </g>
          <rect x="14.4" y="18" fill="none" width="27.8" height="27.3"/>
          <rect x="137.4" y="209.4" fill="none" width="27.8" height="27.3"/>
          <circle fill="#7D1228" cx="97.8" cy="127.8" r="57.2"/>
          <circle fill="#7D1228" cx="23.6" cy="54.5" r="9.3"/>
          <circle fill="#7D1228" cx="155.1" cy="198.2" r="9.3"/>
          <text transform="matrix(1 0 0 1 15.942 31.6153)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
          <text transform="matrix(1 0 0 1 147.3851 236.655)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
        </g>
        </svg>
      `,
      'âœš': num => `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
        <g>
          <g>
            <path fill="#F4F4F2" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
              c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
          </g>
          <rect x="14.4" y="18" fill="none" width="27.8" height="27.3"/>
          <rect x="137.4" y="209.4" fill="none" width="27.8" height="27.3"/>
          <g>
            <rect x="17.9" y="91.9" fill="#7D1228" width="153.3" height="52.3"/>
            <rect x="68.4" y="45.3" fill="#7D1228" width="52.3" height="153.3"/>
          </g>
          <g>
            <rect x="10.3" y="49.4" fill="#7D1228" width="21.3" height="7.3"/>
            <rect x="17.3" y="42.9" fill="#7D1228" width="7.3" height="21.3"/>
          </g>
          <g>
            <rect x="144.4" y="200" fill="#7D1228" width="21.3" height="7.3"/>
            <rect x="151.4" y="193.5" fill="#7D1228" width="7.3" height="21.3"/>
          </g>
          <text transform="matrix(1 0 0 1 13.2988 34.2585)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
          <text transform="matrix(1 0 0 1 147.3851 236.655)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
        </g>
        </svg>
      `,
      'â– ': num => `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
        <g>
          <g>
            <path fill="#F4F4F2" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
              c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
          </g>
          <rect x="14.4" y="18" fill="none" width="27.8" height="27.3"/>
          <rect x="137.4" y="209.4" fill="none" width="27.8" height="27.3"/>
          <rect x="33.1" y="67.9" fill="#7D1228" width="121.1" height="121.1"/>
          <rect x="11.9" y="45.3" fill="#7D1228" width="21.2" height="18.5"/>
          <rect x="144.5" y="195.5" fill="#7D1228" width="21.2" height="18.5"/>
          <text transform="matrix(1 0 0 1 13.2988 34.2585)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
          <text transform="matrix(1 0 0 1 147.3851 236.655)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
        </g>
        </svg>
      `,
      'â–²': num => `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
        <g>
          <g>
            <path fill="#F4F4F2" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
              c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
          </g>
          <rect x="14.4" y="18" fill="none" width="27.8" height="27.3"/>
          <rect x="137.4" y="209.4" fill="none" width="27.8" height="27.3"/>
          <g transform="translate(40, 75) scale(2)">
                <polygon stroke="#791026" points="25, 0, 0, 48, 50, 48" fill-opacity="null"
                    stroke-opacity="null" stroke-width="2" fill="#791026"/>
          </g>
          <g transform="translate(13, 42) scale(0.4)">
                <polygon stroke="#791026" points="25, 0, 0, 48, 50, 48" fill-opacity="null"
                    stroke-opacity="null" stroke-width="5" fill="#791026"/>
          </g>
          <g transform="translate(166.5, 210) scale(0.4) rotate(180)">
                <polygon stroke="#791026" points="25, 0, 0, 48, 50, 48" fill-opacity="null"
                    stroke-opacity="null" stroke-width="5" fill="#791026"/>
          </g>
          <text transform="matrix(1 0 0 1 13.2988 34.2585)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
          <text transform="matrix(1 0 0 1 147.3851 236.655)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
        </g>
        </svg>
      `,
      'â˜…': num => `
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          viewBox="0 0 186.3 255.5" style="enable-background:new 0 0 186.3 255.5;" xml:space="preserve">
        <g>
          <g>
            <path fill="#F4F4F2" stroke="#000000" d="M182.9,237.7c0,7.8-6.3,14.2-14.2,14.2H18.5c-7.8,0-14.2-6.3-14.2-14.2V16.6c0-7.8,6.3-14.2,14.2-14.2h150.2
              c7.8,0,14.2,6.3,14.2,14.2V237.7z"/>
          </g>
          <rect x="14.4" y="18" fill="none" width="27.8" height="27.3"/>
          <rect x="137.4" y="209.4" fill="none" width="27.8" height="27.3"/>
          <polygon fill="#7D1228" points="93.6,56.9 114.5,99.2 161.2,106 127.4,138.9 135.4,185.4 93.6,163.5 51.9,185.4 59.8,138.9 26.1,106 
            72.8,99.2 	"/>
          <polygon fill="#7D1228" points="21,37.8 24.1,44 31,45.1 26,50 27.2,56.9 21,53.6 14.8,56.9 16,50 10.9,45.1 17.9,44 	"/>
          <polygon fill="#7D1228" points="155.1,192.3 158.2,198.6 165.1,199.6 160.1,204.5 161.3,211.4 155.1,208.2 148.9,211.4 150,204.5 
            145,199.6 152,198.6 	"/>
          <text transform="matrix(1 0 0 1 13.2988 34.2585)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
          <text transform="matrix(1 0 0 1 147.3851 236.655)" fill="#791026" font-family="Helvetica, Arial, sans-serif" font-size="26.9039px">${num}</text>
        </g>
        </svg>
      `
    };
    return svgTemplates[card.shape] ? svgTemplates[card.shape](numberText) : '';
  };
  const cards = [{
    shape: 'â—',
    number: '1',
    color: '#80142c'
  }, {
    shape: 'â–²',
    number: '7',
    color: '#a01d39'
  }, {
    shape: 'âœš',
    number: '13',
    color: '#661123'
  }, {
    shape: 'â– ',
    number: '10',
    color: '#550f1e'
  }, {
    shape: 'ðŸ”¥',
    number: 'WHOT',
    color: '#4a0c1a'
  }];
  useEffect(() => {
    setIsVisible(true);
    const interval = setInterval(() => {
      setCurrentCard(prev => (prev + 1) % cards.length);
    }, 2000);
    return () => clearInterval(interval);
  }, []);
  const pageStyles = {
    landing: {
      background: '#000000'
    },
    menu: {
      background: '#000000'
    },
    game: {
      background: 'radial-gradient(ellipse at center, #1a1a1a 0%, #000000 70%)',
      perspective: '1000px'
    }
  };
  return <div className="fixed inset-0 overflow-hidden">
        <style jsx>{`
        body, html {
          margin: 0 !important;
          padding: 0 !important;
          height: 100% !important;
          overflow: hidden !important;
        }
        * {
          box-sizing: border-box;
          outline: none !important;
          border: none !important;
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        *:focus {
          outline: none !important;
          border: none !important;
        }
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        div:focus {
          outline: none !important;
          border: none !important;
        }
        button, input, select, textarea, div {
          outline: none !important;
          border: none !important;
        }
        /* Card Game Animations */
        .card-animation {
          transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
          will-change: transform, opacity;
          backface-visibility: hidden;
        }
        @keyframes cardDeal {
          from {
            transform: var(--start-transform, translate(0, 0)) translateZ(0);
            opacity: 1;
          }
          to {
            transform: var(--end-transform, translate(0, 0)) translateZ(0);
            opacity: 1;
          }
        }
        /* Page Transitions */
        .page-transition {
          transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
          transform-origin: center;
        }
        .page-enter {
          opacity: 0;
          transform: scale(0.95) translateY(20px);
        }
        .page-enter-active {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
        .page-exit {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
        .page-exit-active {
          opacity: 0;
          transform: scale(0.95) translateY(-20px);
        }
        /* Card-like transitions */
        .card-flip {
          transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
          transform-style: preserve-3d;
        }
        .card-flip:hover {
          transform: rotateY(5deg) rotateX(5deg) scale(1.05);
        }
        /* Smooth button transitions */
        button {
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
          transform: translateZ(0);
        }
        button:hover {
          transform: translateY(-2px) scale(1.02);
          filter: brightness(1.1);
        }
        button:active {
          transform: translateY(0) scale(0.98);
        }
        /* Modal/Popup card-like animations */
        .modal-enter {
          opacity: 0;
          transform: scale(0.8) rotateY(-10deg);
        }
        .modal-enter-active {
          opacity: 1;
          transform: scale(1) rotateY(0deg);
          transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .fade-in {
          animation: fadeInModal 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        .scale-in {
          animation: scaleInCard 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        @keyframes fadeInModal {
          from {
            opacity: 0;
            backdrop-filter: blur(0px);
          }
          to {
            opacity: 1;
            backdrop-filter: blur(4px);
          }
        }
        @keyframes scaleInCard {
          from {
            opacity: 0;
            transform: scale(0.8) rotateY(-15deg) rotateX(10deg);
          }
          to {
            opacity: 1;
            transform: scale(1) rotateY(0deg) rotateX(0deg);
          }
        }
        /* Card hover effects */
        .card-hover {
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          transform-style: preserve-3d;
        }
        .card-hover:hover {
          transform: translateY(-5px) rotateY(3deg) rotateX(3deg);
          box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3), 0 5px 15px rgba(128, 20, 44, 0.2);
        }
        /* Smooth state transitions */
        .smooth-transition {
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .deck-scroll-transition {
          transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        /* Interactive element enhancements */
        .interactive:hover {
          transform: translateY(-2px) scale(1.02);
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        /* Card stack effect */
        .card-stack {
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-stack:hover {
          transform: translateY(-3px) scale(1.03);
          box-shadow: 
            0 5px 15px rgba(0, 0, 0, 0.2),
            0 10px 25px rgba(128, 20, 44, 0.1),
            0 15px 35px rgba(128, 20, 44, 0.05);
        }
        /* Round end popup animations */
        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(30px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        @keyframes fadeIn {
          from {
            opacity: 0;
          }
          to {
            opacity: 1;
          }
        }
        @keyframes bounceIn {
          0% {
            opacity: 0;
            transform: scale(0.3);
          }
          50% {
            opacity: 1;
            transform: scale(1.05);
          }
          70% {
            transform: scale(0.9);
          }
          100% {
            opacity: 1;
            transform: scale(1);
          }
        }
        @keyframes scaleIn {
          0% {
            opacity: 0;
            transform: scale(0.8);
          }
          100% {
            opacity: 1;
            transform: scale(1);
          }
        }
        @keyframes progressFill {
          0% {
            width: 0%;
          }
          100% {
            width: 100%;
          }
        }
        /* Enhanced confetti and celebration effects */
        .celebration-pause {
          animation: celebrationGlow 2s ease-in-out;
        }
        @keyframes celebrationGlow {
          0%, 100% {
            filter: brightness(1);
          }
          50% {
            filter: brightness(1.3) contrast(1.1);
          }
        }
        /* Volume Slider Styles */
        .slider {
          --slider-width: 100%;
          --slider-height: 6px;
          --slider-bg: rgb(82, 82, 82);
          --slider-border-radius: 999px;
          --level-color: #80142C;
          --level-transition-duration: .1s;
          --icon-margin: 15px;
          --icon-color: var(--slider-bg);
          --icon-size: 25px;
        }
        .slider {
          cursor: pointer;
          display: inline-flex;
          flex-direction: row-reverse;
          align-items: center;
        }
        .slider .volume {
          display: inline-block;
          vertical-align: top;
          margin-right: var(--icon-margin);
          color: var(--icon-color);
          width: var(--icon-size);
          height: auto;
        }
        .slider .level {
          appearance: none;
          width: var(--slider-width);
          height: var(--slider-height);
          background: var(--slider-bg);
          overflow: hidden;
          border-radius: var(--slider-border-radius);
          transition: height var(--level-transition-duration);
          cursor: inherit;
        }
        .slider .level::-webkit-slider-thumb {
          appearance: none;
          width: 0;
          height: 0;
          box-shadow: -200px 0 0 200px var(--level-color);
        }
        .slider:hover .level {
          height: calc(var(--slider-height) * 2);
        }
        /* Custom Scrollbar Styles */
        * {
          scrollbar-width: thin;
          scrollbar-color: #80142C #2a2a2a;
        }
        /* Webkit browsers (Chrome, Safari, Edge) */
        *::-webkit-scrollbar {
          width: 6px;
          height: 6px;
        }
        *::-webkit-scrollbar-track {
          background: #1a1a1a;
          border-radius: 3px;
        }
        *::-webkit-scrollbar-thumb {
          background: linear-gradient(45deg, #80142C, #4a0c1a);
          border-radius: 3px;
          border: none;
        }
        *::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(45deg, #a01d39, #661123);
        }
        *::-webkit-scrollbar-corner {
          background: #1a1a1a;
        }
        /* Special styling for main containers */
        .overflow-y-auto::-webkit-scrollbar {
          width: 8px;
        }
        .overflow-y-auto::-webkit-scrollbar-track {
          background: rgba(26, 26, 26, 0.8);
          border-radius: 4px;
        }
        .overflow-y-auto::-webkit-scrollbar-thumb {
          background: linear-gradient(180deg, #80142C, #4a0c1a);
          border-radius: 4px;
          box-shadow: inset 0 0 2px rgba(255, 255, 255, 0.1);
        }
        .overflow-y-auto::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(180deg, #a01d39, #661123);
          box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.2);
        }
        /* Horizontal scrollbars */
        .overflow-x-auto::-webkit-scrollbar {
          height: 6px;
        }
        .overflow-x-auto::-webkit-scrollbar-track {
          background: rgba(26, 26, 26, 0.8);
          border-radius: 3px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb {
          background: linear-gradient(90deg, #80142C, #4a0c1a);
          border-radius: 3px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(90deg, #a01d39, #661123);
        }
        `}</style>
      {}
      <div className="h-screen w-full text-white relative overflow-hidden" style={pageStyles[gameState] || pageStyles.landing}>
        {gameState === 'landing' ? <div className="h-full flex flex-col relative">
              {}
              <div className="absolute top-8 left-1/2 transform -translate-x-1/2 z-10">
                <div className="relative w-80 h-32">
                  {cards.map((card, index) => <div key={index} className={`absolute w-20 h-28 rounded-lg border border-black shadow-2xl transform transition-all duration-700 ${index === currentCard ? 'scale-110 z-20 rotate-0' : 'scale-95'}`} style={{
              backgroundColor: card.color,
              left: `${104 + index * 18 + Math.sin(Date.now() * 0.001 + index) * 5}px`,
              top: `${Math.cos(Date.now() * 0.001 + index) * 3}px`,
              zIndex: index === currentCard ? 20 : 10 - index,
              opacity: index === currentCard ? 1 : 0.7,
              transform: `
                          scale(${index === currentCard ? 1.1 : 0.95}) 
                          rotate(${index === currentCard ? 0 : (index - 2) * 8}deg)
                          translateY(${Math.sin(Date.now() * 0.002 + index) * 2}px)
                        `,
              transition: 'all 0.7s ease-in-out'
            }}>
                      <div className="flex items-center justify-center w-full h-full" dangerouslySetInnerHTML={{
                __html: getCardSVGContent(card)
              }} />
                    </div>)}
                </div>
              </div>
              {}
              <div className="flex-1 flex flex-col justify-center items-center px-6 pt-32">
                <div className={`text-center transform transition-all duration-1000 ${isVisible ? 'translate-y-0 opacity-100' : 'translate-y-10 opacity-0'} max-w-6xl`}>
                  {}
                  <div className="mb-8">
                    <h1 className="text-7xl md:text-8xl font-bold mb-4 text-white relative">
                      <span className="bg-gradient-to-r from-[#80142C] via-[#a01d39] to-[#80142C] bg-clip-text text-transparent">
                        whot
                      </span>
                      <span className="text-white ml-4">Go!</span>
                      <div className="absolute -inset-1 bg-gradient-to-r from-[#80142C] to-[#4a0c1a] rounded-xl blur opacity-20"></div>
                    </h1>
                    <div className="text-[#b8869d] text-xl md:text-2xl font-medium tracking-widest">
                      â—† THE CLASSIC 4-PLAYER CARD GAME â—†
                    </div>
                  </div>
                  {}
                  <div className="mb-8 max-w-2xl mx-auto">
                    <p className="text-xl md:text-2xl mb-3 leading-relaxed text-gray-200">
                      Experience the <span className="text-[#80142C] font-bold">beloved classic</span> card game for everyone
                    </p>
                    <p className="text-base text-gray-300 leading-relaxed">
                      Strategic thinking meets fun gameplay in exciting 4-player matches with friends or AI opponents.
                    </p>
                  </div>
                  {}
                  <div className="flex flex-col items-center gap-6">
                    <div className="flex items-center gap-3">
                      <div className="h-12 flex items-center">
                        <UserButton primaryColor="#80142c" bgColor="#80142c" textColor="#ffffff" hoverBgColor="#4a0c1a" height="48px" radius="12px" />
                      </div>
                      <button onClick={() => setShowHelp(true)} className="bg-[#80142C] hover:bg-[#4a0c1a] text-white w-12 h-12 rounded-xl transition-all duration-200 border border-[#80142C] flex items-center justify-center" title="Game Help & Guide">
                        <span className="text-lg font-bold">?</span>
                      </button>
                    </div>
                    <button disabled={!userWallet || !currentUser} onClick={() => userWallet && currentUser && setGameState('menu')} className={`group relative px-12 py-4 rounded-2xl font-bold text-xl transform transition-all duration-300 overflow-hidden ${userWallet && currentUser ? 'hover:scale-105 cursor-pointer' : 'cursor-not-allowed opacity-50'}`} style={{
                background: userWallet && currentUser ? 'linear-gradient(135deg, #80142C 0%, #4a0c1a 100%)' : 'linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%)',
                color: '#ffffff',
                boxShadow: userWallet && currentUser ? '0 10px 30px rgba(128, 20, 44, 0.4), inset 0 1px 0 rgba(255,255,255,0.1)' : '0 10px 30px rgba(74, 74, 74, 0.2)'
              }} onMouseEnter={e => {
                if (userWallet && currentUser) {
                  e.target.style.background = 'linear-gradient(135deg, #a01d39 0%, #661123 100%)';
                  e.target.style.boxShadow = '0 15px 40px rgba(128, 20, 44, 0.6), inset 0 1px 0 rgba(255,255,255,0.2)';
                }
              }} onMouseLeave={e => {
                if (userWallet && currentUser) {
                  e.target.style.background = 'linear-gradient(135deg, #80142C 0%, #4a0c1a 100%)';
                  e.target.style.boxShadow = '0 10px 30px rgba(128, 20, 44, 0.4), inset 0 1px 0 rgba(255,255,255,0.1)';
                }
              }}>
                      <span className="relative z-10 flex items-center justify-center">
                        {userWallet && currentUser ? <>
                            <span>Start Playing</span>
                            <ChevronRight className="ml-3 group-hover:translate-x-1 transition-transform duration-200" size={24} />
                          </> : 'Connect Wallet to Play'}
                      </span>
                      {userWallet && currentUser && <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700"></div>}
                    </button>
                    {}
                    <p className="text-sm text-gray-400 italic max-w-md text-center">
                      Connect your wallet and start playing the classic African card game that brings families together.
                    </p>
                  </div>
                </div>
              </div>
            </div> : gameState === 'rooms' ? <div className="h-full flex flex-col relative overflow-y-auto">
              <div className="flex-1 flex flex-col justify-start items-center px-4 py-8 min-h-0">
                <div className="w-full max-w-lg md:max-w-2xl lg:max-w-4xl relative">
                  <button onClick={() => setGameState('menu')} className="absolute -top-2 left-0 text-white hover:text-gray-300 transition-all duration-300 flex items-center group">
                    <ArrowLeft size={20} className="group-hover:-translate-x-1 transition-transform duration-200" />
                  </button>
                  <div className="text-center mb-12 mt-16">
                    <h1 className="text-4xl md:text-6xl font-bold mb-4 text-white">
                      Online Multiplayer
                    </h1>
                    <div className="text-white text-lg tracking-wider">
                      Join or Create a Room
                    </div>
                  </div>
                  {}
                  <div className="mb-8">
                    <button onClick={createRoom} disabled={!currentUser} className="group w-full p-6 bg-[#80142C] transition-all duration-200 hover:bg-[#4a0c1a] rounded-xl disabled:opacity-50 disabled:cursor-not-allowed">
                      <div className="flex items-center justify-center">
                        <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg mr-4">
                          <Plus className="text-white" size={24} />
                        </div>
                        <div className="text-center">
                          <h2 className="text-2xl font-bold text-white mb-1">Create New Room</h2>
                          <p className="text-gray-200">Start your own game room</p>
                        </div>
                      </div>
                    </button>
                  </div>
                  {}
                  <div className="bg-black p-6 rounded-xl">
                    <h3 className="text-2xl font-bold text-white mb-6 flex items-center">
                      <Users className="mr-3" size={24} />
                      Available Rooms ({rooms.length})
                    </h3>
                    {rooms.length === 0 ? <div className="text-center py-8 text-gray-400">
                        <Users size={48} className="mx-auto mb-4 opacity-50" />
                        <p className="text-lg">No rooms available</p>
                        <p className="text-sm">Create a new room to get started!</p>
                      </div> : <div className="space-y-4 max-h-96 overflow-y-auto">
                        {rooms.map(room => {
                  const playerCount = Object.keys(room.players || {}).length;
                  const canJoin = playerCount < room.maxPlayers && room.status === 'waiting';
                  return <div key={room.id} className="bg-gray-800 p-4 rounded-xl flex items-center justify-between">
                              <div className="flex items-center">
                                <div className="w-12 h-12 bg-[#80142C] flex items-center justify-center rounded-lg mr-4">
                                  <Crown className="text-white" size={20} />
                                </div>
                                <div>
                                  <h4 className="text-white font-bold">{room.ownerUsername}'s Room</h4>
                                  <p className="text-gray-300 text-sm">
                                    {playerCount}/{room.maxPlayers} players
                                    {room.status === 'countdown' && ` â€¢ Starting in ${room.countdown}s`}
                                  </p>
                                </div>
                              </div>
                              <div className="flex items-center gap-2">
                                {room.status === 'countdown' && <div className="flex items-center text-yellow-400 mr-2">
                                    <Clock size={16} className="mr-1" />
                                    <span className="text-sm font-bold">{room.countdown}s</span>
                                  </div>}
                                <button onClick={() => joinRoom(room.id)} disabled={!canJoin || !currentUser} className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                                  {canJoin ? 'Join' : room.status === 'countdown' ? 'Starting' : 'Full'}
                                </button>
                              </div>
                            </div>;
                })}
                      </div>}
                  </div>
                  {!currentUser && <div className="mt-6 p-4 bg-yellow-900 bg-opacity-50 rounded-xl border border-yellow-600">
                      <p className="text-yellow-200 text-center">
                        Connect your wallet to join or create rooms
                      </p>
                    </div>}
                </div>
              </div>
            </div> : gameState === 'room' && currentRoom ? <div className="h-full flex flex-col relative overflow-y-auto">
              <div className="flex-1 flex flex-col justify-start items-center px-4 py-8 min-h-0">
                <div className="w-full max-w-lg md:max-w-2xl lg:max-w-4xl relative">
                  <button onClick={leaveRoom} className="absolute -top-2 left-0 text-white hover:text-gray-300 transition-all duration-300 flex items-center group">
                    <ArrowLeft size={20} className="group-hover:-translate-x-1 transition-transform duration-200" />
                  </button>
                  <div className="text-center mb-12 mt-16">
                    <h1 className="text-4xl md:text-6xl font-bold mb-4 text-white">
                      {currentRoom.ownerUsername}'s Room
                    </h1>
                    <div className="text-white text-lg tracking-wider">
                      {currentRoom.status === 'waiting' && 'Waiting for Players'}
                      {currentRoom.status === 'countdown' && `Starting in ${gameCountdown}s`}
                      {currentRoom.status === 'playing' && 'Game in Progress'}
                    </div>
                  </div>
                  {}
                  {currentRoom.status === 'countdown' && gameCountdown && <div className="mb-8 text-center">
                      <div className="text-6xl font-bold text-[#80142C] mb-4">{gameCountdown}</div>
                      <p className="text-xl text-white">Game starting...</p>
                    </div>}
                  {}
                  <div className="bg-black p-6 rounded-xl mb-6">
                    <h3 className="text-2xl font-bold text-white mb-6 flex items-center">
                      <Users className="mr-3" size={24} />
                      Players ({Object.keys(currentRoom.players || {}).length}/4)
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {Object.values(currentRoom.players || {}).map(player => <div key={player.id} className="bg-gray-800 p-4 rounded-xl flex items-center justify-between">
                          <div className="flex items-center">
                            <div className={`w-10 h-10 flex items-center justify-center rounded-lg mr-3 ${player.id === currentRoom.ownerId ? 'bg-yellow-600' : 'bg-gray-600'}`}>
                              {player.id === currentRoom.ownerId ? <Crown size={20} className="text-white" /> : <Users size={20} className="text-white" />}
                            </div>
                            <div>
                              <h4 className="text-white font-bold">{player.username}</h4>
                              <p className="text-gray-300 text-sm">
                                {player.id === currentRoom.ownerId ? 'Room Owner' : 'Player'}
                              </p>
                            </div>
                          </div>
                          <div className="flex items-center">
                            {player.id !== currentRoom.ownerId && <div className={`px-3 py-1 rounded-lg text-sm font-bold ${player.ready ? 'bg-green-600 text-white' : 'bg-gray-600 text-gray-300'}`}>
                                {player.ready ? 'Ready' : 'Not Ready'}
                              </div>}
                          </div>
                        </div>)}
                      {}
                      {Array.from({
                  length: 4 - Object.keys(currentRoom.players || {}).length
                }, (_, index) => <div key={`empty-${index}`} className="bg-gray-900 p-4 rounded-xl border-2 border-dashed border-gray-600 flex items-center justify-center">
                          <div className="text-gray-500 text-center">
                            <Users size={24} className="mx-auto mb-2 opacity-50" />
                            <p className="text-sm">Waiting for player...</p>
                          </div>
                        </div>)}
                    </div>
                  </div>
                  {}
                  <div className="flex gap-4 justify-center">
                    {currentUser?.id === currentRoom.ownerId ? <button onClick={startGameCountdown} disabled={Object.keys(currentRoom.players || {}).length < 2 || currentRoom.status !== 'waiting'} className="px-8 py-3 bg-green-600 text-white rounded-xl font-bold hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        Start Game
                      </button> : <button onClick={toggleReady} disabled={currentRoom.status !== 'waiting'} className={`px-8 py-3 rounded-xl font-bold transition-colors ${currentRoom.players[currentUser?.id]?.ready ? 'bg-gray-600 text-white hover:bg-gray-700' : 'bg-green-600 text-white hover:bg-green-700'} disabled:opacity-50 disabled:cursor-not-allowed`}>
                        {currentRoom.players[currentUser?.id]?.ready ? 'Not Ready' : 'Ready Up'}
                      </button>}
                    <button onClick={leaveRoom} className="px-8 py-3 bg-[#80142C] text-white rounded-xl font-bold hover:bg-[#4a0c1a] transition-colors">
                      Leave Room
                    </button>
                  </div>
                  {}
                  <div className="mt-6 text-center text-gray-400">
                    {currentUser?.id === currentRoom.ownerId && Object.keys(currentRoom.players || {}).length < 2 && <p>Need at least 2 players to start the game</p>}
                    {currentUser?.id !== currentRoom.ownerId && !currentRoom.players[currentUser?.id]?.ready && <p>Click "Ready Up" when you're ready to play</p>}
                  </div>
                </div>
              </div>
            </div> : gameState === 'menu' ? <div className="h-full flex flex-col relative overflow-y-auto">
              <div className="flex-1 flex flex-col justify-start items-center px-4 py-8 min-h-0">
                <div className="w-full max-w-lg md:max-w-2xl lg:max-w-4xl relative">
              <button onClick={() => setGameState('landing')} className="absolute -top-2 left-0 text-white hover:text-gray-300 transition-all duration-300 flex items-center group">
                    <ArrowLeft size={20} className="group-hover:-translate-x-1 transition-transform duration-200" />
                  </button>
              <div className="text-center mb-12 mt-16">
                    <h1 className="text-4xl md:text-6xl font-bold mb-4 text-white">
                      Main Menu
                    </h1>
                    <div className="text-white text-lg tracking-wider">
                      Select an Option
                    </div>
                  </div>
                  <div className="max-w-4xl mx-auto">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                      <button onClick={() => setActivePopup('battle')} className="group w-full p-8 bg-[#80142C] transition-all duration-200 hover:bg-[#4a0c1a] rounded-xl">
                        <div className="flex items-center">
                          <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                            <Play className="text-white" size={24} />
                          </div>
                          <div className="ml-6 text-left">
                            <h2 className="text-2xl font-bold text-white mb-1">Play Game</h2>
                            <p className="text-gray-200">Start a new Whot game</p>
                          </div>
                          <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                        </div>
                      </button>
                      <button onClick={() => setActivePopup('profile')} className="group w-full p-8 bg-[#80142C] transition-all duration-200 hover:bg-[#4a0c1a] rounded-xl">
                        <div className="flex items-center">
                          <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                            <Shield className="text-white" size={24} />
                          </div>
                          <div className="ml-6 text-left">
                            <h2 className="text-2xl font-bold text-white mb-1">Profile</h2>
                            <p className="text-gray-200">View your player profile</p>
                          </div>
                          <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                        </div>
                      </button>
                      <button onClick={() => setActivePopup('achievements')} className="group w-full p-8 bg-[#80142C] transition-all duration-200 hover:bg-[#4a0c1a] rounded-xl">
                        <div className="flex items-center">
                          <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                            <Award className="text-white" size={24} />
                          </div>
                          <div className="ml-6 text-left">
                            <h2 className="text-2xl font-bold text-white mb-1">Achievements</h2>
                            <p className="text-gray-200">Track your progress</p>
                          </div>
                          <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                        </div>
                      </button>
                      <button onClick={() => setActivePopup('config')} className="group w-full p-8 bg-[#80142C] transition-all duration-200 hover:bg-[#4a0c1a] rounded-xl">
                        <div className="flex items-center">
                          <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                            <Settings className="text-white" size={24} />
                          </div>
                          <div className="ml-6 text-left">
                            <h2 className="text-2xl font-bold text-white mb-1">Settings</h2>
                            <p className="text-gray-200">Adjust game preferences</p>
                          </div>
                          <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                        </div>
                      </button>
                    </div>
                    <div className="text-center">
                      <p className="text-gray-400 italic">
                        Choose an option above to get started with Whot Go!
                      </p>
                    </div>
                  </div>
                </div>
              </div>
              {}
              {activePopup && <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4" onClick={() => setActivePopup(null)}>
                  <div className="relative w-full max-w-4xl max-h-[90vh] overflow-y-auto rounded-xl" onClick={e => e.stopPropagation()}>
                    {}
                    {activePopup === 'battle' && <div className="bg-black rounded-xl">
                        <div className="p-8 bg-[#80142C] rounded-t-xl">
                          <button onClick={() => setActivePopup(null)} className="absolute top-4 right-4 text-white hover:text-gray-300 transition-all duration-300 text-2xl">Ã—</button>
                  <div className="text-center mb-10">
                            <h1 className="text-4xl font-bold mb-2 text-white">
                              Game Modes
                </h1>
                            <div className="text-gray-200 text-lg tracking-wider">
                              Select How You Want to Play
                            </div>
                          </div>
                          <div className="space-y-6 max-w-2xl mx-auto">
                            <button onClick={() => {
                    setActivePopup(null);
                    setGameState('rooms');
                  }} className="group w-full p-6 bg-black transition-all duration-200 hover:bg-gray-800 rounded-xl">
                              <div className="flex items-center">
                                <div className="w-12 h-12 bg-green-600 flex items-center justify-center rounded-lg">
                                  <Wifi className="text-white" size={24} />
                                </div>
                                <div className="ml-6 text-left">
                                  <h2 className="text-xl font-bold text-white mb-1">Online Multiplayer</h2>
                                  <p className="text-gray-200">Play with other players online</p>
                                </div>
                                <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                              </div>
                            </button>
                            <button onClick={() => {
                    setActivePopup(null);
                    setGameState('game');
                  }} className="group w-full p-6 bg-black transition-all duration-200 hover:bg-gray-800 rounded-xl">
                              <div className="flex items-center">
                                <div className="w-12 h-12 bg-black flex items-center justify-center rounded-lg">
                                  <Bot className="text-white" size={24} />
                                </div>
                                <div className="ml-6 text-left">
                                  <h2 className="text-xl font-bold text-white mb-1">Play vs AI</h2>
                                  <p className="text-gray-200">Practice against computer opponents</p>
                                </div>
                                <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                              </div>
                            </button>
                          </div>
                  <div className="mt-8 text-center">
                            <p className="text-gray-200 italic">
                              Select your preferred game mode to start playing.
                            </p>
                          </div>
                        </div>
                      </div>}
                    {}
                    {activePopup === 'profile' && <div className="bg-black rounded-xl">
                <div className="p-8 bg-[#80142C] rounded-t-xl">
                          <button onClick={() => setActivePopup(null)} className="absolute top-4 right-4 text-white hover:text-gray-300 transition-all duration-300 text-2xl">Ã—</button>
                          <div className="text-center mb-10">
                            <h1 className="text-4xl font-bold mb-2 text-white">
                              Player Profile
                            </h1>
                            <div className="text-gray-200 text-lg tracking-wider">
                              Your Game Performance
                            </div>
                          </div>
                          <div className="space-y-6 max-w-4xl mx-auto">
                            <button onClick={() => setActivePopup('leaderboards')} className="group w-full p-6 bg-black transition-all duration-200 hover:bg-gray-800 rounded-xl">
                              <div className="flex items-center">
                                <div className="w-12 h-12 bg-gray-700 flex items-center justify-center rounded-lg">
                                  <Award className="text-white" size={24} />
                                </div>
                                <div className="ml-6 text-left">
                                  <h2 className="text-xl font-bold text-white mb-1">Leaderboards</h2>
                                  <p className="text-gray-200">See top players and rankings</p>
                                </div>
                                <ChevronRight className="ml-auto text-gray-200 group-hover:translate-x-1 transition-transform duration-200" size={20} />
                              </div>
                            </button>
                            {}
                  {}
                            <div className="bg-black p-6 rounded-xl mb-6">
                              <h2 className="text-xl font-bold text-white mb-6 flex items-center">
                                <span className="w-8 h-8 bg-blue-600 flex items-center justify-center mr-3 rounded-lg text-white text-sm">
                                  ðŸ‘¤
                                </span>
                                Player Info
                              </h2>
                              <div className="flex items-center justify-between mb-4">
                                <div className="flex items-center">
                                  <span className="text-white font-medium mr-4">Username:</span>
                                  {isEditingUsername ? <div className="flex items-center gap-2">
                                      <input type="text" value={newUsername} onChange={e => setNewUsername(e.target.value)} className="bg-gray-700 text-white px-3 py-1 rounded-lg border border-gray-600 focus:border-[#80142C] outline-none" placeholder={currentUser?.username || 'Enter username'} maxLength={20} />
                                      <button onClick={() => updateUsername(newUsername)} disabled={!newUsername.trim()} className="px-3 py-1 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                                        Save
                                      </button>
                                      <button onClick={() => {
                            setIsEditingUsername(false);
                            setNewUsername('');
                          }} className="px-3 py-1 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors text-sm">
                                        Cancel
                                      </button>
                                    </div> : <div className="flex items-center">
                                      <span className="text-lg font-bold text-white mr-3">{currentUser?.username || 'Player'}</span>
                                      <button onClick={() => {
                            setIsEditingUsername(true);
                            setNewUsername(currentUser?.username || '');
                          }} className="px-3 py-1 bg-[#80142C] text-white rounded-lg hover:bg-[#4a0c1a] transition-colors text-sm">
                                        Edit
                                      </button>
                                    </div>}
                                </div>
                              </div>
                            </div>

                            {}
                            <div className="bg-black p-6 rounded-xl mb-6">
                              <h2 className="text-xl font-bold text-white mb-6 flex items-center">
                                <span className="w-8 h-8 bg-gradient-to-r from-yellow-500 to-orange-500 flex items-center justify-center mr-3 rounded-lg text-white text-sm">
                                  â­
                                </span>
                                Level Progress
                              </h2>
                              <div className="space-y-4">
                                <div className="flex items-center justify-between">
                                  <span className="text-2xl font-bold text-white">Level {playerProgress.level}</span>
                                  <span className="text-lg text-gray-300">{playerProgress.totalXP.toLocaleString()} Total XP</span>
                                </div>
                                <div className="bg-gray-700 rounded-full h-4 overflow-hidden">
                                  <div className="bg-gradient-to-r from-yellow-500 to-orange-500 h-full transition-all duration-500" style={{
                          width: playerProgress.level < 100 ? `${playerProgress.currentLevelXP / playerProgress.xpNeededForNext * 100}%` : '100%'
                        }}></div>
                                </div>
                                <div className="flex justify-between text-sm text-gray-400">
                                  <span>{playerProgress.currentLevelXP.toLocaleString()} XP</span>
                                  {playerProgress.level < 100 && <span>{playerProgress.xpNeededForNext.toLocaleString()} XP needed for Level {playerProgress.level + 1}</span>}
                                  {playerProgress.level >= 100 && <span className="text-yellow-400 font-bold">MAX LEVEL REACHED!</span>}
                                </div>
                              </div>
                            </div>
                            <div className="bg-black p-6 rounded-xl">
                              <h2 className="text-xl font-bold text-white mb-6 flex items-center">
                                <span className="w-8 h-8 bg-gray-700 flex items-center justify-center mr-3 rounded-lg">
                                  ðŸ“Š
                                </span>
                                Your Game Stats
                              </h2>
                              <div className="grid grid-cols-2 md:grid-cols-4 gap-6">
                                <div className="text-center p-4 bg-gray-800 rounded-lg">
                                  <div className="text-2xl font-bold text-white">{currentUser?.gamesPlayed || 0}</div>
                                  <div className="text-gray-200 text-sm">Games Played</div>
                                </div>
                                <div className="text-center p-4 bg-gray-800 rounded-lg">
                                  <div className="text-2xl font-bold text-white">{currentUser?.gamesWon || 0}</div>
                                  <div className="text-gray-200 text-sm">Games Won</div>
                                </div>
                                <div className="text-center p-4 bg-gray-800 rounded-lg">
                                  <div className="text-2xl font-bold text-white">{currentUser?.gamesPlayed > 0 ? ((currentUser?.gamesWon || 0) / currentUser.gamesPlayed * 100).toFixed(1) : 0}%</div>
                                  <div className="text-gray-200 text-sm">Win Rate</div>
                                </div>
                                <div className="text-center p-4 bg-gray-800 rounded-lg">
                                  <div className="text-2xl font-bold text-white">{playerProgress.level}</div>
                                  <div className="text-gray-200 text-sm">Player Level</div>
                                </div>
                              </div>
                            </div>
                          </div>
                          <div className="mt-8 text-center">
                            <p className="text-gray-200 italic">
                              Keep playing to improve your statistics and climb the leaderboards.
                            </p>
                          </div>
                        </div>
                      </div>}
                    {activePopup === 'achievements' && <div className="bg-black rounded-xl">
                <div className="p-8 bg-[#80142C] rounded-t-xl">
                          <button onClick={() => setActivePopup(null)} className="absolute top-4 right-4 text-white hover:text-gray-300 transition-all duration-300 text-2xl">Ã—</button>
                          <div className="text-center mb-10">
                            <h1 className="text-4xl font-bold mb-2 text-white">
                              Achievements & Badges
                            </h1>
                            <div className="text-gray-200 text-lg tracking-wider">
                              Track Your Progress
                            </div>
                          </div>
                          <div className="max-w-4xl mx-auto">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-96 overflow-y-auto">
                              {achievements.map(achievement => <div key={achievement.id} className={`p-4 rounded-xl border-2 ${achievement.unlocked ? achievement.claimed ? 'bg-gray-800 border-gray-600' : 'bg-[#2d5d3f] border-[#4ade80]' : 'bg-gray-900 border-gray-700 opacity-60'}`}>
                                  <div className="flex items-center mb-3">
                                    <span className="text-3xl mr-3">{achievement.icon}</span>
                                    <div className="flex-1">
                                      <h3 className="text-lg font-bold text-white">{achievement.name}</h3>
                                      <p className="text-sm text-gray-300">{achievement.description}</p>
                                    </div>
                                    {achievement.unlocked && !achievement.claimed && <div className="w-3 h-3 bg-[#80142C] rounded-full animate-pulse"></div>}
                                  </div>
                                  <div className="flex justify-between items-center">
                                    <span className="text-xs text-gray-400">{achievement.reward}</span>
                                    {achievement.unlocked && !achievement.claimed && <button onClick={() => claimAchievement(achievement.id)} className="px-3 py-1 bg-[#80142C] text-white text-xs rounded-lg hover:bg-[#4a0c1a] transition-colors">
                                        Claim
                                      </button>}
                                    {achievement.claimed && <span className="text-xs text-green-400">âœ“ Claimed</span>}
                                    {!achievement.unlocked && <span className="text-xs text-gray-500">ðŸ”’ Locked</span>}
                                  </div>
                                </div>)}
                            </div>
                          </div>
                          <div className="mt-8 text-center">
                            <p className="text-gray-200 italic">
                              Complete challenges to unlock new achievements and earn rewards!
                            </p>
                          </div>
                        </div>
                      </div>}
                    {}
                    {activePopup === 'leaderboards' && <div className="bg-black rounded-xl">
                        <div className="p-8 bg-[#80142C] rounded-t-xl">
                          <button onClick={() => setActivePopup('profile')} className="absolute top-4 left-4 text-white hover:text-gray-300 transition-all duration-300 flex items-center group">
                            <ArrowLeft size={20} className="group-hover:-translate-x-1 transition-transform duration-200" />
                          </button>
                          <button onClick={() => setActivePopup(null)} className="absolute top-4 right-4 text-white hover:text-gray-300 transition-all duration-300 text-2xl">Ã—</button>
                          <div className="text-center mb-10 mt-8">
                            <h1 className="text-4xl font-bold mb-2 text-white">
                              Leaderboards
                            </h1>
                            <div className="text-gray-200 text-lg tracking-wider">
                              Top Players
                            </div>
                          </div>
                          <div className="bg-black rounded-xl">
                            <div className="max-h-96 overflow-y-auto rounded-xl">
                              <table className="w-full text-white">
                                <thead className="sticky top-0 bg-gray-900 text-white">
                                  <tr>
                                    <th className="text-left py-4 px-4 font-bold">Rank</th>
                                    <th className="text-left py-4 px-4 font-bold">Player</th>
                                    <th className="text-left py-4 px-4 font-bold">Wins</th>
                                    <th className="text-left py-4 px-4 font-bold">Win Rate</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {leaderboardData.map((player, index) => <tr key={index} className={`border-b border-gray-600 hover:bg-gray-800 ${player.name === 'You' ? 'bg-gray-800' : ''}`}>
                                      <td className="py-4 px-4">
                                        <span className="font-bold text-lg">
                                          #{player.rank}
                                          {player.rank === 1 && <span className="ml-1">ðŸ‘‘</span>}
                                          {player.rank === 2 && <span className="ml-1">ðŸ¥ˆ</span>}
                                          {player.rank === 3 && <span className="ml-1">ðŸ¥‰</span>}
                                        </span>
                                      </td>
                                      <td className="py-4 px-4">
                                        <div>
                                          <div className={`font-bold text-lg ${player.name === 'You' ? 'text-white' : 'text-white'}`}>
                                            {player.name}
                                          </div>
                                          <div className="text-sm text-gray-200">Level {player.level}</div>
                                        </div>
                                      </td>
                                      <td className="py-4 px-4">
                                        <div className="font-bold text-xl">{player.wins}</div>
                                        <div className="text-sm text-gray-200">{player.games} battles</div>
                                      </td>
                                      <td className="py-4 px-4">
                                        <span className="font-bold text-xl">
                                          {player.winRate}%
                                        </span>
                                      </td>
                                    </tr>)}
                                </tbody>
                              </table>
                            </div>
                          </div>
                          <div className="mt-8 text-center">
                            <p className="text-gray-200 italic">
                              Compete with other players to climb the rankings and earn your place at the top.
                            </p>
                          </div>
                        </div>
                      </div>}
                    {}
                    {activePopup === 'config' && <div className="bg-black rounded-xl">
                        <div className="p-8 bg-[#80142C] rounded-t-xl">
                          <button onClick={() => setActivePopup(null)} className="absolute top-4 right-4 text-white hover:text-gray-300 transition-all duration-300 text-2xl">Ã—</button>
                          <div className="text-center mb-10">
                            <h1 className="text-4xl font-bold mb-2 text-white">
                              Settings
                            </h1>
                            <div className="text-gray-200 text-lg tracking-wider">
                              Customize Your Experience
                            </div>
                          </div>
                          <div className="max-w-2xl mx-auto space-y-6">
                            {}
                            <div className="bg-black p-6 rounded-xl">
                              <h3 className="text-xl font-bold text-white mb-6 flex items-center">
                                <span className="w-8 h-8 bg-gray-700 flex items-center justify-center mr-3 rounded-lg">
                                  ðŸ”Š
                                </span>
                                Audio Settings
                              </h3>
                              <div className="space-y-6">
                                <div className="flex justify-between items-center">
                                  <span className="text-white font-medium">Music Volume</span>
                                  <label className="slider">
                                    <input type="range" className="level" min="0" max="100" value={musicVolume} onChange={e => setMusicVolume(e.target.value)} />
                                    <svg className="volume" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                      <path d="M18.36 19.36a1 1 0 0 1-.705-1.71C19.167 16.148 20 14.142 20 12s-.833-4.148-2.345-5.65a1 1 0 1 1 1.41-1.419C20.958 6.812 22 9.322 22 12s-1.042 5.188-2.935 7.069a.997.997 0 0 1-.705.291z" />
                                      <path d="M15.53 16.53a.999.999 0 0 1-.703-1.711C15.572 14.082 16 13.054 16 12s-.428-2.082-1.173-2.819a1 1 0 1 1 1.406-1.422A6 6 0 0 1 18 12a6 6 0 0 1-1.767 4.241.996.996 0 0 1-.703.289zM12 22a1 1 0 0 1-.707-.293L6.586 17H4c-1.103 0-2-.897-2-2V9c0-1.103.897-2 2-2h2.586l4.707-4.707A.998.998 0 0 1 13 3v18a1 1 0 0 1-1 1z" />
                                    </svg>
                                  </label>
                                </div>
                                <div className="flex justify-between items-center">
                                  <span className="text-white font-medium">Sound Effects</span>
                                  <label className="slider">
                                    <input type="range" className="level" min="0" max="100" value={soundVolume} onChange={e => setSoundVolume(e.target.value)} />
                                    <svg className="volume" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                      <path d="M18.36 19.36a1 1 0 0 1-.705-1.71C19.167 16.148 20 14.142 20 12s-.833-4.148-2.345-5.65a1 1 0 1 1 1.41-1.419C20.958 6.812 22 9.322 22 12s-1.042 5.188-2.935 7.069a.997.997 0 0 1-.705.291z" />
                                      <path d="M15.53 16.53a.999.999 0 0 1-.703-1.711C15.572 14.082 16 13.054 16 12s-.428-2.082-1.173-2.819a1 1 0 1 1 1.406-1.422A6 6 0 0 1 18 12a6 6 0 0 1-1.767 4.241.996.996 0 0 1-.703.289zM12 22a1 1 0 0 1-.707-.293L6.586 17H4c-1.103 0-2-.897-2-2V9c0-1.103.897-2 2-2h2.586l4.707-4.707A.998.998 0 0 1 13 3v18a1 1 0 0 1-1 1z" />
                                    </svg>
                                  </label>
                                </div>
                              </div>
                            </div>
                            {}
                            <div className="bg-black p-6 rounded-xl">
                              <h3 className="text-xl font-bold text-white mb-6 flex items-center">
                                <span className="w-8 h-8 bg-gray-700 flex items-center justify-center mr-3 rounded-lg">
                                  ðŸ‘¤
                                </span>
                                Account Settings
                              </h3>
                              <div className="space-y-4">
                                <button className="w-full p-3 bg-gray-800 text-white rounded-xl hover:bg-gray-700 transition-colors">
                                  Clear Game History
                                </button>
                                <button className="w-full p-3 bg-[#80142C] text-white rounded-xl hover:bg-[#4a0c1a] transition-colors">
                                  Delete Account
                                </button>
                              </div>
                            </div>
                          </div>
                          <div className="mt-8 text-center">
                            <p className="text-gray-200 italic">
                              Customize your gaming experience to your preferences.
                            </p>
                          </div>
                        </div>
                      </div>}
                  </div>
                </div>}
            </div> : gameState === 'game' && gameData ? <div className="h-full relative overflow-hidden">
              {}
              <div className="fixed top-4 left-4 z-30" style={{
          position: 'fixed'
        }}>
                <button onClick={() => {
            if (currentRoom) {
              leaveRoom();
            } else {
              setGameState('menu');
            }
            setGameData(null);
            setShowWhotChoice(false);
            setPendingWhotCard(null);
            setAnimatingCards([]);
            setPlayerScrollIndex(0);
            setShowDeckView(false);
            setShowEliminatedPopup(false);
            setShowRoundEndPopup(false);
            setRoundEndData(null);
            setShowGameLog(false);
            setSelectedLogRound(1);
            setIsPlayerActionInProgress(false);
            setIsAITurnInProgress(false);
            setIsAnyAnimationInProgress(false);
            setActivePopup(null);
            setAdminCardsRevealed(false);
            setAdminMarketRevealed(false);
            setShowAdminDeckOverview(false);
            setConfettiActive(false);
            setPlayPileCardPositions({});
            marketCardPositionsRef.current = [];
            playPilePositionsRef.current = [];
            setMarketCardPositions([]);
            setPlayPilePositions([]);
            setNeedNewMarketPositions(true);
            if (confettiCanvasRef.current) {
              const ctx = confettiCanvasRef.current.getContext('2d');
              ctx.clearRect(0, 0, confettiCanvasRef.current.width, confettiCanvasRef.current.height);
            }
          }} className="text-white hover:text-red-300 transition-colors duration-200">
                  <ArrowLeft size={window.innerWidth < 768 ? 18 : 24} />
                </button>
              </div>
              {}
              
              {}
              {isAdmin && <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-30 flex gap-2" style={{
          position: 'fixed'
        }}>
                <button onClick={() => setAdminCardsRevealed(!adminCardsRevealed)} className={`px-3 py-2 text-xs rounded-lg font-bold transition-all duration-200 ${adminCardsRevealed ? 'bg-red-600 text-white' : 'bg-gray-600 text-gray-300'}`} title="Toggle opponent card visibility">
                  {adminCardsRevealed ? 'Hide Opponent Cards' : 'Reveal Opponent Cards'}
                </button>
                <button onClick={() => setAdminMarketRevealed(!adminMarketRevealed)} className={`px-3 py-2 text-xs rounded-lg font-bold transition-all duration-200 ${adminMarketRevealed ? 'bg-red-600 text-white' : 'bg-gray-600 text-gray-300'}`} title="Toggle market card visibility">
                  {adminMarketRevealed ? 'Hide Market Cards' : 'Reveal Market Cards'}
                </button>
                <button onClick={() => setShowAdminDeckOverview(true)} className="px-3 py-2 text-xs rounded-lg font-bold transition-all duration-200 bg-blue-600 text-white hover:bg-blue-700" title="View all card distributions">
                  View All Cards
                </button>
              </div>}
              <div className={`fixed top-4 right-4 z-30 text-white flex ${window.innerWidth < 768 ? 'gap-2' : 'gap-3'}`} style={{
          position: 'fixed'
        }}>
                {}
                <div className={`bg-black bg-opacity-60 ${window.innerWidth < 768 ? 'p-2' : 'p-3'} rounded-xl border border-gray-600 flex items-center justify-center ${window.innerWidth < 768 ? 'min-w-[40px]' : 'min-w-[60px]'}`}>
                  <div className={`${window.innerWidth < 768 ? 'text-lg' : 'text-2xl'} font-bold`}>
                    {(() => {
                if (gameData.playPile.length === 0) return '?';
                const topCard = gameData.playPile[gameData.playPile.length - 1];
                if (!topCard) return '?';
                if (topCard.chosenShape) {
                  return topCard.chosenShape;
                }
                return topCard.shape === 'ðŸ”¥' ? '?' : topCard.shape;
              })()}
                  </div>
                </div>
                {}
            <button onClick={() => setShowGameLog(true)} className={`bg-black bg-opacity-60 ${window.innerWidth < 768 ? 'p-2' : 'p-3'} rounded-xl border border-gray-600 hover:bg-opacity-80 transition-all duration-200 cursor-pointer`} title="Click to view game log">
                <div className={`${window.innerWidth < 768 ? 'text-xs' : 'text-sm'}`}>
                  {window.innerWidth < 768 ? `R${gameData.roundNumber}` : `Round ${gameData.roundNumber}`}
                </div>
                <div className={`${window.innerWidth < 768 ? 'text-[10px]' : 'text-xs'} text-gray-400`}>
                  {gameData.lastAction}
                </div>
                {gameData.generalMarketActive && <div className={`${window.innerWidth < 768 ? 'text-[10px]' : 'text-xs'} text-yellow-400 mt-1`}>
                  General Market Active
                </div>}
              </button>
              </div>
              {}
              <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-20" style={{
          transform: `translate(calc(-50% - ${window.innerWidth < 768 ? '54px' : window.innerWidth < 1024 ? '72px' : '90px'}), -50%)`
        }}>
                <div className={`relative ${window.innerWidth < 768 ? 'w-[72px] h-[100px]' : window.innerWidth < 1024 ? 'w-[100px] h-36' : 'w-[130px] h-[172px]'}`}>
                  {gameData.playPile.length > 0 ? <>
                      {gameData.playPile.map((card, cardIndex) => {
                const position = playPileCardPositions[cardIndex] || getPlayPilePosition(cardIndex, false);
                return <div key={`pile-${card.id}-${cardIndex}`} className={`absolute ${window.innerWidth < 768 ? 'w-[72px] h-[100px]' : window.innerWidth < 1024 ? 'w-[100px] h-36' : 'w-[130px] h-[172px]'} rounded-lg shadow-2xl`} style={{
                  transform: position.transform || 'translateZ(0)',
                  zIndex: position.zIndex || 30 + cardIndex,
                  top: '0px',
                  left: '0px',
                  position: 'absolute'
                }}>
                            <div className="h-full flex flex-col items-center justify-center text-white font-bold">
                              <div className="flex items-center justify-center w-full h-full" dangerouslySetInnerHTML={{
                      __html: getCardSVGContent(card)
                    }} />
                            </div>
                          </div>;
              })}
                    </> : <div className="h-full flex items-center justify-center border-2 border-dashed border-gray-600 rounded-xl">
                      <div className="text-gray-500 text-xs text-center">
                        Play<br />Pile
                      </div>
                    </div>}
                </div>
              </div>
              {}
              <div className="absolute top-1/2 left-1/2 transform -translate-y-1/2 z-20" style={{
          transform: `translate(calc(-50% + ${window.innerWidth < 768 ? '54px' : window.innerWidth < 1024 ? '72px' : '90px'}), -50%)`
        }}>
                <div className={`relative ${window.innerWidth < 768 ? 'w-[72px] h-[100px]' : window.innerWidth < 1024 ? 'w-[100px] h-36' : 'w-[130px] h-[172px]'} ${(() => {
            const currentUserActualIndex = currentRoom ? gameData.players.findIndex(p => p.id === currentUser?.id) : 0;
            const isCurrentUserTurn = gameData.currentPlayer === currentUserActualIndex;
            const shouldGlow = !isAnyAnimationInProgress && isCurrentUserTurn && (gameData.pendingPickCount > 0 || gameData.generalMarketActive && gameData.currentPlayer !== gameData.generalMarketOriginatorId || gameData.pendingPickCount === 0 && !gameData.generalMarketActive && (() => {
              const currentUserPlayer = gameData.players[currentUserActualIndex];
              if (!currentUserPlayer) return false;
              const topCard = gameData.playPile[gameData.playPile.length - 1];
              if (!topCard) return false;
              const playableCards = currentUserPlayer.cards.filter(card => {
                if (topCard && topCard.chosenShape) {
                  return card.special === 'whot' || card.shape === topCard.chosenShape;
                }
                return canPlayCard(card, topCard);
              });
              return playableCards.length === 0;
            })());
            return shouldGlow ? 'animate-pulse' : '';
          })()}`} style={{
            filter: (() => {
              const currentUserActualIndex = currentRoom ? gameData.players.findIndex(p => p.id === currentUser?.id) : 0;
              const isCurrentUserTurn = gameData.currentPlayer === currentUserActualIndex;
              const shouldGlow = isCurrentUserTurn && (gameData.pendingPickCount > 0 || gameData.generalMarketActive && gameData.currentPlayer !== gameData.generalMarketOriginatorId || gameData.pendingPickCount === 0 && !gameData.generalMarketActive && (() => {
                const currentUserPlayer = gameData.players[currentUserActualIndex];
                if (!currentUserPlayer) return false;
                const topCard = gameData.playPile[gameData.playPile.length - 1];
                if (!topCard) return false;
                const playableCards = currentUserPlayer.cards.filter(card => {
                  if (topCard && topCard.chosenShape) {
                    return card.special === 'whot' || card.shape === topCard.chosenShape;
                  }
                  return canPlayCard(card, topCard);
                });
                return playableCards.length === 0;
              })());
              return shouldGlow ? 'drop-shadow(0 0 15px rgba(239, 68, 68, 0.8)) drop-shadow(0 0 25px rgba(239, 68, 68, 0.4))' : 'none';
            })()
          }}>
                  {}
                  {Array.from({
              length: Math.min(gameData.drawPile.length, 8)
            }, (_, index) => <div key={index} className={`absolute ${window.innerWidth < 768 ? 'w-[72px] h-[100px]' : window.innerWidth < 1024 ? 'w-[100px] h-36' : 'w-[130px] h-[172px]'} rounded-lg shadow-2xl ${index === Math.min(gameData.drawPile.length, 8) - 1 && animatingCards.length === 0 && !isPlayerActionInProgress ? 'hover:scale-105 cursor-pointer' : ''}`} style={{
              ...getMarketCardPosition(index)
            }} onClick={index === Math.min(gameData.drawPile.length, 8) - 1 && animatingCards.length === 0 && !isPlayerActionInProgress && !isAnyAnimationInProgress ? currentRoom ? drawMultiplayerCard : drawCard : undefined}>
                      <div className="h-full w-full" dangerouslySetInnerHTML={{
                __html: isAdmin && adminMarketRevealed && gameData.drawPile[gameData.drawPile.length - 1 - index] ? getCardSVGContent(gameData.drawPile[gameData.drawPile.length - 1 - index]) : getCardBackSVG()
              }} />
                    </div>)}
                  {}
                  {gameData.drawPile.length === 0 && <div className={`${window.innerWidth < 768 ? 'w-[72px] h-[100px]' : window.innerWidth < 1024 ? 'w-[100px] h-36' : 'w-[130px] h-[172px]'} rounded-xl border-2 border-dashed border-gray-600 flex items-center justify-center text-gray-500 text-xs`}>
                      Empty
                    </div>}
                </div>
              </div>
              {}
              {}
              {(roundEndData || gameData.roundEndData) && !showRoundEndPopup && gameData.gamePhase === 'roundEnd' && <div className="absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-[95] celebration-pause">
                  <div className="text-center text-white">
                    <div className="text-6xl mb-4">ðŸŽ‰</div>
                    <h2 className="text-3xl font-bold mb-2">Round Complete!</h2>
                    <p className="text-xl text-gray-200">Preparing results...</p>
                  </div>
                </div>}
              {}
              {animatingCards.map(card => {
          const initialStyle = {
            transform: card.startPos.transform || 'translateZ(0)',
            opacity: card.startPos.opacity !== undefined ? card.startPos.opacity : 1,
            zIndex: 70
          };
          if (card.startPos.top !== undefined) {
            initialStyle.top = card.startPos.top;
            initialStyle.bottom = 'auto';
          } else if (card.startPos.bottom !== undefined) {
            initialStyle.bottom = card.startPos.bottom;
            initialStyle.top = 'auto';
          } else {
            initialStyle.top = 'auto';
            initialStyle.bottom = 'auto';
          }
          if (card.startPos.left !== undefined) {
            initialStyle.left = card.startPos.left;
            initialStyle.right = 'auto';
          } else if (card.startPos.right !== undefined) {
            initialStyle.right = card.startPos.right;
            initialStyle.left = 'auto';
          } else {
            initialStyle.left = 'auto';
            initialStyle.right = 'auto';
          }
          return <div key={card.id} className={`fixed ${window.innerWidth < 768 ? 'w-[72px] h-[100px]' : window.innerWidth < 1024 ? 'w-[100px] h-36' : 'w-[130px] h-[172px]'} rounded-lg shadow-2xl card-animation`} style={initialStyle} ref={el => {
            if (el) {
              requestAnimationFrame(() => {
                el.style.transform = card.endPos.transform || 'translateZ(0)';
                el.style.opacity = card.endPos.opacity !== undefined ? card.endPos.opacity : 1;
                el.style.top = '';
                el.style.bottom = '';
                el.style.left = '';
                el.style.right = '';
                if (card.endPos.top !== undefined) {
                  el.style.top = card.endPos.top;
                  el.style.bottom = 'auto';
                } else if (card.endPos.bottom !== undefined) {
                  el.style.bottom = card.endPos.bottom;
                  el.style.top = 'auto';
                } else {
                  el.style.top = 'auto';
                  el.style.bottom = 'auto';
                }
                if (card.endPos.left !== undefined) {
                  el.style.left = card.endPos.left;
                  el.style.right = 'auto';
                } else if (card.endPos.right !== undefined) {
                  el.style.right = card.endPos.right;
                  el.style.left = 'auto';
                } else {
                  el.style.left = 'auto';
                  el.style.right = 'auto';
                }
              });
            }
          }}>
                    <div className="h-full flex flex-col items-center justify-center text-white font-bold">
                      <div className="flex items-center justify-center w-full h-full" dangerouslySetInnerHTML={{
                __html: card.isPlayerCard ? getCardSVGContent(card) : getCardBackSVG()
              }} />
                    </div>
                  </div>;
        })}
              {}
              {(() => {
          const currentUserActualIndex = currentRoom ? gameData.players.findIndex(p => p.id === currentUser?.id) : 0;
          const isCurrentUserTurn = gameData.currentPlayer === currentUserActualIndex;
          return gameData.players.map((player, playerIndex) => {
            const mapping = getVisualPlayerMapping();
            const visualPlayerIndex = currentRoom ? mapping.actualToVisual[playerIndex] !== undefined ? mapping.actualToVisual[playerIndex] : playerIndex : playerIndex;
            const isCurrentPlayer = !isAnyAnimationInProgress && gameData.currentPlayer === playerIndex;
            const pos = animationPositions.playerDecks[visualPlayerIndex];
            const maxVisibleCards = visualPlayerIndex === 0 ? maxVisiblePlayerCards : 3;
            const cardSpacing = 6;
            const isCurrentUserPlayer = currentRoom ? playerIndex === currentUserActualIndex : playerIndex === 0;
            const visibleCards = isCurrentUserPlayer ? player.cards.slice(playerScrollIndex, playerScrollIndex + maxVisibleCards) : player.cards.slice(0, maxVisibleCards);
            const cardDimensions = window.innerWidth < 768 ? 'w-[72px] h-[100px]' : window.innerWidth < 1024 ? 'w-[100px] h-36' : 'w-[130px] h-[172px]';
            const topCard = gameData.playPile[gameData.playPile.length - 1];
            const canPlayerPlay = !isAnyAnimationInProgress && gameData.currentPlayer === playerIndex && !isPlayerActionInProgress;
            const playableOutsideRange = isCurrentUserPlayer ? hasPlayableCardsOutsideRange() : {
              left: false,
              right: false
            };
            return <div key={player.id} className={`absolute ${isCurrentPlayer ? 'z-20' : 'z-10'}`} style={{
              ...pos,
              filter: isCurrentPlayer ? 'brightness(1.2)' : 'brightness(0.8)'
            }}>
                    {player.eliminated ? <div className={`flex flex-col items-center justify-center h-full text-white bg-black bg-opacity-50 rounded-xl p-4 ${window.innerWidth < 768 ? 'w-[200px]' : 'w-[300px]'}`} style={{
                transform: visualPlayerIndex === 1 ? 'translateX(-60px)' : visualPlayerIndex === 3 ? 'translateX(60px)' : 'none'
              }}>
                        <Shield size={window.innerWidth < 768 ? 32 : 48} className="text-red-500 mb-2" />
                        <h3 className={`${window.innerWidth < 768 ? 'text-lg' : 'text-xl'} font-bold text-red-400`}>ELIMINATED</h3>
                      </div> : <>
                    <div className={`flex items-center player-cards-container deck-scroll-transition ${visualPlayerIndex === 0 ? 'smooth-transition' : ''}`} style={{
                  gap: `${cardSpacing}px`,
                  width: visualPlayerIndex !== 0 ? `${(MAX_VISIBLE_AI_CARDS + 1) * (window.innerWidth < 768 ? 72 : window.innerWidth < 1024 ? 100 : 130) + MAX_VISIBLE_AI_CARDS * cardSpacing}px` : 'auto',
                  height: visualPlayerIndex !== 0 ? `${window.innerWidth < 768 ? 100 : window.innerWidth < 1024 ? 144 : 172}px` : 'auto'
                }}>
                      {}
                      {isCurrentUserPlayer && <button onClick={() => playerScrollIndex > 0 && scrollPlayerCards('left')} disabled={playerScrollIndex <= 0} className={`${window.innerWidth < 768 ? 'w-8 h-12' : 'w-10 h-14'} ${playerScrollIndex > 0 ? 'bg-gradient-to-r from-[#80142C] to-[#4a0c1a]' : 'bg-gradient-to-r from-gray-700 to-gray-600'} rounded-xl flex flex-col items-center justify-center text-white smooth-transition z-30 mr-2 shadow-lg border-2 ${playerScrollIndex > 0 ? 'border-[#80142C]' : 'border-gray-500'} relative ${playerScrollIndex <= 0 ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}>
                          {playableOutsideRange.left && playerScrollIndex > 0 && <div className="absolute top-1 right-1 w-3 h-3 bg-[#80142C] rounded-full border-2 border-gray-900 animate-ping"></div>}
                          {playableOutsideRange.left && playerScrollIndex > 0 && <div className="absolute top-1 right-1 w-3 h-3 bg-[#80142C] rounded-full border-2 border-gray-900"></div>}
                          <ChevronLeft size={window.innerWidth < 768 ? 12 : 16} />
                          <span className={`${window.innerWidth < 768 ? 'text-[8px]' : 'text-[10px]'} font-bold`}>{playerScrollIndex}</span>
                        </button>}
                      {visibleCards.map((card, cardIndex) => {
                    const canPlayAnyCard = isCurrentUserPlayer && isCurrentUserTurn && canPlayerPlay && gameData.pendingPickCount === 0 && !(gameData.generalMarketActive && gameData.currentPlayer !== gameData.generalMarketOriginatorId) && !isAnyAnimationInProgress;
                    const isThisCardPlayable = canPlayAnyCard && isCardPlayable(card, topCard);
                    return <div key={`${card.id}-${cardIndex}`} className={`${cardDimensions} rounded-lg shadow-lg smooth-transition ${isThisCardPlayable ? 'cursor-pointer' : ''}`} style={{
                      backgroundColor: isCurrentUserPlayer ? 'transparent' : '#2a2a2a',
                      zIndex: cardIndex,
                      transform: 'none',
                      opacity: isCurrentUserPlayer ? isThisCardPlayable || !canPlayAnyCard ? 1 : 0.4 : 1
                    }} onClick={() => {
                      if (isThisCardPlayable && isCurrentUserPlayer && isCurrentUserTurn) {
                        if (currentRoom) {
                          playMultiplayerCard(cardIndex);
                        } else {
                          playCard(cardIndex);
                        }
                      }
                    }}>
                            {isCurrentUserPlayer ? <div className="h-full flex flex-col items-center justify-center text-white font-bold relative">
                                <div className="flex items-center justify-center w-full h-full" dangerouslySetInnerHTML={{
                          __html: getCardSVGContent(card)
                        }} />
                                {card.special && <div className="absolute bottom-1 text-xs bg-black bg-opacity-70 px-1 rounded">
                                    {card.special === 'holdon' && 'HOLD'}
                                    {card.special === 'pick2' && 'P2'}
                                    {card.special === 'generalmarket' && 'GM'}
                                    {card.special === 'whot' && 'WHOT'}
                                  </div>}
                              </div> : <div className="h-full flex items-center justify-center">
                                <div className="flex items-center justify-center w-full h-full" dangerouslySetInnerHTML={{
                          __html: isAdmin && adminCardsRevealed ? getCardSVGContent(card) : getCardBackSVG()
                        }} />
                              </div>}
                          </div>;
                  })}
                      {}
                      {visualPlayerIndex !== 0 && <div className={`${cardDimensions} rounded-xl bg-gray-700 shadow-lg flex items-center justify-center text-gray-400 text-sm font-bold`} style={{
                    zIndex: maxVisibleCards + 1,
                    opacity: player.cards.length > maxVisibleCards ? 1 : 0,
                    transition: 'opacity 0.3s ease-in-out'
                  }}>
                          +{Math.max(0, player.cards.length - maxVisibleCards)}
                        </div>}
                      {}
                      {isCurrentUserPlayer && <button onClick={() => player.cards.length > maxVisiblePlayerCards && playerScrollIndex < player.cards.length - maxVisiblePlayerCards && scrollPlayerCards('right')} disabled={!(player.cards.length > maxVisiblePlayerCards && playerScrollIndex < player.cards.length - maxVisiblePlayerCards)} className={`${window.innerWidth < 768 ? 'w-8 h-12' : 'w-10 h-14'} ${player.cards.length > maxVisiblePlayerCards && playerScrollIndex < player.cards.length - maxVisiblePlayerCards ? 'bg-gradient-to-r from-[#80142C] to-[#4a0c1a]' : 'bg-gradient-to-r from-gray-700 to-gray-600'} rounded-xl flex flex-col items-center justify-center text-white smooth-transition z-30 ml-2 shadow-lg border-2 ${player.cards.length > maxVisiblePlayerCards && playerScrollIndex < player.cards.length - maxVisiblePlayerCards ? 'border-[#80142C]' : 'border-gray-500'} relative ${!(player.cards.length > maxVisiblePlayerCards && playerScrollIndex < player.cards.length - maxVisiblePlayerCards) ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}>
                          {playableOutsideRange.right && player.cards.length > maxVisiblePlayerCards && playerScrollIndex < player.cards.length - maxVisiblePlayerCards && <div className="absolute top-1 right-1 w-3 h-3 bg-[#80142C] rounded-full border-2 border-gray-900 animate-ping"></div>}
                          {playableOutsideRange.right && player.cards.length > maxVisiblePlayerCards && playerScrollIndex < player.cards.length - maxVisiblePlayerCards && <div className="absolute top-1 right-1 w-3 h-3 bg-[#80142C] rounded-full border-2 border-gray-900"></div>}
                          <ChevronRightIcon size={window.innerWidth < 768 ? 12 : 16} />
                          <span className={`${window.innerWidth < 768 ? 'text-[8px]' : 'text-[10px]'} font-bold`}>{Math.max(0, player.cards.length - (playerScrollIndex + maxVisiblePlayerCards))}</span>
                        </button>}
                    </div>
                    {}
                <div className={`text-white ${window.innerWidth < 768 ? 'text-xs' : 'text-sm'} mt-1 font-bold ${isCurrentPlayer ? 'text-[#b8869d]' : ''} flex items-center justify-center`} style={{
                  textAlign: visualPlayerIndex === 1 ? 'left' : visualPlayerIndex === 3 ? 'right' : 'center'
                }}>
                      <span>{window.innerWidth < 768 ? `${player.name.split(' ')[0]} (${player.cards.length})` : `${player.name} (${player.cards.length})`}</span>
                      {isCurrentUserPlayer && <button onClick={() => setShowDeckView(true)} className={`ml-2 ${window.innerWidth < 768 ? 'w-4 h-4' : 'w-5 h-5'} bg-gray-700 rounded-full flex items-center justify-center text-white smooth-transition shadow-sm rounded-full`} title="View Full Deck">
                          <Grid3X3 size={window.innerWidth < 768 ? 8 : 10} />
                        </button>}
                      {}
                      {currentRoom && isCurrentUserTurn && playerIndex === currentUserActualIndex && !isAnyAnimationInProgress && <div className={`ml-2 flex items-center ${window.innerWidth < 768 ? 'text-[10px]' : 'text-xs'}`}>
                          <span className="text-[#80142C] font-bold">{window.innerWidth < 768 ? 'â—' : 'Your Turn'}</span>
                          {turnTimer !== null && <div className="ml-2 flex items-center text-yellow-400">
                              <Clock size={12} className="mr-1" />
                              <span className="font-bold">{turnTimer}s</span>
                            </div>}
                        </div>}
                      {}
                      {!currentRoom && isCurrentPlayer && playerIndex === 0 && !isAnyAnimationInProgress && <span className={`ml-1 ${window.innerWidth < 768 ? 'text-[10px]' : 'text-xs'} text-[#80142C] font-bold`}>{window.innerWidth < 768 ? 'â—' : 'Your Turn'}</span>}
                      {isAnyAnimationInProgress && gameData.currentPlayer === playerIndex && <span className={`ml-1 ${window.innerWidth < 768 ? 'text-[10px]' : 'text-xs'} text-yellow-400`}>{window.innerWidth < 768 ? 'â¸' : '(Wait...)'}</span>}
                      {isCurrentUserPlayer && gameData.generalMarketActive && gameData.currentPlayer !== gameData.generalMarketOriginatorId && <span className={`ml-1 ${window.innerWidth < 768 ? 'text-[8px]' : 'text-[10px]'} text-yellow-300`}>(General Market Active)</span>}
                      {player.cards.length === 1 && <span className={`ml-1 ${window.innerWidth < 768 ? 'text-[10px]' : 'text-xs'} text-yellow-300`}>{window.innerWidth < 768 ? '!' : '(Last Card!)'}</span>}
                    </div>
                    </>}
                  </div>;
          });
        })()}
              {}
              {showEliminatedPopup && <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[100] fade-in">
                  <div className="text-center text-white scale-in bg-black p-8 rounded-2xl border-2 border-[#80142C]">
                    <div className="bg-[#80142C] p-6 rounded-xl">
                    <h1 className="text-4xl font-bold mb-4 text-white">ELIMINATED</h1>
                    <p className="text-xl mb-6">You have been knocked out of the game.</p>
                    <div className="flex gap-4">
                        <button onClick={() => setShowEliminatedPopup(false)} className="px-8 py-3 bg-[#80142C] text-white rounded-xl smooth-transition font-bold hover:bg-[#4a0c1a]">
                          Continue Watching
                        </button>
                        <button onClick={() => {
                  setGameState('menu');
                  setGameData(null);
                  setShowWhotChoice(false);
                  setPendingWhotCard(null);
                  setAnimatingCards([]);
                  setPlayerScrollIndex(0);
                  setShowDeckView(false);
                  setShowEliminatedPopup(false);
                  setShowRoundEndPopup(false);
                  setRoundEndData(null);
                  setShowGameLog(false);
                  setSelectedLogRound(1);
                  setIsPlayerActionInProgress(false);
                  setIsAITurnInProgress(false);
                  setIsAnyAnimationInProgress(false);
                  setActivePopup(null);
                  setAdminCardsRevealed(false);
                  setAdminMarketRevealed(false);
                  setShowAdminDeckOverview(false);
                  setConfettiActive(false);
                  setPlayPileCardPositions({});
                  marketCardPositionsRef.current = [];
                  playPilePositionsRef.current = [];
                  setMarketCardPositions([]);
                  setPlayPilePositions([]);
                  setNeedNewMarketPositions(false);
                }} className="px-8 py-3 bg-gray-700 text-white rounded-xl smooth-transition font-bold hover:bg-gray-600">
                          Return to Arena
                        </button>
                      </div>
                    </div>
                  </div>
                </div>}
              {}
              {showWhotChoice && <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[100] fade-in">
                  <div className="bg-black p-8 rounded-2xl border-2 border-[#80142C] text-center scale-in">
                    <div className="bg-[#80142C] p-6 rounded-xl">
                    <h2 className="text-2xl font-bold text-white mb-6">Choose WHOT Shape</h2>
                    <div className="flex gap-4 justify-center">
                        {['â—', 'â–²', 'âœš', 'â– ', 'â˜…'].map(shape => <button key={shape} onClick={() => chooseWhotShape(shape)} className="w-16 h-20 rounded-xl bg-[#80142C] smooth-transition flex items-center justify-center text-white text-3xl font-bold cursor-pointer hover:bg-[#4a0c1a]">
                            {shape}
                          </button>)}
                      </div>
                    </div>
                  </div>
                </div>}
              {}
              {showDeckView && <div className="absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[100] fade-in">
            <div className="bg-black p-6 rounded-2xl border-2 border-[#80142C] max-w-4xl max-h-[80vh] overflow-y-auto scale-in">
                    <div className="bg-[#80142C] p-4 rounded-xl">
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="text-2xl font-bold text-white">Your Full Deck ({gameData.players[0].cards.length} cards)</h2>
                      <button onClick={() => setShowDeckView(false)} className="text-white smooth-transition">
                        <Shield size={24} className="rotate-45" />
                      </button>
                    </div>
                    <div className="grid grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-3">
                      {gameData.players[0].cards.map((card, index) => {
                  const canPlayAnyCard = gameData.currentPlayer === 0 && gameData.pendingPickCount === 0 && !(gameData.generalMarketActive && gameData.currentPlayer !== gameData.generalMarketOriginatorId) && !isPlayerActionInProgress;
                  const topCard = gameData.playPile[gameData.playPile.length - 1];
                  const isPlayable = canPlayAnyCard && isCardPlayable(card, topCard);
                  return <div key={`deck-${card.id}-${index}`} className={`w-16 h-22 rounded-xl shadow-lg smooth-transition ${isPlayable ? 'cursor-pointer border-2 border-[#80142C]' : 'opacity-60'}`} onClick={() => {
                    if (isPlayable) {
                      const actualIndex = index - playerScrollIndex;
                      if (actualIndex >= 0 && actualIndex < maxVisiblePlayerCards) {
                        playCard(actualIndex);
                      } else {
                        setPlayerScrollIndex(Math.max(0, Math.min(index - Math.floor(maxVisiblePlayerCards / 2), gameData.players[0].cards.length - maxVisiblePlayerCards)));
                        setTimeout(() => {
                          const newIndex = index - Math.max(0, Math.min(index - Math.floor(maxVisiblePlayerCards / 2), gameData.players[0].cards.length - maxVisiblePlayerCards));
                          playCard(newIndex);
                        }, 100);
                      }
                      setShowDeckView(false);
                    }
                  }}>
                            <div className="h-full flex flex-col items-center justify-center text-white font-bold relative">
                              <div className="flex items-center justify-center w-full h-full text-xs" dangerouslySetInnerHTML={{
                        __html: getCardSVGContent(card)
                      }} />
                              {card.special && <div className="absolute bottom-0 text-[8px] bg-black bg-opacity-70 px-1 rounded">
                                  {card.special === 'holdon' && 'HOLD'}
                                  {card.special === 'pick2' && 'P2'}
                                  {card.special === 'generalmarket' && 'GM'}
                                  {card.special === 'whot' && 'WHOT'}
                                </div>}
                              {isPlayable && <div className="absolute top-0 right-0 w-2 h-2 bg-[#80142C] rounded-full"></div>}
                            </div>
                          </div>;
                })}
                    </div>
                    <div className="mt-4 text-center">
                        <button onClick={() => setShowDeckView(false)} className="px-6 py-2 bg-[#80142C] text-white rounded-xl smooth-transition font-bold hover:bg-[#4a0c1a]">
                          Close
                        </button>
                      </div>
                    </div>
                  </div>
                </div>}
              {}
        {}
              {confettiActive && <canvas ref={confettiCanvasRef} className="fixed inset-0 pointer-events-none z-[110]" style={{
          width: '100vw',
          height: '100vh'
        }} />}
              {showRoundEndPopup && (roundEndData || gameData.roundEndData) && <div className="absolute inset-0 bg-black bg-opacity-95 flex items-center justify-center z-[100] opacity-0" style={{
          animation: 'fadeIn 0.6s ease-out forwards'
        }}>
                  <div className="bg-black p-8 rounded-2xl border-2 border-[#80142C] max-w-6xl max-h-[90vh] overflow-y-auto opacity-0 transform scale-95" style={{
            animation: 'scaleInCard 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s forwards'
          }}>
                    <div className="bg-[#80142C] p-6 rounded-xl">
                      {}
                      <div className="text-center mb-8 opacity-0 transform translateY-8" style={{
                animation: 'fadeInUp 0.8s ease-out 1s forwards'
              }}>
                        <h1 className="text-4xl font-bold text-white mb-2">Round {(roundEndData || gameData.roundEndData)?.roundNumber} Complete!</h1>
                        <div className="text-xl text-gray-200">
                          ðŸ† {(roundEndData || gameData.roundEndData)?.winner.name} wins the round!
                        </div>
                      </div>
                      {}
                      <div className="space-y-4 mb-8">
                        {(roundEndData || gameData.roundEndData)?.players.map((player, index) => {
                  const data = roundEndData || gameData.roundEndData;
                  const isEliminated = player.id === data.eliminatedPlayer.id;
                  const baseDelay = 1.8 + index * 0.4;
                  return <div key={player.id} className={`bg-gray-800 p-4 rounded-xl flex flex-col space-y-3 opacity-0 transform translateY-4 ${isEliminated ? 'border-2 border-red-500' : ''}`} style={{
                    animation: `fadeInUp 0.6s ease-out ${baseDelay}s forwards`
                  }}>
                              <div className="flex items-center justify-between">
                                <span className="text-lg font-bold text-white opacity-0" style={{
                        animation: `fadeIn 0.4s ease-out ${baseDelay + 0.2}s forwards`
                      }}>{player.name}</span>
                                <div className="flex items-center">
                                  <div className="text-right mr-4">
                                    <div className="text-sm text-gray-400 opacity-0" style={{
                            animation: `fadeIn 0.4s ease-out ${baseDelay + 0.25}s forwards`
                          }}>Card Total:</div>
                                    <span className={`text-3xl font-bold opacity-0 ${player.cardTotal === data.maxCards ? 'text-red-400' : 'text-green-400'}`} style={{
                            animation: `bounceIn 0.6s ease-out ${baseDelay + 0.4}s forwards`
                          }}>
                                      {player.cardTotal}
                                    </span>
                                  </div>
                                  <div className="text-right">
                                    <div className="text-sm text-gray-400 opacity-0" style={{
                            animation: `fadeIn 0.4s ease-out ${baseDelay + 0.3}s forwards`
                          }}>Cards:</div>
                                    <span className="text-xl font-bold text-white opacity-0" style={{
                            animation: `fadeIn 0.4s ease-out ${baseDelay + 0.35}s forwards`
                          }}>
                                      {player.cardCount}
                                    </span>
                                  </div>
                                  {isEliminated && <div className="ml-4 text-4xl opacity-0" style={{
                          animation: `bounceIn 0.8s ease-out ${baseDelay + 1.2}s forwards`
                        }}>
                                      âŒ
                                    </div>}
                                </div>
                              </div>
                              {}
                              <div className="flex items-center flex-wrap gap-2 mt-3">
                                <span className="text-sm text-gray-400 opacity-0" style={{
                        animation: `fadeIn 0.4s ease-out ${baseDelay + 0.6}s forwards`
                      }}>Remaining cards:</span>
                                {player.cards.map((card, cardIndex) => <div key={cardIndex} className="w-10 h-12 rounded opacity-0 transform scale-90 hover:scale-105 transition-transform duration-200" style={{
                        animation: `fadeIn 0.3s ease-out ${baseDelay + 0.8 + cardIndex * 0.05}s forwards, scaleIn 0.3s ease-out ${baseDelay + 0.8 + cardIndex * 0.05}s forwards`
                      }} dangerouslySetInnerHTML={{
                        __html: getCardSVGContent(card)
                      }} />)}
                                {player.cards.length === 0 && <span className="text-green-400 font-bold opacity-0" style={{
                        animation: `fadeIn 0.4s ease-out ${baseDelay + 0.8}s forwards`
                      }}>ðŸŽ‰ NO CARDS LEFT!</span>}
                              </div>
                            </div>;
                })}
                      </div>
                      {}
                      <div className="text-center opacity-0 transform translateY-4" style={{
                animation: `fadeInUp 0.8s ease-out ${2.2 + (roundEndData || gameData.roundEndData).players.length * 0.4}s forwards`
              }}>
                        <div className="text-lg text-red-400 mb-2">
                          Player with highest card total ({(roundEndData || gameData.roundEndData).maxCards} points) is eliminated:
                        </div>
                        <div className="text-2xl font-bold text-red-400 opacity-0" style={{
                  animation: `bounceIn 0.6s ease-out ${2.4 + (roundEndData || gameData.roundEndData).players.length * 0.4}s forwards`
                }}>
                          {(roundEndData || gameData.roundEndData).eliminatedPlayer.name}
                        </div>
                      </div>
                      {}
                      <div className="mt-6 bg-gray-700 rounded-full h-3 opacity-0" style={{
                animation: `fadeIn 0.5s ease-out ${2.8 + (roundEndData || gameData.roundEndData).players.length * 0.4}s forwards`
              }}>
                        <div className="bg-gradient-to-r from-[#80142C] to-red-500 h-3 rounded-full w-0" style={{
                  animation: `progressFill 7s ease-out ${3.2 + (roundEndData || gameData.roundEndData).players.length * 0.4}s forwards`
                }}></div>
                      </div>
                      <div className="text-center mt-2 text-sm text-gray-400 opacity-0" style={{
                animation: `fadeIn 0.5s ease-out ${3 + (roundEndData || gameData.roundEndData).players.length * 0.4}s forwards`
              }}>
                        {gameData.gamePhase === 'gameEnd' ? 'Game ending...' : 'Next round starting...'}
                      </div>
                    </div>
                  </div>
                </div>}
              {showAdminDeckOverview && isAdmin && <div className="absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[100] fade-in">
                  <div className="bg-black p-6 rounded-2xl border-2 border-[#80142C] max-w-7xl max-h-[90vh] overflow-y-auto scale-in">
                    <div className="bg-[#80142C] p-4 rounded-xl">
                      <div className="flex justify-between items-center mb-4">
                        <h2 className="text-2xl font-bold text-white">Admin - All Card Distributions</h2>
                        <button onClick={() => setShowAdminDeckOverview(false)} className="text-white hover:text-gray-300 transition-colors duration-200 text-2xl">
                          Ã—
                        </button>
                      </div>
                      <div className="space-y-6">
                        {}
                        <div className="bg-black p-4 rounded-xl">
                          <h3 className="text-lg font-bold text-white mb-3 flex items-center">
                            <span className="w-6 h-6 bg-green-600 flex items-center justify-center mr-2 rounded text-xs">P</span>
                            Play Pile ({gameData.playPile.length} cards)
                          </h3>
                          <div className="flex flex-wrap gap-2 max-h-32 overflow-y-auto">
                            {gameData.playPile.length === 0 ? <span className="text-gray-400 italic">Empty</span> : gameData.playPile.map((card, index) => <div key={`play-pile-${index}`} className="w-12 h-16 rounded shadow-lg" title={`${card.number}${card.shape}${card.chosenShape ? ` (chosen: ${card.chosenShape})` : ''}`}>
                                  <div className="flex items-center justify-center w-full h-full text-[8px]" dangerouslySetInnerHTML={{
                        __html: getCardSVGContent(card)
                      }} />
                                </div>)}
                          </div>
                        </div>
                        {}
                        <div className="bg-black p-4 rounded-xl">
                          <h3 className="text-lg font-bold text-white mb-3 flex items-center">
                            <span className="w-6 h-6 bg-blue-600 flex items-center justify-center mr-2 rounded text-xs">M</span>
                            Market Deck ({gameData.drawPile.length} cards)
                          </h3>
                          <div className="grid grid-cols-8 md:grid-cols-12 lg:grid-cols-16 gap-1 max-h-48 overflow-y-auto">
                            {gameData.drawPile.length === 0 ? <span className="text-gray-400 italic col-span-full">Empty</span> : gameData.drawPile.map((card, index) => <div key={`market-${index}`} className="w-10 h-14 rounded shadow" title={`${card.number}${card.shape}`}>
                                  <div className="flex items-center justify-center w-full h-full text-[6px]" dangerouslySetInnerHTML={{
                        __html: getCardSVGContent(card)
                      }} />
                                </div>)}
                          </div>
                        </div>
                        {}
                        {gameData.players.map((player, playerIndex) => <div key={player.id} className="bg-black p-4 rounded-xl">
                            <h3 className="text-lg font-bold text-white mb-3 flex items-center">
                              <span className={`w-6 h-6 flex items-center justify-center mr-2 rounded text-xs ${player.eliminated ? 'bg-red-600' : gameData.currentPlayer === playerIndex ? 'bg-yellow-600' : 'bg-gray-600'}`}>
                                {playerIndex + 1}
                              </span>
                              {player.name} ({player.cards.length} cards)
                              {player.eliminated && <span className="ml-2 text-red-400 text-sm">[ELIMINATED]</span>}
                              {gameData.currentPlayer === playerIndex && !isAnyAnimationInProgress && <span className="ml-2 text-yellow-400 text-sm">[CURRENT TURN]</span>}
                            </h3>
                            <div className="grid grid-cols-6 md:grid-cols-10 lg:grid-cols-14 gap-1 max-h-32 overflow-y-auto">
                              {player.cards.length === 0 ? <span className="text-gray-400 italic col-span-full">No cards</span> : player.cards.map((card, cardIndex) => <div key={`player-${player.id}-${cardIndex}`} className="w-10 h-14 rounded shadow" title={`${card.number}${card.shape}${card.special ? ` (${card.special})` : ''}`}>
                                    <div className="flex items-center justify-center w-full h-full text-[6px]" dangerouslySetInnerHTML={{
                        __html: getCardSVGContent(card)
                      }} />
                                  </div>)}
                            </div>
                          </div>)}
                      </div>
                      <div className="mt-6 text-center">
                        <button onClick={() => setShowAdminDeckOverview(false)} className="px-6 py-2 bg-[#80142C] text-white rounded-xl smooth-transition font-bold hover:bg-[#4a0c1a]">
                          Close Overview
                        </button>
                      </div>
                    </div>
                  </div>
                </div>}
              {showGameLog && <div className="absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[100] fade-in">
                  <div className="bg-black p-6 rounded-2xl border-2 border-[#80142C] max-w-4xl max-h-[80vh] overflow-y-auto scale-in">
                    <div className="bg-[#80142C] p-4 rounded-xl">
                    <div className="flex justify-between items-center mb-4">
                      <h2 className="text-2xl font-bold text-white">Game Log</h2>
                      <button onClick={() => setShowGameLog(false)} className="text-white hover:text-gray-300 transition-colors duration-200 text-2xl">
                        Ã—
                      </button>
                    </div>
                    {}
                    <div className="flex gap-2 mb-4 overflow-x-auto">
                      {Object.keys(gameData.gameLog).map(round => <button key={round} onClick={() => setSelectedLogRound(parseInt(round))} className={`px-4 py-2 rounded-xl font-bold whitespace-nowrap transition-colors duration-200 ${selectedLogRound === parseInt(round) ? 'bg-[#80142C] text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>
                          Round {round}
                        </button>)}
                    </div>
                    <div className="bg-gray-800 rounded-xl p-4 max-h-96 overflow-y-auto">
                      {(gameData.gameLog[selectedLogRound] || []).map((log, index) => <div key={index} className="text-gray-300 text-sm mb-2 border-b border-gray-700 pb-2 last:border-b-0">
                          <span className="text-red-400 font-mono text-xs mr-2">{String(index + 1).padStart(2, '0')}.</span>
                          {log}
                        </div>)}
                      {(!gameData.gameLog[selectedLogRound] || gameData.gameLog[selectedLogRound].length === 0) && <div className="text-gray-500 text-center py-4">No actions recorded for this round yet</div>}
                    </div>
                    <div className="mt-4 text-center">
                        <button onClick={() => setShowGameLog(false)} className="px-6 py-2 bg-[#80142C] text-white rounded-xl smooth-transition font-bold hover:bg-[#4a0c1a]">
                          Close Log
                        </button>
                      </div>
                    </div>
                  </div>
                </div>}
              {gameData.gamePhase === 'gameEnd' && <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[100] fade-in">
                  <div className="text-center text-white scale-in">
                    <h1 className="text-6xl font-bold mb-4" style={{
              textShadow: '4px 4px 8px rgba(0,0,0,0.8)',
              color: gameData.winner.id === currentUser?.id ? '#80142C' : '#666'
            }}>
                      {gameData.winner.id === currentUser?.id ? 'VICTORY!' : 'DEFEAT'}
                    </h1>
                    <p className="text-2xl mb-6">{gameData.winner.name} emerges from the shadows</p>
                    {}
                    {(() => {
              const roundsPlayed = gameData.roundNumber;
              const cardsPlayed = 20;
              const xpGained = getXPFromGame(gameData.winner.id === currentUser?.id, roundsPlayed, cardsPlayed);
              return <div className="bg-black bg-opacity-60 p-4 rounded-xl mb-6">
                          <div className="text-lg font-bold text-yellow-400 mb-2">XP Gained: +{xpGained}</div>
                          <div className="text-sm text-gray-300">
                            Base XP: 50 â€¢ {gameData.winner.id === currentUser?.id ? 'Victory Bonus: +100 â€¢ ' : ''}
                            Rounds: +{roundsPlayed * 25} â€¢ Cards: +{Math.floor(cardsPlayed / 5) * 10}
                          </div>
                        </div>;
            })()}
                    <div className="space-y-2 mb-8 max-h-40 overflow-y-auto">
                      {Object.values(gameData.gameLog).flat().slice(-5).map((log, index) => <div key={index} className="text-gray-400 text-sm">{log}</div>)}
                    </div>
                    <div className="text-center mb-6">
                      <p className="text-lg text-gray-300">
                        {currentRoom ? 'Returning to room lobby in a few seconds...' : 'Game completed!'}
                      </p>
                    </div>
                    <button onClick={() => {
              if (currentRoom) {
                setGameData(null);
                setGameState('room');
              } else {
                setGameState('menu');
                setGameData(null);
              }
              setShowWhotChoice(false);
              setPendingWhotCard(null);
              setAnimatingCards([]);
              setPlayerScrollIndex(0);
              setShowDeckView(false);
              setShowEliminatedPopup(false);
              setShowRoundEndPopup(false);
              setRoundEndData(null);
              setShowGameLog(false);
              setSelectedLogRound(1);
              setIsPlayerActionInProgress(false);
              setIsAITurnInProgress(false);
              setIsAnyAnimationInProgress(false);
              setActivePopup(null);
              setAdminCardsRevealed(false);
              setAdminMarketRevealed(false);
              setShowAdminDeckOverview(false);
              setConfettiActive(false);
              setPlayPileCardPositions({});
              marketCardPositionsRef.current = [];
              playPilePositionsRef.current = [];
              setMarketCardPositions([]);
              setPlayPilePositions([]);
              setNeedNewMarketPositions(false);
            }} className="px-8 py-3 bg-[#80142C] text-white rounded-xl smooth-transition font-bold hover:bg-[#4a0c1a]">
                      {currentRoom ? 'Return to Room' : 'Return to Arena'}
                    </button>
                  </div>
                </div>}
              </div> : null}
        {}
        {showHelp && <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[100] p-4 fade-in" onClick={() => setShowHelp(false)}>
          <div className="relative w-full max-w-4xl max-h-[90vh] overflow-y-auto rounded-xl scale-in" onClick={e => e.stopPropagation()}>
            <div className="bg-black rounded-xl">
              <div className="p-8 bg-[#80142C] rounded-t-xl">
                <button onClick={() => setShowHelp(false)} className="absolute top-4 right-4 text-white hover:text-gray-300 transition-all duration-300 text-2xl">Ã—</button>
                <div className="text-center mb-10">
                  <h1 className="text-4xl font-bold mb-2 text-white">
                    Game Guide & Rules
                  </h1>
                  <div className="text-gray-200 text-lg tracking-wider">
                    Everything You Need to Know
                  </div>
                </div>
                <div className="max-w-5xl mx-auto space-y-8">
                  {}
                  <div className="bg-black p-6 rounded-xl">
                    <h3 className="text-2xl font-bold text-white mb-4 flex items-center">
                      <span className="w-8 h-8 bg-blue-600 flex items-center justify-center mr-3 rounded-lg text-white text-sm">ðŸ“š</span>
                      Basic Rules
                    </h3>
                    <div className="text-gray-300 space-y-3">
                      <p><strong>Objective:</strong> Be the first player to play all your cards to win the round.</p>
                      <p><strong>Setup:</strong> 4 players start with 6 cards each. One card is dealt to start the play pile.</p>
                      <p><strong>Playing:</strong> Match the top card by either <strong>shape</strong> or <strong>number</strong>.</p>
                      <p><strong>Drawing:</strong> If you can't play, draw from the market (deck) until you can play or pass.</p>
                      <p><strong>Elimination:</strong> When a round ends, the player(s) with the most cards are eliminated.</p>
                      <p><strong>Victory:</strong> The last player remaining wins the entire game!</p>
                    </div>
                  </div>
                  {}
                  <div className="bg-black p-6 rounded-xl">
                    <h3 className="text-2xl font-bold text-white mb-4 flex items-center">
                      <span className="w-8 h-8 bg-purple-600 flex items-center justify-center mr-3 rounded-lg text-white text-sm">âœ¨</span>
                      Special Cards
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-300">
                      <div className="bg-gray-800 p-4 rounded-lg">
                        <h4 className="font-bold text-yellow-400 mb-2">ðŸ”¥ WHOT Card</h4>
                        <p>Can be played on any card. Choose the next shape when played.</p>
                      </div>
                      <div className="bg-gray-800 p-4 rounded-lg">
                        <h4 className="font-bold text-[#80142C] mb-2">2 - Pick Two</h4>
                        <p>Next player must draw 2 cards from the market.</p>
                      </div>
                      <div className="bg-gray-800 p-4 rounded-lg">
                        <h4 className="font-bold text-blue-400 mb-2">1 - Hold On</h4>
                        <p>Next player's turn is skipped entirely.</p>
                      </div>
                      <div className="bg-gray-800 p-4 rounded-lg">
                        <h4 className="font-bold text-green-400 mb-2">14 - General Market</h4>
                        <p>ALL other players must draw 1 card from market.</p>
                      </div>
                    </div>
                  </div>
                  {}
                  <div className="bg-black p-6 rounded-xl">
                    <h3 className="text-2xl font-bold text-white mb-4 flex items-center">
                      <span className="w-8 h-8 bg-green-600 flex items-center justify-center mr-3 rounded-lg text-white text-sm">ðŸ”·</span>
                      Card Shapes & Numbers
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 text-gray-300">
                      <div>
                        <h4 className="font-bold text-white mb-3">Available Shapes:</h4>
                        <div className="space-y-2">
                          <div className="flex items-center"><span className="text-2xl mr-3">â—</span> Circle</div>
                          <div className="flex items-center"><span className="text-2xl mr-3">â–²</span> Triangle</div>
                          <div className="flex items-center"><span className="text-2xl mr-3">âœš</span> Cross</div>
                          <div className="flex items-center"><span className="text-2xl mr-3">â– </span> Square</div>
                          <div className="flex items-center"><span className="text-2xl mr-3">â˜…</span> Star</div>
                        </div>
                      </div>
                      <div>
                        <h4 className="font-bold text-white mb-3">Number Distribution:</h4>
                        <div className="text-sm space-y-1">
                          <div><strong>Circles & Triangles:</strong> 1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14</div>
                          <div><strong>Crosses & Squares:</strong> 1, 2, 3, 5, 7, 10, 11, 13, 14</div>
                          <div><strong>Stars:</strong> 1, 2, 3, 4, 5, 7, 8</div>
                          <div><strong>WHOT:</strong> 5 special cards</div>
                        </div>
                      </div>
                    </div>
                  </div>
                  {}
                  <div className="bg-black p-6 rounded-xl">
                    <h3 className="text-2xl font-bold text-white mb-4 flex items-center">
                      <span className="w-8 h-8 bg-yellow-600 flex items-center justify-center mr-3 rounded-lg text-white text-sm">â­</span>
                      XP & Progress System
                    </h3>
                    <div className="space-y-4 text-gray-300">
                      <div className="bg-gray-800 p-4 rounded-lg">
                        <h4 className="font-bold text-yellow-400 mb-2">How to Earn XP:</h4>
                        <ul className="space-y-1 text-sm">
                          <li>â€¢ <strong>Playing a game:</strong> 50 XP base</li>
                          <li>â€¢ <strong>Winning a game:</strong> +100 XP bonus</li>
                          <li>â€¢ <strong>Surviving rounds:</strong> +25 XP per round</li>
                          <li>â€¢ <strong>Playing cards:</strong> +10 XP per 5 cards played</li>
                          <li>â€¢ <strong>Claiming achievements:</strong> 100-5000 XP each</li>
                        </ul>
                      </div>
                      <div className="bg-gray-800 p-4 rounded-lg">
                        <h4 className="font-bold text-blue-400 mb-2">Level System (1-100):</h4>
                        <ul className="space-y-1 text-sm">
                          <li>â€¢ <strong>Progressive XP Requirements:</strong> Each level needs more XP than the last</li>
                          <li>â€¢ <strong>Level 1-10:</strong> 100-1600 XP per level</li>
                          <li>â€¢ <strong>Level 11-50:</strong> 1750-6000 XP per level</li>
                          <li>â€¢ <strong>Level 51-100:</strong> 6500-14000+ XP per level</li>
                          <li>â€¢ <strong>Max Level 100:</strong> Ultimate bragging rights!</li>
                        </ul>
                      </div>
                      <div className="bg-gray-800 p-4 rounded-lg">
                        <h4 className="font-bold text-green-400 mb-2">Achievements & Rewards:</h4>
                        <p className="text-sm">Complete specific challenges to unlock achievements worth hundreds or thousands of XP. From first victories to legendary milestones!</p>
                      </div>
                    </div>
                  </div>
                  {}
                  <div className="bg-black p-6 rounded-xl">
                    <h3 className="text-2xl font-bold text-white mb-4 flex items-center">
                      <span className="w-8 h-8 bg-orange-600 flex items-center justify-center mr-3 rounded-lg text-white text-sm">ðŸ’¡</span>
                      Pro Tips & Strategy
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-300 text-sm">
                      <div className="space-y-2">
                        <p><strong>â€¢ Save WHOT cards</strong> for when you're stuck or for strategic shape changes</p>
                        <p><strong>â€¢ Watch opponents' cards</strong> to predict what they might play</p>
                        <p><strong>â€¢ Use special cards wisely</strong> - timing is everything</p>
                        <p><strong>â€¢ Count cards</strong> to know what's still in play</p>
                      </div>
                      <div className="space-y-2">
                        <p><strong>â€¢ Play high numbers early</strong> when you have multiple options</p>
                        <p><strong>â€¢ Keep variety</strong> in shapes to avoid being stuck</p>
                        <p><strong>â€¢ Last card advantage</strong> - plan your final moves carefully</p>
                        <p><strong>â€¢ General Market timing</strong> can eliminate opponents quickly</p>
                      </div>
                    </div>
                  </div>
                  {}
                  <div className="bg-black p-6 rounded-xl">
                    <h3 className="text-2xl font-bold text-white mb-4 flex items-center">
                      <span className="w-8 h-8 bg-red-600 flex items-center justify-center mr-3 rounded-lg text-white text-sm">ðŸŽ®</span>
                      Game Controls
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-300 text-sm">
                      <div className="space-y-2">
                        <p><strong>â€¢ Click cards to play</strong> them (if valid)</p>
                        <p><strong>â€¢ Click market deck</strong> to draw cards</p>
                        <p><strong>â€¢ Use scroll arrows</strong> to navigate your hand</p>
                        <p><strong>â€¢ Grid icon</strong> opens full deck view</p>
                      </div>
                      <div className="space-y-2">
                        <p><strong>â€¢ Red glow on market</strong> means you must draw</p>
                        <p><strong>â€¢ Playable cards</strong> are highlighted</p>
                        <p><strong>â€¢ Red dots</strong> show playable cards outside view</p>
                        <p><strong>â€¢ Game log</strong> tracks all moves</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="mt-8 text-center">
                  <button onClick={() => setShowHelp(false)} className="px-8 py-3 bg-[#80142C] text-white rounded-xl font-bold hover:bg-[#4a0c1a] transition-colors">
                    Start Playing!
                  </button>
                  <p className="text-gray-200 italic mt-4">
                    Master the ancient game of Whot and climb the legendary ranks!
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>}
      </div>
    </div>;
}